Java
About the Tutorial
Java is a high-level programming language originally developed by Sun Microsystems and
released in 1995. Java runs on a variety of platforms, such as Windows, Mac OS, and the
various versions of UNIX. This tutorial gives a complete understanding of Java.
This reference will take you through simple and practical approaches while learning Java
Programming language.
Audience
This tutorial has been prepared for the beginners to help them understand the basic to
advanced concepts related to Java Programming language.
Prerequisites
Before you start practicing various types of examples given in this reference, we assume
that you are already aware about computer programs and computer programming
languages.
Execute Java Online
For most of the examples given in this tutorial, you will find a ‘Try it’ option, which you
can use to execute your Java programs at the spot and enjoy your learning.
Try following the example using the ‘Try it’ option available at the top right corner of the
following sample code box −
public class MyFirstJavaProgram {
public static void main(String []args) {
System.out.println("Hello World");
}
}
iJava
Table of Contents
About the Tutorial ............................................................................................................................................ i
Audience ........................................................................................................................................................... i
Prerequisites ..................................................................................................................................................... i
Execute Java Online .......................................................................................................................................... i
Table of Contents ............................................................................................................................................ ii
JAVA – BASICS ............................................................................................................................. 1
1. Java – Overview ........................................................................................................................................ 2
History of Java ................................................................................................................................................. 3
Tools You Will Need ......................................................................................................................................... 3
Try It Option .................................................................................................................................................... 4
What is Next? .................................................................................................................................................. 4
2. Java - Environment Setup ......................................................................................................................... 5
Try it Option Online ......................................................................................................................................... 5
Local Environment Setup ................................................................................................................................. 5
Popular Java Editors ........................................................................................................................................ 6
What is Next? .................................................................................................................................................. 6
3. Java – Basic Syntax .................................................................................................................................... 7
First Java Program ........................................................................................................................................... 7
Basic Syntax ..................................................................................................................................................... 8
Java Identifiers ................................................................................................................................................. 9
Java Modifiers.................................................................................................................................................. 9
Java Variables .................................................................................................................................................. 9
Java Arrays ....................................................................................................................................................... 9
Java Enums .................................................................................................................................................... 10
Java Keywords ............................................................................................................................................... 10
Comments in Java .......................................................................................................................................... 11
Using Blank Lines ........................................................................................................................................... 12
Inheritance .................................................................................................................................................... 12
Interfaces ....................................................................................................................................................... 12
What is Next? ................................................................................................................................................ 12
4. Java – Objects & Classes.......................................................................................................................... 13
Objects in Java ............................................................................................................................................... 13
Classes in Java ................................................................................................................................................ 14
Constructors .................................................................................................................................................. 14
How to Use Singleton Class? ......................................................................................................................... 15
Creating an Object ......................................................................................................................................... 17
Accessing Instance Variables and Methods ................................................................................................... 18
Source File Declaration Rules ........................................................................................................................ 20
Java Package .................................................................................................................................................. 20
Import Statements ........................................................................................................................................ 21
A Simple Case Study ...................................................................................................................................... 21
What is Next? ................................................................................................................................................ 23
iiJava
5. Java – Basic Datatypes ............................................................................................................................ 24
Primitive Datatypes ....................................................................................................................................... 24
Reference Datatypes ..................................................................................................................................... 26
Java Literals ................................................................................................................................................... 26
What is Next? ................................................................................................................................................ 28
6. Java – Variable Types .............................................................................................................................. 29
Local Variables ............................................................................................................................................... 29
Instance Variables ......................................................................................................................................... 31
Class/static Variables ..................................................................................................................................... 33
What is Next? ................................................................................................................................................ 34
7. Java – Modifier Types ............................................................................................................................. 35
Java Access Modifiers .................................................................................................................................... 35
Java Non-Access Modifiers ............................................................................................................................ 38
The Static Modifier ........................................................................................................................................ 38
The Final Modifier ......................................................................................................................................... 39
The Abstract Modifier.................................................................................................................................... 41
Access Control Modifiers ............................................................................................................................... 43
Non-Access Modifiers .................................................................................................................................... 44
What is Next? ................................................................................................................................................ 44
8. Java – Basic Operators ............................................................................................................................ 45
The Arithmetic Operators .............................................................................................................................. 45
The Relational Operators............................................................................................................................... 47
The Bitwise Operators ................................................................................................................................... 49
The Logical Operators .................................................................................................................................... 52
The Assignment Operators ............................................................................................................................ 53
Miscellaneous Operators ............................................................................................................................... 57
Precedence of Java Operators ....................................................................................................................... 59
What is Next? ................................................................................................................................................ 59
9. Java – Loop Control ................................................................................................................................. 60
While Loop in Java ......................................................................................................................................... 61
for Loop in Java .............................................................................................................................................. 62
Do While Loop in Java ................................................................................................................................... 65
Loop Control Statements ............................................................................................................................... 67
Break Statement in Java ................................................................................................................................ 67
Continue Statement in Java ........................................................................................................................... 69
Enhanced for loop in Java .............................................................................................................................. 70
What is Next? ................................................................................................................................................ 71
10. Java – Decision Making ........................................................................................................................... 72
If Statement in Java ....................................................................................................................................... 73
If-else Statement in Java................................................................................................................................ 74
The if...else if...else Statement ...................................................................................................................... 76
Nested if Statement in Java ........................................................................................................................... 77
Switch Statement in Java ............................................................................................................................... 78
The ? : Operator: ........................................................................................................................................... 80
What is Next? ................................................................................................................................................ 81
iiiJava
11. Java – Numbers Class .............................................................................................................................. 82
Number Methods .......................................................................................................................................... 83
Java XXXValue Method .................................................................................................................................. 86
Java – compareTo() Method .......................................................................................................................... 87
Java – equals() Method ................................................................................................................................. 88
Java – valueOf() Method ............................................................................................................................... 89
Java – toString() Method ............................................................................................................................... 91
Java – parseInt() Method ............................................................................................................................... 92
Java – abs() Method ...................................................................................................................................... 93
Java – ceil() Method ...................................................................................................................................... 94
Java – floor() Method .................................................................................................................................... 95
Java – rint() Method ...................................................................................................................................... 96
Java – round() Method .................................................................................................................................. 97
Java – min() Method ...................................................................................................................................... 98
Java – max() Method ..................................................................................................................................... 99
Java – exp() Method .................................................................................................................................... 100
Java – log() Method ..................................................................................................................................... 101
Java – pow() Method ................................................................................................................................... 102
Java – sqrt() Method .................................................................................................................................... 103
Java – sin() Method ..................................................................................................................................... 104
Java – cos() Method ..................................................................................................................................... 105
Java – tan() Method ..................................................................................................................................... 106
Java – asin() Method ................................................................................................................................... 107
Java – acos() Method ................................................................................................................................... 108
Java – atan() Method ................................................................................................................................... 109
Java – atan2() Method ................................................................................................................................. 110
Java – toDegrees() Method ......................................................................................................................... 111
Java – toRadians() Method .......................................................................................................................... 112
Java – random() Method ............................................................................................................................. 113
What is Next? .............................................................................................................................................. 114
12. Java – Character Class ........................................................................................................................... 115
Escape Sequences ........................................................................................................................................ 115
Character Methods ...................................................................................................................................... 117
Java – isLetter() Method .............................................................................................................................. 117
Java – isDigit() Method ................................................................................................................................ 118
Java – isWhitespace() Method .................................................................................................................... 119
Java – isUpperCase() Method ...................................................................................................................... 120
Java – isLowerCase() Method ...................................................................................................................... 121
Java – toUpperCase() Method ..................................................................................................................... 122
Java – toLowerCase() Method ..................................................................................................................... 123
Java – toString() Method ............................................................................................................................. 124
What is Next? .............................................................................................................................................. 125
13. Java – Strings Class ................................................................................................................................ 126
Creating Strings ........................................................................................................................................... 126
Java – String Buffer & String Builder Classes ............................................................................................... 126
StringBuffer Methods .................................................................................................................................. 127
Java – String Buffer append() Method ........................................................................................................ 128
Java – String Buffer reverse() Method ......................................................................................................... 129
ivJava
Java – String Buffer delete() Method .......................................................................................................... 130
Java – String Buffer insert() Method ........................................................................................................... 131
Java – String Buffer replace() Method ......................................................................................................... 132
String Length................................................................................................................................................ 135
Concatenating Strings .................................................................................................................................. 136
Creating Format Strings ............................................................................................................................... 136
String Methods ............................................................................................................................................ 137
Java – String chartAt() Method .................................................................................................................... 142
Java – String compareTo(Object o) Method ................................................................................................ 143
Java – String compareTo(String anotherString) Method ............................................................................. 144
Java – String compareToIgnoreCase() Method ........................................................................................... 145
Java – String concat() Method ..................................................................................................................... 146
Java – String contentEquals() Method ......................................................................................................... 147
Java – String copyValueOf(char[] data) Method ......................................................................................... 148
Java – String copyValueOf(char[] data, int offset, int count) Method......................................................... 149
Java – String endsWith() Method ................................................................................................................ 150
Java – String equals() Method ..................................................................................................................... 151
Java – String equalsIgnoreCase() Method ................................................................................................... 152
Java – String getBytes(String charsetName) Method .................................................................................. 154
Java – String getBytes() Method .................................................................................................................. 155
Java – String getChars() Method ................................................................................................................. 156
Java – String hashCode() Method ................................................................................................................ 157
Java – String indexOf(int ch) Method .......................................................................................................... 158
Java – String indexOf(int ch, int fromIndex) Method .................................................................................. 159
Java – String indexOf(String str) Method .................................................................................................... 160
Java – String indexOf(String str, int fromIndex) Method ............................................................................. 161
Java – String Intern() Method ...................................................................................................................... 162
Java – String lastIndexOf(int ch) Method .................................................................................................... 163
Java – String lastIndexOf(int ch, int fromIndex) Method ............................................................................ 164
Java – String lastIndexOf(String str) Method ............................................................................................... 165
Java – String lastIndexOf(String str, int fromIndex) Method ....................................................................... 166
Java – String length() Method ..................................................................................................................... 167
Java – String matches() Method .................................................................................................................. 168
Java – String regionMatches() Method ....................................................................................................... 169
Java – String regionMatches() Method ....................................................................................................... 171
Java – String replace() Method .................................................................................................................... 173
Java – String replaceAll() Method ................................................................................................................ 174
Java – String replaceFirst() Method ............................................................................................................. 175
Java – String split() Method ......................................................................................................................... 176
Java – String split() Method ......................................................................................................................... 178
Java – String startsWith() Method ............................................................................................................... 180
Java – String startsWith() Method ............................................................................................................... 181
Java – String subsequence() Method .......................................................................................................... 182
Java – String substring() Method ................................................................................................................. 183
Java – String substring() Method ................................................................................................................. 184
Java – String toCharArray() Method ............................................................................................................ 186
Java – String toLowerCase() Method ........................................................................................................... 187
Java – String toLowerCase() Method ........................................................................................................... 188
Java – String toString() Method ................................................................................................................... 189
Java – String toUpperCase() Method ........................................................................................................... 189
vJava
Java – String toUpperCase() Method ........................................................................................................... 190
Java – String trim() Method ......................................................................................................................... 191
Java – String valueOf() Method ................................................................................................................... 192
14. Java – Arrays ......................................................................................................................................... 196
Declaring Array Variables ............................................................................................................................ 196
Creating Arrays ............................................................................................................................................ 196
Processing Arrays ........................................................................................................................................ 198
The foreach Loops ....................................................................................................................................... 199
Passing Arrays to Methods .......................................................................................................................... 199
Returning an Array from a Method ............................................................................................................. 200
The Arrays Class ........................................................................................................................................... 200
15. Java – Date & Time ............................................................................................................................... 202
Getting Current Date & Time....................................................................................................................... 203
Date Comparison ......................................................................................................................................... 204
Simple DateFormat Format Codes .............................................................................................................. 205
Date and Time Conversion Characters ........................................................................................................ 208
Parsing Strings into Dates ............................................................................................................................ 209
Sleeping for a While .................................................................................................................................... 210
Measuring Elapsed Time ............................................................................................................................. 211
GregorianCalendar Class ............................................................................................................................. 212
16. Java – Regular Expressions .................................................................................................................... 218
Capturing Groups ........................................................................................................................................ 218
Regular Expression Syntax ........................................................................................................................... 220
Methods of the Matcher Class .................................................................................................................... 223
17. Java – Methods ..................................................................................................................................... 230
Creating Method ......................................................................................................................................... 230
Method Calling ............................................................................................................................................ 231
The void Keyword ........................................................................................................................................ 232
Passing Parameters by Value ....................................................................................................................... 233
Method Overloading ................................................................................................................................... 235
Using Command-Line Arguments ................................................................................................................ 236
The Constructors ......................................................................................................................................... 237
Parameterized Constructor ......................................................................................................................... 238
The this keyword ......................................................................................................................................... 239
Variable Arguments(var-args) ..................................................................................................................... 242
The finalize( ) Method ................................................................................................................................. 243
18. Java – Files and I/O ............................................................................................................................... 244
Stream ......................................................................................................................................................... 244
Standard Streams ........................................................................................................................................ 247
Reading and Writing Files ............................................................................................................................ 248
ByteArrayInputStream ................................................................................................................................. 250
DataInputStream ......................................................................................................................................... 253
FileOutputStream ........................................................................................................................................ 255
ByteArrayOutputStream .............................................................................................................................. 256
DataOutputStream ...................................................................................................................................... 259
File Navigation and I/O ................................................................................................................................ 261
viJava
File Class ...................................................................................................................................................... 262
Directories in Java........................................................................................................................................ 272
Listing Directories ........................................................................................................................................ 273
19. Java – Exceptions .................................................................................................................................. 274
Exception Hierarchy..................................................................................................................................... 275
Built-in Exceptions ....................................................................................................................................... 276
Exceptions Methods .................................................................................................................................... 278
Catching Exceptions ..................................................................................................................................... 279
Multiple Catch Blocks .................................................................................................................................. 280
Catching Multiple Type of Exceptions ......................................................................................................... 281
The Throws/Throw Keywords ..................................................................................................................... 281
The Finally Block .......................................................................................................................................... 282
The try-with-resources ................................................................................................................................ 284
User-defined Exceptions .............................................................................................................................. 286
Common Exceptions .................................................................................................................................... 289
20. Java – Inner Classes ............................................................................................................................... 290
Nested Classes ............................................................................................................................................. 290
Inner Classes (Non-static Nested Classes) ................................................................................................... 291
Accessing the Private Members .................................................................................................................. 292
Method-local Inner Class ............................................................................................................................. 293
Anonymous Inner Class ............................................................................................................................... 294
Anonymous Inner Class as Argument .......................................................................................................... 295
Static Nested Class....................................................................................................................................... 296
JAVA - OBJECT ORIENTED ........................................................................................................ 299
21. Java – Inheritance ................................................................................................................................. 300
extends Keyword ......................................................................................................................................... 300
Sample Code ................................................................................................................................................ 300
The super keyword ...................................................................................................................................... 302
Invoking Superclass Constructor ................................................................................................................. 305
IS-A Relationship .......................................................................................................................................... 306
The instanceof Keyword .............................................................................................................................. 308
HAS-A relationship ....................................................................................................................................... 309
Types of Inheritance .................................................................................................................................... 309
22. Java – Overriding .................................................................................................................................. 311
Rules for Method Overriding ....................................................................................................................... 313
Using the super Keyword ............................................................................................................................ 314
23. Java – Polymorphism ............................................................................................................................ 315
Virtual Methods ........................................................................................................................................... 316
24. Java – Abstraction ................................................................................................................................. 320
Abstract Class .............................................................................................................................................. 320
Inheriting the Abstract Class........................................................................................................................ 323
Abstract Methods ........................................................................................................................................ 324
viiJava
25. Java – Encapsulation ............................................................................................................................. 326
Benefits of Encapsulation ............................................................................................................................ 328
26. Java – Interfaces ................................................................................................................................... 329
Declaring Interfaces ..................................................................................................................................... 330
Implementing Interfaces ............................................................................................................................. 330
Extending Interfaces .................................................................................................................................... 332
Extending Multiple Interfaces ..................................................................................................................... 333
Tagging Interfaces ....................................................................................................................................... 333
27. Java – Packages ..................................................................................................................................... 334
Creating a Package ...................................................................................................................................... 334
The import Keyword .................................................................................................................................... 336
The Directory Structure of Packages ........................................................................................................... 337
Set CLASSPATH System Variable.................................................................................................................. 339
JAVA – ADVANCED .................................................................................................................. 340
28. Java – Data Structures ........................................................................................................................... 341
The Enumeration ......................................................................................................................................... 341
The BitSet .................................................................................................................................................... 343
The Vector ................................................................................................................................................... 348
The Stack ..................................................................................................................................................... 355
The Dictionary ............................................................................................................................................. 358
The Hashtable .............................................................................................................................................. 362
The Properties ............................................................................................................................................. 366
29. Java – Collections Framework ............................................................................................................... 370
The Collection Interfaces ............................................................................................................................. 371
The Collection Interface .............................................................................................................................. 372
The List Interface ......................................................................................................................................... 375
The Set Interface ......................................................................................................................................... 378
The SortedSet Interface ............................................................................................................................... 380
The Map Interface ....................................................................................................................................... 382
The Map.Entry Interface .............................................................................................................................. 384
The SortedMap Interface ............................................................................................................................ 386
The Enumeration Interface.......................................................................................................................... 388
The Collection Classes ................................................................................................................................. 389
The LinkedList Class ..................................................................................................................................... 391
The ArrayList Class ....................................................................................................................................... 395
The HashSet Class ........................................................................................................................................ 399
The LinkedHashSet Class ............................................................................................................................. 402
The TreeSet Class ......................................................................................................................................... 403
The HashMap Class ...................................................................................................................................... 406
The TreeMap Class ...................................................................................................................................... 409
The WeakHashMap Class ............................................................................................................................ 412
The LinkedHashMap Class ........................................................................................................................... 415
The IdentityHashMap Class ......................................................................................................................... 418
The Vector Class .......................................................................................................................................... 422
The Stack Class ............................................................................................................................................ 428
viiiJava
The Dictionary Class .................................................................................................................................... 430
The Map Interface ....................................................................................................................................... 431
The Hashtable Class ..................................................................................................................................... 433
The Properties Class .................................................................................................................................... 437
The BitSet Class ........................................................................................................................................... 440
The Collection Algorithms ........................................................................................................................... 444
How to Use an Iterator ? ............................................................................................................................. 449
How to Use a Comparator ? ........................................................................................................................ 453
Summary ..................................................................................................................................................... 455
30. Java – Generics ..................................................................................................................................... 456
Generic Methods ......................................................................................................................................... 456
Bounded Type Parameters .......................................................................................................................... 458
Generic Classes ............................................................................................................................................ 459
31. Java – Serialization ................................................................................................................................ 461
Serializing an Object .................................................................................................................................... 462
Deserializing an Object ................................................................................................................................ 463
32. Java – Networking ................................................................................................................................. 465
URL Processing ............................................................................................................................................ 465
URL Class Methods ...................................................................................................................................... 466
URLConnections Class Methods .................................................................................................................. 469
Socket Programming ................................................................................................................................... 472
ServerSocket Class Methods ....................................................................................................................... 473
Socket Class Methods .................................................................................................................................. 474
InetAddress Class Methods ......................................................................................................................... 476
Socket Client Example ................................................................................................................................. 476
Socket Server Example ................................................................................................................................ 478
33. Java – Sending E-mail ............................................................................................................................ 480
Send a Simple E-mail ................................................................................................................................... 480
Send an HTML E-mail ................................................................................................................................... 482
Send Attachment in E-mail .......................................................................................................................... 484
User Authentication Part ............................................................................................................................. 486
34. Java – Multithreading ........................................................................................................................... 487
Life Cycle of a Thread .................................................................................................................................. 487
Thread Priorities .......................................................................................................................................... 488
Create a Thread by Implementing a Runnable Interface ............................................................................ 488
Create a Thread by Extending a Thread Class ............................................................................................. 490
Thread Methods .......................................................................................................................................... 493
Major Java Multithreading Concepts .......................................................................................................... 498
Thread Synchronization ............................................................................................................................... 498
Interthread Communication ........................................................................................................................ 503
Thread Deadlock .......................................................................................................................................... 506
Thread Control............................................................................................................................................. 509
35. Java – Applet Basics .............................................................................................................................. 514
Life Cycle of an Applet ................................................................................................................................. 514
A "Hello, World" Applet ............................................................................................................................... 515
ixJava
The Applet Class .......................................................................................................................................... 515
Invoking an Applet ....................................................................................................................................... 516
HTML <applet> Tag ...................................................................................................................................... 516
HTML Attribute Reference .......................................................................................................................... 518
HTML Events Reference .............................................................................................................................. 520
Getting Applet Parameters .......................................................................................................................... 525
Specifying Applet Parameters ..................................................................................................................... 526
Application Conversion to Applets .............................................................................................................. 526
Event Handling ............................................................................................................................................ 527
Displaying Images ........................................................................................................................................ 529
Playing Audio ............................................................................................................................................... 531
36. Java – Documentation Comments ......................................................................................................... 533
What is Javadoc? ......................................................................................................................................... 533
The javadoc Tags ......................................................................................................................................... 534
xJava – Basics1. Java – Overview
Java
Java programming language was originally developed by Sun Microsystems which was
initiated by James Gosling and released in 1995 as core component of Sun Microsystems'
Java platform (Java 1.0 [J2SE]).
The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java
and its widespread popularity, multiple configurations were built to suit various types of
platforms. For example: J2EE for Enterprise Applications, J2ME for Mobile Applications.
The new J2 versions were renamed as Java SE, Java EE, and Java ME respectively. Java
is guaranteed to be Write Once, Run Anywhere.
Java is:
 Object Oriented: In Java, everything is an Object. Java can be easily extended
since it is based on the Object model.
 Platform Independent: Unlike many other programming languages including C
and C++, when Java is compiled, it is not compiled into platform specific machine,
rather into platform independent byte code. This byte code is distributed over the
web and interpreted by the Virtual Machine (JVM) on whichever platform it is being
run on.
 Simple: Java is designed to be easy to learn. If you understand the basic concept
of OOP Java, it would be easy to master.
 Secure: With Java's secure feature it enables to develop virus-free, tamper-free
systems. Authentication techniques are based on public-key encryption.
 Architecture-neutral: Java compiler generates an architecture-neutral object
file format, which makes the compiled code executable on many processors, with
the presence of Java runtime system.
 Portable: Being architecture-neutral and having no implementation dependent
aspects of the specification makes Java portable. Compiler in Java is written in
ANSI C with a clean portability boundary, which is a POSIX subset.
 Robust: Java makes an effort to eliminate error prone situations by emphasizing
mainly on compile time error checking and runtime checking.
 Multithreaded: With Java's multithreaded feature it is possible to write programs
that can perform many tasks simultaneously. This design feature allows the
developers to construct interactive applications that can run smoothly.
 Interpreted: Java byte code is translated on the fly to native machine
instructions and is not stored anywhere. The development process is more rapid
and analytical since the linking is an incremental and light-weight process.
 High Performance: With the use of Just-In-Time compilers, Java enables high
performance.
2Java
 Distributed: Java is designed for the distributed environment of the internet.
 Dynamic: Java is considered to be more dynamic than C or C++ since it is
designed to adapt to an evolving environment. Java programs can carry extensive
amount of run-time information that can be used to verify and resolve accesses
to objects on run-time.
History of Java
James Gosling initiated Java language project in June 1991 for use in one of his many set-
top box projects. The language, initially called ‘Oak’ after an oak tree that stood outside
Gosling's office, also went by the name ‘Green’ and ended up later being renamed as Java,
from a list of random words.
Sun released the first public implementation as Java 1.0 in 1995. It promised Write Once,
Run Anywhere (WORA), providing no-cost run-times on popular platforms.
On 13 November, 2006, Sun released much of Java as free and open source software
under the terms of the GNU General Public License (GPL).
On 8 May, 2007, Sun finished the process, making all of Java's core code free and open-
source, aside from a small portion of code to which Sun did not hold the copyright.
Tools You Will Need
For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz
computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).
You will also need the following softwares:
 Linux 7.1 or Windows xp/7/8 operating system
 Java JDK 8
 Microsoft Notepad or any other text editor
This tutorial will provide the necessary skills to create GUI, networking, and web
applications using Java.
3Java
Try It Option
We have provided you with an option to compile and execute available code online. Just
click the Try it button avaiable at the top-right corner of the code window to compile and
execute the available code. There are certain examples which cannot be executed online,
so we have skipped those examples.
public class MyFirstJavaProgram {
public static void main(String []args) {
System.out.println("Hello World");
}
}
There may be a case that you do not see the result of the compiled/executed code. In
such case, you can re-try to compile and execute the code using execute button available
in the compilation pop-up window.
What is Next?
The next chapter will guide you to how you can obtain Java and its documentation. Finally,
it instructs you on how to install Java and prepare an environment to develop Java
applications.
42. Java - Environment Setup
Java
In this chapter, we will discuss on the different aspects of setting up a congenial
environment for Java.
Try it Option Online
You really do not need to set up your own environment to start learning Java programming
language. Reason is very simple, we already have Java Programming environment setup
online, so that you can compile and execute all the available examples online at the same
time when you are doing your theory work. This gives you confidence in what you are
reading and to check the result with different options. Feel free to modify any example
and execute it online.
Try the following example using Try it option available at the top right corner of the
following sample code box:
public class MyFirstJavaProgram {
public static void main(String []args) {
System.out.println("Hello World");
}
}
For most of the examples given in this tutorial, you will find the Try it option, which you
can use to execute your programs and enjoy your learning.
Local Environment Setup
If you are still willing to set up your environment for Java programming language, then
this section guides you on how to download and set up Java on your machine. Following
are the steps to set up the environment.
Java SE is freely available from the link Download Java. You can download a version based
on your operating system.
Follow the instructions to download Java and run the .exe to install Java on your machine.
Once you installed Java on your machine, you will need to set environment variables to
point to correct installation directories:
Setting Up the Path for Windows
Assuming you have installed Java in c:\Program Files\java\jdk directory:
 Right-click on 'My Computer' and select 'Properties'.
 Click the 'Environment variables' button under the 'Advanced' tab.
5Java

Now, alter the 'Path' variable so that it also contains the path to the Java
executable. Example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then
change
your
path
to
read
'C:\WINDOWS\SYSTEM32;c:\Program
Files\java\jdk\bin'.
Setting Up the Path for Linux, UNIX, Solaris, FreeBSD
Environment variable PATH should be set to point to where the Java binaries have been
installed. Refer to your shell documentation, if you have trouble doing this.
Example, if you use bash as your shell, then you would add the following line to the end
of your '.bashrc: export PATH=/path/to/java:$PATH'
Popular Java Editors
To write your Java programs, you will need a text editor. There are even more
sophisticated IDEs available in the market. But for now, you can consider one of the
following:
 Notepad: On Windows machine, you can use any simple text editor like Notepad
(Recommended for this tutorial), TextPad.
 Netbeans: A Java IDE that is open-source and free, which can be downloaded
from http://www.netbeans.org/index.html .
 Eclipse: A Java IDE developed by the eclipse open-source community and can be
downloaded from http://www.eclipse.org/ .
What is Next?
Next chapter will teach you how to write and run your first Java program and some of the
important basic syntaxes in Java needed for developing applications.
63. Java – Basic Syntax
Java
When we consider a Java program, it can be defined as a collection of objects that
communicate via invoking each other's methods. Let us now briefly look into what do class,
object, methods, and instance variables mean.
 Object - Objects have states and behaviors. Example: A dog has states - color,
name, breed as well as behavior such as wagging their tail, barking, eating. An
object is an instance of a class.
 Class - A class can be defined as a template/blueprint that describes the
behavior/state that the object of its type supports.
 Methods - A method is basically a behavior. A class can contain many methods.
It is in methods where the logics are written, data is manipulated and all the
actions are executed.
 Instance Variables - Each object has its unique set of instance variables. An
object's state is created by the values assigned to these instance variables.
First Java Program
Let us look at a simple code that will print the words Hello World.
public class MyFirstJavaProgram {
/* This is my first java program.
* This will print 'Hello World' as the output
*/
public static void main(String []args) {
System.out.println("Hello World"); // prints Hello World
}
}
Let's look at how to save the file, compile, and run the program. Please follow the
subsequent steps:
 Open notepad and add the code as above.
 Save the file as: MyFirstJavaProgram.java.
 Open a command prompt window and go to the directory where you saved the
class. Assume it's C:\.
7Java
 Type 'javac MyFirstJavaProgram.java' and press enter to compile your code. If
there are no errors in your code, the command prompt will take you to the next
line (Assumption : The path variable is set).
 Now, type ' java MyFirstJavaProgram ' to run your program.
 You will be able to see ' Hello World ' printed on the window.
C:\> javac MyFirstJavaProgram.java
C:\> java MyFirstJavaProgram
Hello World
Basic Syntax
About Java programs, it is very important to keep in mind the following points.
 Case
Sensitivity
- Java
is
case
sensitive,
which
identifier Helloand hello would have different meaning in Java.
means
 Class Names - For all class names the first letter should be in Upper Case.
If several words are used to form a name of the class, each inner word's first letter
should be in Upper Case.
Example: class MyFirstJavaClass

Method Names - All method names should start with a Lower Case letter.
If several words are used to form the name of the method, then each inner word's
first letter should be in Upper Case.
Example: public void myMethodName()

Program File Name - Name of the program file should exactly match the class
name.
When saving the file, you should save it using the class name (Remember Java is
case sensitive) and append '.java' to the end of the name (if the file name and the
class
name
do
not
match,
your
program
will
not
compile).
Example: Assume 'MyFirstJavaProgram' is the class name. Then the file should
be saved as 'MyFirstJavaProgram.java'

public static void main(String args[]) - Java program processing starts from
the main() method which is a mandatory part of every Java program.
8Java
Java Identifiers
All Java components require names. Names used for classes, variables, and methods are
called identifiers.
In Java, there are several points to remember about identifiers. They are as follows:
 All identifiers should begin with a letter (A to Z or a to z), currency character ($)
or an underscore (_).
 After the first character, identifiers can have any combination of characters.
 A key word cannot be used as an identifier.
 Most importantly, identifiers are case sensitive.
 Examples of legal identifiers: age, $salary, _value, __1_value.
 Examples of illegal identifiers: 123abc, -salary.
Java Modifiers
Like other languages, it is possible to modify classes, methods, etc., by using modifiers.
There are two categories of modifiers:
 Access Modifiers: default, public , protected, private
 Non-access Modifiers: final, abstract, strictfp
We will be looking into more details about modifiers in the next section.
Java Variables
Following are the types of variables in Java:
 Local Variables
 Class Variables (Static Variables)
 Instance Variables (Non-static Variables)
Java Arrays
Arrays are objects that store multiple variables of the same type. However, an array itself
is an object on the heap. We will look into how to declare, construct, and initialize in the
upcoming chapters.
9Java
Java Enums
Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few
predefined values. The values in this enumerated list are called enums.
With the use of enums it is possible to reduce the number of bugs in your code.
For example, if we consider an application for a fresh juice shop, it would be possible to
restrict the glass size to small, medium, and large. This would make sure that it would not
allow anyone to order any size other than small, medium, or large.
Example
class FreshJuice {
enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }
FreshJuiceSize size;
}
public class FreshJuiceTest {
public static void main(String args[]){
FreshJuice juice = new FreshJuice();
juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;
System.out.println("Size: " + juice.size);
}
}
The above example will produce the following result:
Size: MEDIUM
Note: Enums can be declared as their own or inside a class. Methods, variables,
constructors can be defined inside enums as well.
Java Keywords
The following list shows the reserved words in Java. These reserved words may not be
used as constant or variable or any other identifier names.
abstract assert boolean break
byte case catch char
10Java
class const continue default
do double else enum
extends final finally float
for goto if implements
import instanceof int interface
long native new package
private protected public return
short static strictfp super
switch synchronized this throw
throws transient try void
volatile while
Comments in Java
Java supports single-line and multi-line comments very similar to C and C++. All
characters available inside any comment are ignored by Java compiler.
public class MyFirstJavaProgram{
/* This is my first java program.
* This will print 'Hello World' as the output
* This is an example of multi-line comments.
*/
public static void main(String []args){
// This is an example of single line comment
/* This is also an example of single line comment. */
System.out.println("Hello World");
}
}
11Java
Using Blank Lines
A line containing only white space, possibly with a comment, is known as a blank line, and
Java totally ignores it.
Inheritance
In Java, classes can be derived from classes. Basically, if you need to create a new class
and here is already a class that has some of the code you require, then it is possible to
derive your new class from the already existing code.
This concept allows you to reuse the fields and methods of the existing class without having
to rewrite the code in a new class. In this scenario, the existing class is called the
superclass and the derived class is called the subclass.
Interfaces
In Java language, an interface can be defined as a contract between objects on how to
communicate with each other. Interfaces play a vital role when it comes to the concept of
inheritance.
An interface defines the methods, a deriving class (subclass) should use. But the
implementation of the methods is totally up to the subclass.
What is Next?
The next section explains about Objects and classes in Java programming. At the end of
the session, you will be able to get a clear picture as to what are objects and what are
classes in Java.
124. Java – Objects & Classes
Java
Java is an Object-Oriented Language. As a language that has the Object-Oriented feature,
Java supports the following fundamental concepts:
 Polymorphism
 Inheritance
 Encapsulation
 Abstraction
 Classes
 Objects
 Instance
 Method
 Message Parsing
In this chapter, we will look into the concepts - Classes and Objects.
 Object - Objects have states and behaviors. Example: A dog has states - color,
name, breed as well as behaviors – wagging the tail, barking, eating. An object is
an instance of a class.
 Class - A class can be defined as a template/blueprint that describes the
behavior/state that the object of its type support.
Objects in Java
Let us now look deep into what are objects. If we consider the real-world, we can find
many objects around us, cars, dogs, humans, etc. All these objects have a state and a
behavior.
If we consider a dog, then its state is - name, breed, color, and the behavior is - barking,
wagging the tail, running.
If you compare the software object with a real-world object, they have very similar
characteristics.
Software objects also have a state and a behavior. A software object's state is stored in
fields and behavior is shown via methods.
So in software development, methods operate on the internal state of an object and the
object-to-object communication is done via methods.
13Java
Classes in Java
A class is a blueprint from which individual objects are created.
Following is a sample of a class.
public class Dog{
String breed;
int ageC
String color;
void barking(){
}
void hungry(){
}
void sleeping(){
}
}
A class can contain any of the following variable types.
 Local variables: Variables defined inside methods, constructors or blocks are
called local variables. The variable will be declared and initialized within the
method and the variable will be destroyed when the method has completed.
 Instance variables: Instance variables are variables within a class but outside
any method. These variables are initialized when the class is instantiated. Instance
variables can be accessed from inside any method, constructor or blocks of that
particular class.
 Class variables: Class variables are variables declared within a class, outside any
method, with the static keyword.
A class can have any number of methods to access the value of various kinds of methods.
In the above example, barking(), hungry() and sleeping() are methods.
Following are some of the important topics that need to be discussed when looking into
classes of the Java Language.
Constructors
When discussing about classes, one of the most important sub topic would be constructors.
Every class has a constructor. If we do not explicitly write a constructor for a class, the
Java compiler builds a default constructor for that class.
14Java
Each time a new object is created, at least one constructor will be invoked. The main rule
of constructors is that they should have the same name as the class. A class can have
more than one constructor.
Following is an example of a constructor:
public class Puppy{
public Puppy(){
}
public Puppy(String name){
// This constructor has one parameter, name.
}
}
Java also supports Singleton Classes where you would be able to create only one instance
of a class.
Note: We have two different types of constructors. We are going to discuss constructors
in detail in the subsequent chapters.
How to Use Singleton Class?
The Singleton's purpose is to control object creation, limiting the number of objects to only
one. Since there is only one Singleton instance, any instance fields of a Singleton will occur
only once per class, just like static fields. Singletons often control access to resources,
such as database connections or sockets.
For example, if you have a license for only one connection for your database or your JDBC
driver has trouble with multithreading, the Singleton makes sure that only one connection
is made or that only one thread can access the connection at a time.
15Java
Implementing Singletons
Example 1
The easiest implementation consists of a private constructor and a field to hold its result,
and a static accessor method with a name like getInstance().
The private field can be assigned from within a static initializer block or, more simply,
using an initializer. The getInstance( ) method (which must be public) then simply returns
this instance −
// File Name: Singleton.java
public class Singleton {
private static Singleton singleton = new Singleton( );
/* A private Constructor prevents any other
* class from instantiating.
*/
private Singleton(){ }
/* Static 'instance' method */
public static Singleton getInstance( ) {
return singleton;
}
/* Other methods protected by singleton-ness */
protected static void demoMethod( ) {
System.out.println("demoMethod for singleton");
}
}
Here is the main program file, where we will create a singleton object:
// File Name: SingletonDemo.java
public class SingletonDemo {
public static void main(String[] args) {
Singleton tmp = Singleton.getInstance( );
tmp.demoMethod( );
}
}
16Java
This will produce the following result −
demoMethod for singleton
Example 2
Following implementation shows a classic Singleton design pattern:
public class ClassicSingleton {
private static ClassicSingleton instance = null;
private ClassicSingleton() {
// Exists only to defeat instantiation.
}
public static ClassicSingleton getInstance() {
if(instance == null) {
instance = new ClassicSingleton();
}
return instance;
} }
The ClassicSingleton class maintains a static reference to the lone singleton instance and
returns that reference from the static getInstance() method.
Here, ClassicSingleton class employs a technique known as lazy instantiation to create the
singleton; as a result, the singleton instance is not created until the getInstance() method
is called for the first time. This technique ensures that singleton instances are created only
when needed.
Creating an Object
As mentioned previously, a class provides the blueprints for objects. So basically, an object
is created from a class. In Java, the new keyword is used to create new objects.
There are three steps when creating an object from a class:
 Declaration: A variable declaration with a variable name with an object type.
 Instantiation: The 'new' keyword is used to create the object.
 Initialization: The 'new' keyword is followed by a call to a constructor. This call
initializes the new object.
17Java
Following is an example of creating an object:
public class Puppy{
public Puppy(String name){
// This constructor has one parameter, name.
System.out.println("Passed Name is :" + name );
}
public static void main(String []args){
// Following statement would create an object myPuppy
Puppy myPuppy = new Puppy( "tommy" );
}
}
If we compile and run the above program, then it will produce the following result:
Passed Name is :tommy
Accessing Instance Variables and Methods
Instance variables and methods are accessed via created objects. To access an instance
variable, following is the fully qualified path:
/* First create an object */
ObjectReference = new Constructor();
/* Now call a variable as follows */
ObjectReference.variableName;
/* Now you can call a class method as follows */
ObjectReference.MethodName();
18Java
Example
This example explains how to access instance variables and methods of a class.
public class Puppy{
int puppyAge;
public Puppy(String name){
// This constructor has one parameter, name.
System.out.println("Name chosen is :" + name );
}
public void setAge( int age ){
puppyAge = age;
}
public int getAge( ){
System.out.println("Puppy's age is :" + puppyAge );
return puppyAge;
}
public static void main(String []args){
/* Object creation */
Puppy myPuppy = new Puppy( "tommy" );
/* Call class method to set puppy's age */
myPuppy.setAge( 2 );
/* Call another class method to get puppy's age */
myPuppy.getAge( );
/* You can access instance variable as follows as well */
System.out.println("Variable Value :" + myPuppy.puppyAge );
}
}
19Java
If we compile and run the above program, then it will produce the following result:
Name chosen is :tommy
Puppy's age is :2
Variable Value :2
Source File Declaration Rules
As the last part of this section, let's now look into the source file declaration rules. These
rules are essential when declaring classes, import statements and package statements in
a source file.
 There can be only one public class per source file.
 A source file can have multiple non-public classes.
 The public class name should be the name of the source file as well which should
be appended by .java at the end. For example: the class name is public class
Employee{} then the source file should be as Employee.java.
 If the class is defined inside a package, then the package statement should be the
first statement in the source file.
 If import statements are present, then they must be written between the package
statement and the class declaration. If there are no package statements, then the
import statement should be the first line in the source file.
 Import and package statements will imply to all the classes present in the source
file. It is not possible to declare different import and/or package statements to
different classes in the source file.
Classes have several access levels and there are different types of classes; abstract
classes, final classes, etc. We will be explaining about all these in the access modifiers
chapter.
Apart from the above mentioned types of classes, Java also has some special classes called
Inner classes and Anonymous classes.
Java Package
In simple words, it is a way of categorizing the classes and interfaces. When developing
applications in Java, hundreds of classes and interfaces will be written, therefore
categorizing these classes is a must as well as makes life much easier.
20Java
Import Statements
In Java if a fully qualified name, which includes the package and the class name is given,
then the compiler can easily locate the source code or classes. Import statement is a way
of giving the proper location for the compiler to find that particular class.
For example, the following line would ask the compiler to load all the classes available in
directory java_installation/java/io:
import java.io.*;
A Simple Case Study
For our case study, we will be creating two classes. They are Employee and EmployeeTest.
First open notepad and add the following code. Remember this is the Employee class and
the class is a public class. Now, save this source file with the name Employee.java.
The Employee class has four instance variables - name, age, designation and salary. The
class has one explicitly defined constructor, which takes a parameter.
import java.io.*;
public class Employee{
String name;
int age;
String designation;
double salary;
// This is the constructor of the class Employee
public Employee(String name){
this.name = name;
}
// Assign the age of the Employee
to the variable age.
public void empAge(int empAge){
age =
empAge;
}
/* Assign the designation to the variable designation.*/
public void empDesignation(String empDesig){
designation = empDesig;
}
/* Assign the salary to the variable
salary.*/
21Java
public void empSalary(double empSalary){
salary = empSalary;
}
/* Print the Employee details */
public void printEmployee(){
System.out.println("Name:"+ name );
System.out.println("Age:" + age );
System.out.println("Designation:" + designation );
System.out.println("Salary:" + salary);
}
}
As mentioned previously in this tutorial, processing starts from the main method.
Therefore, in order for us to run this Employee class there should be a main method and
objects should be created. We will be creating a separate class for these tasks.
Following is the EmployeeTest class, which creates two instances of the class Employee
and invokes the methods for each object to assign values for each variable.
Save the following code in EmployeeTest.java file.
import java.io.*;
public class EmployeeTest{
public static void main(String args[]){
/* Create two objects using constructor */
Employee empOne = new Employee("James Smith");
Employee empTwo = new Employee("Mary Anne");
// Invoking methods for each object created
empOne.empAge(26);
empOne.empDesignation("Senior Software Engineer");
empOne.empSalary(1000);
empOne.printEmployee();
empTwo.empAge(21);
empTwo.empDesignation("Software Engineer");
empTwo.empSalary(500);
empTwo.printEmployee();
} }
22Java
Now, compile both the classes and then run EmployeeTest to see the result as follows:
C:\> javac Employee.java
C:\> javac EmployeeTest.java
C:\> java EmployeeTest
Name:James Smith
Age:26
Designation:Senior Software Engineer
Salary:1000.0
Name:Mary Anne
Age:21
Designation:Software Engineer
Salary:500.0
What is Next?
In the next session, we will discuss the basic data types in Java and how they can be used
when developing Java applications.
235. Java – Basic Datatypes
Java
Variables are nothing but reserved memory locations to store values. This means that
when you create a variable you reserve some space in the memory.
Based on the data type of a variable, the operating system allocates memory and decides
what can be stored in the reserved memory. Therefore, by assigning different datatypes
to variables, you can store integers, decimals, or characters in these variables.
There are two data types available in Java:
 Primitive Datatypes
 Reference/Object Datatypes
Primitive Datatypes
There are eight primitive datatypes supported by Java. Primitive datatypes are predefined
by the language and named by a keyword. Let us now look into the eight primitive data
types in detail.
byte:
 Byte data type is an 8-bit signed two's complement integer
 Minimum value is -128 (-2^7)
 Maximum value is 127 (inclusive)(2^7 -1)
 Default value is 0
 Byte datatype is used to save space in large arrays, mainly in place of integers,
since a byte is four times smaller than an integer
 Example: byte a = 100 , byte b = -50
short:
 Short datatype is a 16-bit signed two's complement integer
 Minimum value is -32,768 (-2^15)
 Maximum value is 32,767 (inclusive) (2^15 -1)
 Short datatype can also be used to save memory as byte data type. A short is 2
times smaller than an integer
 Default value is 0
24Java

Example: short s = 10000, short r = -20000
int:
 Int datatype is a 32-bit signed two's complement integer
 Minimum value is - 2,147,483,648 (-2^31)
 Maximum value is 2,147,483,647(inclusive) (2^31 -1)
 Integer is generally used as the default data type for integral values unless there
is a concern about memory.
 The default value is 0
 Example: int a = 100000, int b = -200000
long:
 Long datatype is a 64-bit signed two's complement integer
 Minimum value is -9,223,372,036,854,775,808 (-2^63)
 Maximum value is 9,223,372,036,854,775,807 (inclusive) (2^63 -1)
 This type is used when a wider range than int is needed
 Default value is 0L
 Example: long a = 100000L, long b = -200000L
float:
 Float datatype is a single-precision 32-bit IEEE 754 floating point
 Float is mainly used to save memory in large arrays of floating point numbers
 Default value is 0.0f
 Float datatype is never used for precise values such as currency
 Example: float f1 = 234.5f
double:
 double datatype is a double-precision 64-bit IEEE 754 floating point
 This datatype is generally used as the default data type for decimal values,
generally the default choice
 Double datatype should never be used for precise values such as currency
 Default value is 0.0d
25Java

Example: double d1 = 123.4
boolean:
 boolean datatype represents one bit of information
 There are only two possible values: true and false
 This datatype is used for simple flags that track true/false conditions
 Default value is false
 Example: boolean one = true
char:
 char datatype is a single 16-bit Unicode character
 Minimum value is '\u0000' (or 0)
 Maximum value is '\uffff' (or 65,535 inclusive)
 Char datatype is used to store any character
 Example: char letterA ='A'
Reference Datatypes
 Reference variables are created using defined constructors of the classes. They are
used to access objects. These variables are declared to be of a specific type that
cannot be changed. For example, Employee, Puppy, etc.
 Class objects and various type of array variables come under reference datatype.
 Default value of any reference variable is null.
 A reference variable can be used to refer any object of the declared type or any
compatible type.
 Example: Animal animal = new Animal("giraffe");
Java Literals
A literal is a source code representation of a fixed value. They are represented directly in
the code without any computation.
Literals can be assigned to any primitive type variable. For example:
byte a = 68;
char a = 'A'
byte, int, long, and short can be expressed in decimal(base 10), hexadecimal(base 16) or
octal(base 8) number systems as well.
26Java
Prefix 0 is used to indicate octal, and prefix 0x indicates hexadecimal when using these
number systems for literals. For example:
int decimal = 100;
int octal = 0144;
int hexa =
0x64;
String literals in Java are specified like they are in most other languages by enclosing a
sequence of characters between a pair of double quotes. Examples of string literals are:
"Hello World"
"two\nlines"
"\"This is in quotes\""
String and char types of literals can contain any Unicode characters. For example:
char a = '\u0001';
String a = "\u0001";
Java language supports few special escape sequences for String and char literals as well.
They are:
Notation Character represented
\n Newline (0x0a)
\r Carriage return (0x0d)
\f Formfeed (0x0c)
\b Backspace (0x08)
\s Space (0x20)
\t tab
27Java
\" Double quote
\' Single quote
\\ backslash
\ddd Octal character (ddd)
\uxxxx Hexadecimal UNICODE character (xxxx)
What is Next?
This chapter explained the various data types. The next topic explains different variable
types and their usage. This will give you a good understanding on how they can be used
in the Java classes, interfaces, etc.
286. Java – Variable Types
Java
A variable provides us with named storage that our programs can manipulate. Each
variable in Java has a specific type, which determines the size and layout of the variable's
memory; the range of values that can be stored within that memory; and the set of
operations that can be applied to the variable.
You must declare all variables before they can be used. Following is the basic form of a
variable declaration:
data type variable [ = value][, variable [= value] ...] ;
Here data type is one of Java's datatypes and variable is the name of the variable. To
declare more than one variable of the specified type, you can use a comma-separated list.
Following are valid examples of variable declaration and initialization in Java:
int a, b, c; // Declares three ints, a, b, and c.
int a = 10, b = 10; // Example of initialization
byte B = 22; // initializes a byte type variable B.
double pi = 3.14159; // declares and assigns a value of PI.
char a = 'a';
// the char variable a iis initialized with value 'a'
This chapter will explain various variable types available in Java Language. There are three
kinds of variables in Java:
 Local variables
 Instance variables
 Class/Static variables
Local Variables
 Local variables are declared in methods, constructors, or blocks.
 Local variables are created when the method, constructor or block is entered and
the variable will be destroyed once it exits the method, constructor, or block.
 Access modifiers cannot be used for local variables.
 Local variables are visible only within the declared method, constructor, or block.
 Local variables are implemented at stack level internally.
 There is no default value for local variables, so local variables should be declared
and an initial value should be assigned before the first use.
29Java
Example
Here, age is a local variable. This is defined inside pupAge() method and its scope is
limited to only this method.
public class Test{
public void pupAge(){
int age = 0;
age = age + 7;
System.out.println("Puppy age is : " + age);
}
public static void main(String args[]){
Test test = new Test();
test.pupAge();
}
}
This will produce the following result:
Puppy age is: 7
Example
Following example uses age without initializing it, so it would give an error at the time of
compilation.
public class Test{
public void pupAge(){
int age;
age = age + 7;
System.out.println("Puppy age is : " + age);
}
public static void main(String args[]){
Test test = new Test();
test.pupAge();
}
}
30Java
This will produce the following error while compiling it:
Test.java:4:variable number might not have been initialized
age = age + 7;
^
1 error
Instance Variables
 Instance variables are declared in a class, but outside a method, constructor or any
block.
 When a space is allocated for an object in the heap, a slot for each instance variable
value is created.
 Instance variables are created when an object is created with the use of the
keyword 'new' and destroyed when the object is destroyed.
 Instance variables hold values that must be referenced by more than one method,
constructor or block, or essential parts of an object's state that must be present
throughout the class.
 Instance variables can be declared in class level before or after use.
 Access modifiers can be given for instance variables.
 The instance variables are visible for all methods, constructors and block in the
class. Normally, it is recommended to make these variables private (access level).
However, visibility for subclasses can be given for these variables with the use of
access modifiers.
 Instance variables have default values. For numbers, the default value is 0, for
Booleans it is false, and for object references it is null. Values can be assigned
during the declaration or within the constructor.
 Instance variables can be accessed directly by calling the variable name inside the
class. However, within static methods (when instance variables are given
accessibility), they should be called using the fully qualified name
. ObjectReference.VariableName.
31Java
Example
import java.io.*;
public class Employee{
// this instance variable is visible for any child class.
public String name;
// salary
variable is visible in Employee class only.
private double salary;
// The name variable is assigned in the constructor.
public Employee (String empName){
name = empName;
}
// The salary variable is assigned a value.
public void setSalary(double empSal){
salary = empSal;
}
// This method prints the employee details.
public void printEmp(){
System.out.println("name
: " + name );
System.out.println("salary :" + salary);
}
public static void main(String args[]){
Employee empOne = new Employee("Ransika");
empOne.setSalary(1000);
empOne.printEmp();
}
}
32Java
This will produce the following result:
name
: Ransika
salary :1000.0
Class/static Variables
 Class variables also known as static variables are declared with the static keyword
in a class, but outside a method, constructor or a block.
 There would only be one copy of each class variable per class, regardless of how
many objects are created from it.
 Static variables are rarely used other than being declared as constants. Constants
are variables that are declared as public/private, final, and static. Constant
variables never change from their initial value.
 Static variables are stored in the static memory. It is rare to use static variables
other than declared final and used as either public or private constants.
 Static variables are created when the program starts and destroyed when the
program stops.
 Visibility is similar to instance variables. However, most static variables are
declared public since they must be available for users of the class.
 Default values are same as instance variables. For numbers, the default value is 0;
for Booleans, it is false; and for object references, it is null. Values can be assigned
during the declaration or within the constructor. Additionally, values can be
assigned in special static initializer blocks.
 Static variables can be
ClassName.VariableName.
 When declaring class variables as public static final, then variable names
(constants) are all in upper case. If the static variables are not public and final, the
naming syntax is the same as instance and local variables.
accessed
by
calling
with
the
class
name
33Java
Example
import java.io.*;
public class Employee{
// salary
variable is a private static variable
private static double salary;
// DEPARTMENT is a constant
public static final String DEPARTMENT = "Development ";
public static void main(String args[]){
salary = 1000;
System.out.println(DEPARTMENT + "average salary:" + salary);
}
}
This will produce the following result:
Development average salary:1000
Note: If the variables are accessed from an outside class, the constant should be accessed
as Employee.DEPARTMENT
What is Next?
You already have used access modifiers (public & private) in this chapter. The next chapter
will explain Access Modifiers and Non-Access Modifiers in detail.
347. Java – Modifier Types
Java
Modifiers are keywords that you add to those definitions to change their meanings. Java
language has a wide variety of modifiers, including the following:
 Java Access Modifiers
 Non Access Modifiers
Java Access Modifiers
Java provides a number of access modifiers to set access levels for classes, variables,
methods, and constructors. The four access levels are:
 Visible to the package, the default. No modifiers are needed.
 Visible to the class only (private).
 Visible to the world (public).
 Visible to the package and all subclasses (protected).
Default Access Modifier - No Keyword
Default access modifier means we do not explicitly declare an access modifier for a class,
field, method, etc.
A variable or method declared without any access control modifier is available to any other
class in the same package. The fields in an interface are implicitly public static final and
the methods in an interface are by default public.
Example
Variables and methods can be declared without any modifiers, as in the following
examples:
String version = "1.5.1";
boolean processOrder() {
return true;
}
Private Access Modifier - Private
Methods, variables, and constructors that are declared private can only be accessed within
the declared class itself.
Private access modifier is the most restrictive access level. Class and interfaces cannot be
private.
35Java
Variables that are declared private can be accessed outside the class, if public getter
methods are present in the class.
Using the private modifier is the main way that an object encapsulates itself and hides
data from the outside world.
Example
The following class uses private access control:
public class Logger {
private String format;
public String getFormat() {
return this.format;
}
public void setFormat(String format) {
this.format = format;
}
}
Here, the format variable of the Logger class is private, so there's no way for other classes
to retrieve or set its value directly.
So, to make this variable available to the outside world, we defined two public
methods: getFormat(), which returns the value of format, and setFormat(String), which
sets its value.
Public Access Modifier - Public
A class, method, constructor, interface, etc. declared public can be accessed from any
other class. Therefore, fields, methods, blocks declared inside a public class can be
accessed from any class belonging to the Java Universe.
However, if the public class we are trying to access is in a different package, then the
public class still needs to be imported. Because of class inheritance, all public methods
and variables of a class are inherited by its subclasses.
Example
The following function uses public access control:
public static void main(String[] arguments) {
// ...
}
The main() method of an application has to be public. Otherwise, it could not be called by
a Java interpreter (such as java) to run the class.
36Java
Protected Access Modifier - Protected
Variables, methods, and constructors, which are declared protected in a superclass can be
accessed only by the subclasses in other package or any class within the package of the
protected members' class.
The protected access modifier cannot be applied to class and interfaces. Methods, fields
can be declared protected, however methods and fields in a interface cannot be declared
protected.
Protected access gives the subclass a chance to use the helper method or variable, while
preventing a nonrelated class from trying to use it.
Example
The following parent class uses protected access control, to allow its child class
override openSpeaker() method:
class AudioPlayer {
protected boolean openSpeaker(Speaker sp) {
// implementation details
}
}
class StreamingAudioPlayer {
boolean openSpeaker(Speaker sp) {
// implementation details
}
}
Here, if we define openSpeaker() method as private, then it would not be accessible from
any other class other than AudioPlayer. If we define it as public, then it would become
accessible to all the outside world. But our intention is to expose this method to its subclass
only, that’s why we have used protected modifier.
Access Control and Inheritance
The following rules for inherited methods are enforced:
 Methods declared public in a superclass also must be public in all subclasses.
 Methods declared protected in a superclass must either be protected or public in
subclasses; they cannot be private.
 Methods declared private are not inherited at all, so there is no rule for them.
37Java
Java Non-Access Modifiers
Java provides a number of non-access modifiers to achieve many other functionalities.
 The static modifier for creating class methods and variables.
 The final modifier for finalizing the implementations of classes, methods, and
variables.
 The abstract modifier for creating abstract classes and methods.
 The synchronized and volatile modifiers, which are used for threads.
The Static Modifier
Static Variables
The static keyword is used to create variables that will exist independently of any instances
created for the class. Only one copy of the static variable exists regardless of the number
of instances of the class.
Static variables are also known as class variables. Local variables cannot be declared
static.
Static Methods
The static keyword is used to create methods that will exist independently of any instances
created for the class.
Static methods do not use any instance variables of any object of the class they are defined
in. Static methods take all the data from parameters and compute something from those
parameters, with no reference to variables.
Class variables and methods can be accessed using the class name followed by a dot and
the name of the variable or method.
Example
The static modifier is used to create class methods and variables, as in the following
example:
public class InstanceCounter {
private static int numInstances = 0;
protected static int getCount() {
return numInstances;
}
38Java
private static void addInstance() {
numInstances++;
}
InstanceCounter() {
InstanceCounter.addInstance();
}
public static void main(String[] arguments) {
System.out.println("Starting with " +
InstanceCounter.getCount() + " instances");
for (int i = 0; i < 500; ++i){
new InstanceCounter();
}
System.out.println("Created " +
InstanceCounter.getCount() + " instances");
}
}
This will produce the following result:
Started with 0 instances
Created 500 instances
The Final Modifier
Final Variables
A final variable can be explicitly initialized only once. A reference variable declared final
can never be reassigned to refer to an different object.
However, the data within the object can be changed. So, the state of the object can be
changed but not the reference.
With variables, the final modifier often is used with static to make the constant a class
variable.
39Java
Example
public class Test{
final int value = 10;
// The following are examples of declaring constants:
public static final int BOXWIDTH = 6;
static final String TITLE = "Manager";
public void changeValue(){
value = 12; //will give an error
}
}
Final Methods
A final method cannot be overridden by any subclasses. As mentioned previously, the final
modifier prevents a method from being modified in a subclass.
The main intention of making a method final would be that the content of the method
should not be changed by any outsider.
Example
You declare methods using the final modifier in the class declaration, as in the following
example:
public class Test{
public final void changeName(){
// body of method
}
}
Final Classes
The main purpose of using a class being declared as final is to prevent the class from being
subclassed. If a class is marked as final then no class can inherit any feature from the final
class.
Example
public final class Test {
// body of class
}
40Java
The Abstract Modifier
Abstract Class
An abstract class can never be instantiated. If a class is declared as abstract then the sole
purpose is for the class to be extended.
A class cannot be both abstract and final (since a final class cannot be extended). If a class
contains abstract methods then the class should be declared abstract. Otherwise, a
compile error will be thrown.
An abstract class may contain both abstract methods as well normal methods.
Example
abstract class Caravan{
private double price;
private String model;
private String year;
public abstract void goFast(); //an abstract method
public abstract void changeColor();
}
Abstract Methods
An abstract method is a method declared without any implementation. The methods body
(implementation) is provided by the subclass. Abstract methods can never be final or
strict.
Any class that extends an abstract class must implement all the abstract methods of the
super class, unless the subclass is also an abstract class.
If a class contains one or more abstract methods, then the class must be declared abstract.
An abstract class does not need to contain abstract methods.
The abstract method ends with a semicolon. Example: public abstract sample();
41Java
Example
public abstract class SuperClass{
abstract void m(); //abstract method
}
class SubClass extends SuperClass{
// implements the abstract method
void m(){
.........
}
}
The Synchronized Modifier
The synchronized keyword used to indicate that a method can be accessed by only one
thread at a time. The synchronized modifier can be applied with any of the four access
level modifiers.
Example
public synchronized void showDetails(){
.......
}
The Transient Modifier
An instance variable is marked transient to indicate the JVM to skip the particular variable
when serializing the object containing it.
This modifier is included in the statement that creates the variable, preceding the class or
data type of the variable.
Example
public transient int limit = 55;
// will not persist
public int b; // will persist
The Volatile Modifier
The volatile modifier is used to let the JVM know that a thread accessing the variable must
always merge its own private copy of the variable with the master copy in the memory.
Accessing a volatile variable synchronizes all the cached copied of the variables in the main
memory. Volatile can only be applied to instance variables, which are of type object or
private. A volatile object reference can be null.
42Java
Example
public class MyRunnable implements Runnable{
private volatile boolean active;
public void run(){
active = true;
while (active){ // line 1
// some code here
}
}
public void stop(){
active = false; // line 2
} }
Usually, run() is called in one thread (the one you start using the Runnable), and stop() is
called from another thread. If in line 1, the cached value of active is used, the loop may
not stop when you set active to false in line 2. That's when you want to use volatile.
To use a modifier, you include its keyword in the definition of a class, method, or variable.
The modifier precedes the rest of the statement, as in the following example.
public class className {
// ...
}
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) {
// body of method
}
Access Control Modifiers
Java provides a number of access modifiers to set access levels for classes, variables,
methods and constructors. The four access levels are:
 Visible to the package, the default. No modifiers are needed.
 Visible to the class only (private).
 Visible to the world (public).
 Visible to the package and all subclasses (protected).
43Java
Non-Access Modifiers
Java provides a number of non-access modifiers to achieve many other functionality.
 The static modifier for creating class methods and variables.
 The final modifier for finalizing the implementations of classes, methods, and
variables.
 The abstract modifier for creating abstract classes and methods.
 The synchronized and volatile modifiers, which are used for threads.
What is Next?
In the next section, we will be discussing about Basic Operators used in Java Language.
The chapter will give you an overview of how these operators can be used during
application development.
448. Java – Basic Operators
Java
Java provides a rich set of operators to manipulate variables. We can divide all the Java
operators into the following groups:
 Arithmetic Operators
 Relational Operators
 Bitwise Operators
 Logical Operators
 Assignment Operators
 Misc Operators
The Arithmetic Operators
Arithmetic operators are used in mathematical expressions in the same way that they are
used in algebra. The following table lists the arithmetic operators:
Assume integer variable A holds 10 and variable B holds 20, then:
Sr.No.
Operator and Example
+ ( Addition )
1
Adds values on either side of the operator
Example: A + B will give 30
- ( Subtraction )
2
Subtracts right-hand operand from left-hand operand
Example: A - B will give -10
* ( Multiplication )
3
Multiplies values on either side of the operator
Example: A * B will give 200
45Java
/ (Division)
Divides left-hand operand by right-hand operand
4
Example: B / A will give 2
% (Modulus)
Divides left-hand operand by right-hand operand and returns remainder
5
Example: B % A will give 0
++ (Increment)
Increases the value of operand by 1
6
Example: B++ gives 21
-- ( Decrement )
Decreases the value of operand by 1
7
Example: B-- gives 19
Example
The following program is a simple example which demonstrates the arithmetic operators.
Copy and paste the following Java program in Test.java file, and compile and run this
program:
public class Test {
public static void main(String args[]) {
int a = 10;
int b = 20;
int c = 25;
int d = 25;
System.out.println("a + b = " + (a + b) );
System.out.println("a - b = " + (a - b) );
System.out.println("a * b = " + (a * b) );
System.out.println("b / a = " + (b / a) );
System.out.println("b % a = " + (b % a) );
System.out.println("c % a = " + (c % a) );
System.out.println("a++ = " + (a++) );
System.out.println("b-- = " + (a--) );
46Java
// Check the difference in d++ and ++d
System.out.println("d++ = " + (d++) );
System.out.println("++d = " + (++d) );
} }
This will produce the following result:
a + b = 30
a - b = -10
a * b = 200
b / a = 2
b % a = 0
c % a = 5
a++ = 10
b-- = 11
d++ = 25
++d = 27
The Relational Operators
There are following relational operators supported by Java language.
Assume variable A holds 10 and variable B holds 20, then:
Sr.No.
Operator and Description
== (equal to)
1
Checks if the values of two operands are equal or not, if yes then condition
becomes true.
Example: (A == B) is not true.
!= (not equal to)
2
Checks if the values of two operands are equal or not, if values are not
equal then condition becomes true.
Example: (A != B) is true.
47Java
> (greater than)
Checks if the value of left operand is greater than the value of right
operand, if yes then condition becomes true.
3
Example: (A > B) is not true.
< (less than)
Checks if the value of left operand is less than the value of right operand,
if yes then condition becomes true.
4
Example: (A < B) is true.
>= (greater than or equal to)
Checks if the value of left operand is greater than or equal to the value of
right operand, if yes then condition becomes true.
5
Example: (A >= B) is not true.
<= (less than or equal to)
Checks if the value of left operand is less than or equal to the value of right
operand, if yes then condition becomes true.
6
Example: (A <= B) is true.
Example
The following program is a simple example that demonstrates the relational operators.
Copy and paste the following Java program in Test.java file and compile and run this
program.
public class Test {
public static void main(String args[]) {
int a = 10;
int b = 20;
System.out.println("a == b = " + (a == b) );
System.out.println("a != b = " + (a != b) );
System.out.println("a > b = " + (a > b) );
System.out.println("a < b = " + (a < b) );
System.out.println("b >= a = " + (b >= a) );
System.out.println("b <= a = " + (b <= a) );
}
}
48Java
This will produce the following result:
a == b = false
a != b = true
a > b = false
a < b = true
b >= a = true
b <= a = false
The Bitwise Operators
Java defines several bitwise operators, which can be applied to the integer types, long,
int, short, char, and byte.
Bitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60 and b
= 13; now in binary format they will be as follows:
a = 0011 1100
b = 0000 1101
-----------------
a&b = 0000 1100
a|b = 0011 1101
a^b = 0011 0001
~a = 1100 0011
The following table lists the bitwise operators:
Assume integer variable A holds 60 and variable B holds 13 then:
Sr. No.
1
Operator and Description
& (bitwise and)
Binary AND Operator copies a bit to the result if it exists in both operands.
Example: (A & B) will give 12 which is 0000 1100
49Java
| (bitwise or)
2
Binary OR Operator copies a bit if it exists in either operand.
Example: (A | B) will give 61 which is 0011 1101
^ (bitwise XOR)
3
Binary XOR Operator copies the bit if it is set in one operand but not both.
Example: (A ^ B) will give 49 which is 0011 0001
~ (bitwise compliment)
4
Binary Ones Complement Operator is unary and has the effect of 'flipping'
bits.
Example: (~A ) will give -61 which is 1100 0011 in 2's complement form
due to a signed binary number.
<< (left shift)
5
Binary Left Shift Operator. The left operands value is moved left by the
number of bits specified by the right operand.
Example: A << 2 will give 240 which is 1111 0000
>> (right shift)
6
Binary Right Shift Operator. The left operands value is moved right by the
number of bits specified by the right operand.
Example: A >> 2 will give 15 which is 1111
>>> (zero fill right shift)
7
Shift right zero fill operator. The left operands value is moved right by the
number of bits specified by the right operand and shifted values are filled
up with zeros.
Example: A >>>2 will give 15 which is 0000 1111
50Java
Example
The following program is a simple example that demonstrates the bitwise operators. Copy
and paste the following Java program in Test.java file and compile and run this program:
public class Test {
public static void main(String args[]) {
int a = 60; /* 60 = 0011 1100 */
int b = 13; /* 13 = 0000 1101 */
int c = 0;
c = a & b;
/* 12 = 0000 1100 */
System.out.println("a & b = " + c );
c = a | b;
/* 61 = 0011 1101 */
System.out.println("a | b = " + c );
c = a ^ b;
/* 49 = 0011 0001 */
System.out.println("a ^ b = " + c );
c = ~a;
/*-61 = 1100 0011 */
System.out.println("~a = " + c );
c = a << 2;
/* 240 = 1111 0000 */
System.out.println("a << 2 = " + c );
c = a >> 2;
/* 15 = 1111 */
System.out.println("a >> 2
c = a >>> 2;
= " + c );
/* 15 = 0000 1111 */
System.out.println("a >>> 2 = " + c );
}
}
51Java
This will produce the following result:
a & b = 12
a | b = 61
a ^ b = 49
~a = -61
a << 2 = 240
a >> 15
a >>> 15
The Logical Operators
The following table lists the logical operators:
Assume Boolean variables A holds true and variable B holds false, then:
Operator
Description
&& (logical and)
1
Called Logical AND operator. If both the operands are non-zero, then the
condition becomes true.
Example: (A && B) is false.
|| (logical or)
2
Called Logical OR Operator. If any of the two operands are non-zero, then
the condition becomes true.
Example: (A || B) is true.
! (logical not)
3
Called Logical NOT Operator. Use to reverses the logical state of its
operand. If a condition is true then Logical NOT operator will make false.
Example: !(A && B) is true.
52Java
Example
The following simple example program demonstrates the logical operators. Copy and paste
the following Java program in Test.java file and compile and run this program:
public class Test {
public static void main(String args[]) {
boolean a = true;
boolean b = false;
System.out.println("a && b = " + (a&&b));
System.out.println("a || b = " + (a||b) );
System.out.println("!(a && b) = " + !(a && b));
}
}
This will produce the following result:
a && b = false
a || b = true
!(a && b) = true
The Assignment Operators
Following are the assignment operators supported by Java language:
Sr. No.
Operator and Description
=
1
Simple assignment operator. Assigns values from right side operands to left
side operand.
Example: C = A + B will assign value of A + B into C
53Java
+=
2
Add AND assignment operator. It adds right operand to the left operand
and assign the result to left operand.
Example: C += A is equivalent to C = C + A
-=
3
Subtract AND assignment operator. It subtracts right operand from the left
operand and assign the result to left operand.
Example:C -= A is equivalent to C = C – A
*=
4
Multiply AND assignment operator. It multiplies right operand with the left
operand and assign the result to left operand.
Example: C *= A is equivalent to C = C * A
/=
5
Divide AND assignment operator. It divides left operand with the right
operand and assign the result to left operand.
Example: C /= A is equivalent to C = C / A
%=
6
Modulus AND assignment operator. It takes modulus using two operands
and assign the result to left operand.
Example: C %= A is equivalent to C = C % A
<<=
7
Left shift AND assignment operator.
Example: C <<= 2 is same as C = C << 2
>>=
8
Right shift AND assignment operator
Example: C >>= 2 is same as C = C >> 2
54Java
&=
Bitwise AND assignment operator.
9
Example: C &= 2 is same as C = C & 2
^=
bitwise exclusive OR and assignment operator.
10
Example: C ^= 2 is same as C = C ^ 2
|=
bitwise inclusive OR and assignment operator.
11
Example: C |= 2 is same as C = C | 2
Example
The following program is a simple example that demonstrates the assignment operators.
Copy and paste the following Java program in Test.java file. Compile and run this program:
public class Test {
public static void main(String args[]) {
int a = 10;
int b = 20;
int c = 0;
c = a + b;
System.out.println("c = a + b = " + c );
c += a ;
System.out.println("c += a
= " + c );
c -= a ;
System.out.println("c -= a = " + c );
c *= a ;
System.out.println("c *= a = " + c );
55Java
a = 10;
c = 15;
c /= a ;
System.out.println("c /= a = " + c );
a = 10;
c = 15;
c %= a ;
System.out.println("c %= a
= " + c );
c <<= 2 ;
System.out.println("c <<= 2 = " + c );
c >>= 2 ;
System.out.println("c >>= 2 = " + c );
c >>= 2 ;
System.out.println("c >>= a = " + c );
c &= a ;
System.out.println("c &= 2
= " + c );
c ^= a ;
System.out.println("c ^= a
= " + c );
c |= a ;
System.out.println("c |= a
= " + c );
}
}
This will produce the following result:
c = a + b = 30
c += a
= 40
c -= a = 30
c *= a = 300
56Java
c /= a = 1
c %= a
= 5
c <<= 2 = 20
c >>= 2 = 5
c >>= 2 = 1
c &= a
= 0
c ^= a = 10
c |= a = 10
Miscellaneous Operators
There are few other operators supported by Java Language.
Conditional Operator ( ? : )
Conditional operator is also known as the ternary operator. This operator consists of
three operands and is used to evaluate Boolean expressions. The goal of the operator is
to decide, which value should be assigned to the variable. The operator is written as:
variable x = (expression) ? value if true : value if false
Following is an example:
public class Test {
public static void main(String args[]){
int a, b;
a = 10;
b = (a == 1) ? 20: 30;
System.out.println( "Value of b is : " +
b );
b = (a == 10) ? 20: 30;
System.out.println( "Value of b is : " + b );
}
}
This will produce the following result:
Value of b is : 30
Value of b is : 20
57Java
instanceof Operator
This operator is used only for object reference variables. The operator checks whether the
object is of a particular type (class type or interface type). instanceof operator is written
as:
( Object reference variable ) instanceof
(class/interface type)
If the object referred by the variable on the left side of the operator passes the IS-A check
for the class/interface type on the right side, then the result will be true. Following is an
example:
public class Test {
public static void main(String args[]){
String name = "James";
// following will return true since name is type of String
boolean result = name instanceof String;
System.out.println( result );
}
}
This will produce the following result:
true
This operator will still return true, if the object being compared is the assignment
compatible with the type on the right. Following is one more example:
class Vehicle {}
public class Car extends Vehicle {
public static void main(String args[]){
Vehicle a = new Car();
boolean result =
a instanceof Car;
System.out.println( result );
}
}
This will produce the following result:
true
58Java
Precedence of Java Operators
Operator precedence determines the grouping of terms in an expression. This affects how
an expression is evaluated. Certain operators have higher precedence than others; for
example, the multiplication operator has higher precedence than the addition operator:
For example, x = 7 + 3 * 2; here x is assigned 13, not 20 because operator * has higher
precedence than +, so it first gets multiplied with 3*2 and then adds into 7.
Here, operators with the highest precedence appear at the top of the table, those with the
lowest appear at the bottom. Within an expression, higher precedence operators will be
evaluated first.
Category
Operator
Associativity
Postfix () [] . (dot operator) Left toright
Unary ++ - - ! ~ Right to left
* / % Left to right
+ - Left to right
Shift >> >>> << Left to right
Relational > >= < <= Left to right
== != Left to right
Bitwise AND & Left to right
Bitwise XOR ^ Left to right
Bitwise OR | Left to right
Logical AND && Left to right
Logical OR || Left to right
Conditional ?: Right to left
Assignment = += -= *= /= %= >>= <<= &= ^= |= Right to left
Multiplicative
Additive
Equality
What is Next?
The next chapter will explain about loop control in Java programming. The chapter will
describe various types of loops and how these loops can be used in Java program
development and for what purposes they are being used.
599. Java – Loop Control
Java
There may be a situation when you need to execute a block of code several number of
times. In general, statements are executed sequentially: The first statement in a function
is executed first, followed by the second, and so on.
Programming languages provide various control structures that allow for more complicated
execution paths.
A loop statement allows us to execute a statement or group of statements multiple times
and following is the general form of a loop statement in most of the programming
languages:
Java programming language provides the following types of loop to handle looping
requirements. Click the following links to check their detail.
Loop Type
Description
while loop Repeats a statement or group of statements while a given
condition is true. It tests the condition before executing the
loop body.
for loop Execute a sequence of statements multiple times and
abbreviates the code that manages the loop variable.
do...while loop Like a while statement, except that it tests the condition at
the end of the loop body.
60Java
While Loop in Java
A while loop statement in Java programming language repeatedly executes a target
statement as long as a given condition is true.
Syntax
The syntax of a while loop is:
while(Boolean_expression)
{
//Statements
}
Here, statement(s) may be a single statement or a block of statements. The
condition may be any expression, and true is any non zero value.
When executing, if the boolean_expression result is true, then the actions inside the loop
will be executed. This will continue as long as the expression result is true.
When the condition becomes false, program control passes to the line immediately
following the loop.
Flow Diagram
61Java
Here, key point of the while loop is that the loop might not ever run. When the expression
is tested and the result is false, the loop body will be skipped and the first statement after
the while loop will be executed.
Example
public class Test {
public static void main(String args[]) {
int x = 10;
while( x < 20 ) {
System.out.print("value of x : " + x );
x++;
System.out.print("\n");
}
}
}
This will produce the following result:
value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
for Loop in Java
A for loop is a repetition control structure that allows you to efficiently write a loop that
needs to be executed a specific number of times.
A for loop is useful when you know how many times a task is to be repeated.
62Java
Syntax
The syntax of a for loop is:
for(initialization; Boolean_expression; update)
{
//Statements
}
Here is the flow of control in a for loop:
 The initialization step is executed first, and only once. This step allows you to
declare and initialize any loop control variables and this step ends with a semi colon
(;).
 Next, the Boolean expression is evaluated. If it is true, the body of the loop is
executed. If it is false, the body of the loop will not be executed and control jumps
to the next statement past the for loop.
 After the body of the for loop gets executed, the control jumps back up to the
update statement. This statement allows you to update any loop control variables.
This statement can be left blank with a semicolon at the end.
 The Boolean expression is now evaluated again. If it is true, the loop executes and
the process repeats (body of loop, then update step, then Boolean expression).
After the Boolean expression is false, the for loop terminates.
63Java
Flow Diagram
Example
Following is an example code of the for loop in Java.
public class Test {
public static void main(String args[]) {
for(int x = 10; x < 20; x = x+1) {
System.out.print("value of x : " + x );
System.out.print("\n");
}
}
64Java
}
This will produce the following result:
value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
Do While Loop in Java
A do...while loop is similar to a while loop, except that a do...while loop is guaranteed to
execute at least one time.
Syntax
Following is the syntax of a do...while loop:
do
{
//Statements
}while(Boolean_expression);
Notice that the Boolean expression appears at the end of the loop, so the statements in
the loop execute once before the Boolean is tested.
If the Boolean expression is true, the control jumps back up to do statement, and the
statements in the loop execute again. This process repeats until the Boolean expression is
false.
65Java
Flow Diagram
Example
public class Test {
public static void main(String args[]){
int x = 10;
do{
System.out.print("value of x : " + x );
x++;
System.out.print("\n");
}while( x < 20 );
}
}
66Java
This will produce the following result:
value of x : 10
value of x : 11
value of x : 12
value of x : 13
value of x : 14
value of x : 15
value of x : 16
value of x : 17
value of x : 18
value of x : 19
Loop Control Statements
Loop control statements change execution from its normal sequence. When execution
leaves a scope, all automatic objects that were created in that scope are destroyed.
Java supports the following control statements. Click the following links to check their
detail.
Control Statement
Description
break statement Terminates the loop or switch statement and transfers
execution to the statement immediately following the loop or
switch.
continue statement Causes the loop to skip the remainder of its body and
immediately retest its condition prior to reiterating.
Break Statement in Java
The break statement in Java programming language has the following two usages:
 When the break statement is encountered inside a loop, the loop is immediately
terminated and the program control resumes at the next statement following the
loop.
 It can be used to terminate a case in the switch statement (covered in the next
chapter).
67Java
Syntax
The syntax of a break is a single statement inside any loop:
break;
Flow Diagram
Example
public class Test {
public static void main(String args[]) {
int [] numbers = {10, 20, 30, 40, 50};
for(int x : numbers ) {
if( x == 30 ) {
break;
}
System.out.print( x );
System.out.print("\n");
}
}
}
68Java
This will produce the following result:
10
20
Continue Statement in Java
The continue keyword can be used in any of the loop control structures. It causes the
loop to immediately jump to the next iteration of the loop.
 In a for loop, the continue keyword causes control to immediately jump to the
update statement.
 In a while loop or do/while loop, control immediately jumps to the Boolean
expression.
Syntax
The syntax of a continue is a single statement inside any loop:
continue;
Flow Diagram
69Java
Example
public class Test {
public static void main(String args[]) {
int [] numbers = {10, 20, 30, 40, 50};
for(int x : numbers ) {
if( x == 30 ) {
continue;
}
System.out.print( x );
System.out.print("\n");
}
}
}
This will produce the following result:
10
20
40
50
Enhanced for loop in Java
As of Java 5, the enhanced for loop was introduced. This is mainly used to traverse
collection of elements including arrays.
Syntax
Following is the syntax of enhanced for loop:
for(declaration : expression)
{
//Statements
}

Declaration: The newly declared block variable, is of a type compatible with the
elements of the array you are accessing. The variable will be available within the
for block and its value would be the same as the current array element.
70Java

Expression: This evaluates to the array you need to loop through. The expression
can be an array variable or method call that returns an array.
Example
public class Test {
public static void main(String args[]){
int [] numbers = {10, 20, 30, 40, 50};
for(int x : numbers ){
System.out.print( x );
System.out.print(",");
}
System.out.print("\n");
String [] names ={"James", "Larry", "Tom", "Lacy"};
for( String name : names ) {
System.out.print( name );
System.out.print(",");
}
}
}
This will produce the following result:
10,20,30,40,50,
James,Larry,Tom,Lacy,
What is Next?
In the following chapter, we will be learning about decision making statements in Java
programming.
7110.
Java – Decision Making
Java
Decision making structures have one or more conditions to be evaluated or tested by the
program, along with a statement or statements that are to be executed if the condition is
determined to be true, and optionally, other statements to be executed if the condition is
determined to be false.
Following is the general form of a typical decision making structure found in most of the
programming languages:
Java programming language provides following types of decision making statements. Click
the following links to check their detail.
Statement
if statement
if...else statement
Description
An if statement consists of a boolean
followed by one or more statements.
expression
An if statement can be followed by an optional else
statement, which executes when the boolean
expression is false.
72Java
nested if
statements
switch statement
You can use one if or else if statement inside another if or else
if statement(s).
A switch statement allows a variable to be tested for equality
against a list of values.
If Statement in Java
An if statement consists of a Boolean expression followed by one or more statements.
Syntax
Following is the syntax of an if statement:
if(Boolean_expression)
{
//Statements will execute if the Boolean expression is true
}
If the Boolean expression evaluates to true then the block of code inside the if statement
will be executed. If not, the first set of code after the end of the if statement (after the
closing curly brace) will be executed.
Flow Diagram
73Java
Example
public class Test {
public static void main(String args[]){
int x = 10;
if( x < 20 ){
System.out.print("This is if statement");
}
}
}
This will produce the following result:
This is if statement.
If-else Statement in Java
An if statement can be followed by an optional else statement, which executes when the
Boolean expression is false.
Syntax
Following is the syntax of an if...else statement:
if(Boolean_expression){
//Executes when the Boolean expression is true
}else{
//Executes when the Boolean expression is false
}
If the boolean expression evaluates to true, then the if block of code will be executed,
otherwise else block of code will be executed.
74Java
Flow Diagram
Example
public class Test {
public static void main(String args[]){
int x = 30;
if( x < 20 ){
System.out.print("This is if statement");
}else{
System.out.print("This is else statement");
}
}
}
This will produce the following result:
75Java
This is else statement
The if...else if...else Statement
An if statement can be followed by an optional else if...else statement, which is very useful
to test various conditions using single if...else if statement.
When using if, else if, else statements there are a few points to keep in mind.
 An if can have zero or one else's and it must come after any else if's.
 An if can have zero to many else if's and they must come before the else.
 Once an else if succeeds, none of the remaining else if's or else's will be tested.
Syntax
Following is the syntax of an if...else statement:
if(Boolean_expression 1){
//Executes when the Boolean expression 1 is true
}else if(Boolean_expression 2){
//Executes when the Boolean expression 2 is true
}else if(Boolean_expression 3){
//Executes when the Boolean expression 3 is true
}else {
//Executes when the none of the above condition is true.
}
Example
public class Test {
public static void main(String args[]){
int x = 30;
if( x == 10 ){
System.out.print("Value of X is 10");
}else if( x == 20 ){
System.out.print("Value of X is 20");
}else if( x == 30 ){
System.out.print("Value of X is 30");
}else{
System.out.print("This is else statement");
}
76Java
}
}
This will produce the following result:
Value of X is 30
Nested if Statement in Java
It is always legal to nest if-else statements which means you can use one if or else if
statement inside another if or else if statement.
Syntax
The syntax for a nested if...else is as follows:
if(Boolean_expression 1){
//Executes when the Boolean expression 1 is true
if(Boolean_expression 2){
//Executes when the Boolean expression 2 is true
}
}
You can nest else if...else in the similar way as we have nested if statement.
Example
public class Test {
public static void main(String args[]){
int x = 30;
int y = 10;
if( x == 30 ){
if( y == 10 ){
System.out.print("X = 30 and Y = 10");
}
}
}
}
This will produce the following result:
77Java
X = 30 and Y = 10
Switch Statement in Java
A switch statement allows a variable to be tested for equality against a list of values.
Each value is called a case, and the variable being switched on is checked for each case.
Syntax
The syntax of enhanced for loop is:
switch(expression){
case value :
//Statements
break; //optional
case value :
//Statements
break; //optional
//You can have any number of case statements.
default : //Optional
//Statements
}
The following rules apply to a switch statement:
 The variable used in a switch statement can only be integers, convertable integers
(byte, short, char), strings and enums.
 You can have any number of case statements within a switch. Each case is followed
by the value to be compared to and a colon.
 The value for a case must be the same data type as the variable in the switch and
it must be a constant or a literal.
 When the variable being switched on is equal to a case, the statements following
that case will execute until a break statement is reached.
 When a break statement is reached, the switch terminates, and the flow of control
jumps to the next line following the switch statement.
 Not every case needs to contain a break. If no break appears, the flow of control
will fall through to subsequent cases until a break is reached.
78Java

A switch statement can have an optional default case, which must appear at the
end of the switch. The default case can be used for performing a task when none
of the cases is true. No break is needed in the default case.
Flow Diagram
Example
public class Test {
public static void main(String args[]){
//char grade = args[0].charAt(0);
char grade = 'C';
switch(grade)
{
case 'A' :
System.out.println("Excellent!");
break;
case 'B' :
case 'C' :
System.out.println("Well done");
79Java
break;
case 'D' :
System.out.println("You passed");
case 'F' :
System.out.println("Better try again");
break;
default :
System.out.println("Invalid grade");
}
System.out.println("Your grade is " + grade);
}
}
Compile and run the above program using various command line arguments. This will
produce the following result:
$ java Test
Well done
Your grade is a C
$
The ? : Operator:
We have covered conditional operator ? : in the previous chapter which can be used to
replace if...else statements. It has the following general form:
Exp1 ? Exp2 : Exp3;
Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.
To determine the value of the whole expression, initially exp1 is evaluated.
 If the value of exp1 is true, then the value of Exp2 will be the value of the whole
expression.
 If the value of exp1 is false, then Exp3 is evaluated and its value becomes the value
of the entire expression.
80Java
What is Next?
In the next chapter, we will discuss about Number class (in the java.lang package) and its
subclasses in Java Language.
We will be looking into some of the situations where you will use instantiations of these
classes rather than the primitive data types, as well as classes such as formatting,
mathematical functions that you need to know about when working with Numbers.
8111.
Java – Numbers Class
Java
Normally, when we work with Numbers, we use primitive data types such as byte, int,
long, double, etc.
Example
int i = 5000;
float gpa = 13.65;
byte mask = 0xaf;
However, in development, we come across situations where we need to use objects instead
of primitive data types. In order to achieve this, Java provides wrapper classes.
All the wrapper classes (Integer, Long, Byte, Double, Float, Short) are subclasses of the
abstract class Number.
The object of the wrapper class contains or wraps its respective primitive data type.
Converting primitive data types into object is called boxing, and this is taken care by the
compiler. Therefore, while using a wrapper class you just need to pass the value of the
primitive data type to the constructor of the Wrapper class.
And the Wrapper object will be converted back to a primitive data type, and this process
is called unboxing. The Number class is part of the java.lang package.
Following is an example of boxing and unboxing:
public class Test{
public static void main(String args[]){
Integer x = 5; // boxes int to an Integer object
x =
x + 10;
// unboxes the Integer to a int
System.out.println(x);
}
}
82Java
This will produce the following result:
15
When x is assigned an integer value, the compiler boxes the integer because x is integer
object. Later, x is unboxed so that they can be added as an integer.
Number Methods
Following is the list of the instance methods that all the subclasses of the Number class
implements:
Sr.
No.
1
Methods with Description
xxxValue()
Converts the value of this Number object to the xxx data type and returns it.
compareTo()
2
Compares this Number object to the argument.
equals()
3
Determines whether this number object is equal to the argument.
valueOf()
4
Returns an Integer object holding the value of the specified primitive.
toString()
5
Returns a String object representing the value of a specified int or Integer.
parseInt()
6
This method is used to get the primitive data type of a certain String.
abs()
7
Returns the absolute value of the argument.
83Java
ceil()
8
Returns the smallest integer that is greater than or equal to the argument.
Returned as a double.
floor()
9
Returns the largest integer that is less than or equal to the argument.
Returned as a double.
rint()
10
Returns the integer that is closest in value to the argument. Returned as a
double.
round()
11
Returns the closest long or int, as indicated by the method's return type to
the argument.
min()
12
Returns the smaller of the two arguments.
max()
13
Returns the larger of the two arguments.
exp()
14
Returns the base of the natural logarithms, e, to the power of the argument.
log()
15
Returns the natural logarithm of the argument.
pow()
16
Returns the value of the first argument raised to the power of the second
argument.
84Java
sqrt()
17
Returns the square root of the argument.
sin()
18
Returns the sine of the specified double value.
cos()
19
Returns the cosine of the specified double value.
tan()
20
Returns the tangent of the specified double value.
asin()
21
Returns the arcsine of the specified double value.
acos()
22
Returns the arccosine of the specified double value.
atan()
23
Returns the arctangent of the specified double value.
atan2()
24
Converts rectangular coordinates (x, y) to polar coordinate (r, theta) and
returns theta.
toDegrees()
25
Converts the argument to degrees.
toRadians()
26
Converts the argument to radians.
85Java
random()
27
Returns a random number.
Java XXXValue Method
Description
The method converts the value of the Number Object that invokes the method to the
primitive data type that is returned from the method.
Syntax
Here is a separate method for each primitive data type:
byte byteValue()
short shortValue()
int intValue()
long longValue()
float floatValue()
double doubleValue()
Parameters
Here is the detail of parameters:

All these are default methods and accepts no parameter.
Return Value

This method returns the primitive data type that is given in the signature.
Example
public class Test{
public static void main(String args[]){
Integer x = 5;
// Returns byte primitive data type
System.out.println( x.byteValue() );
86Java
// Returns double primitive data type
System.out.println(x.doubleValue());
// Returns long primitive data type
System.out.println( x.longValue() );
}
}
This will produce the following result:
5
5.0
5
Java – compareTo() Method
Description
The method compares the Number object that invoked the method to the argument. It is
possible to compare Byte, Long, Integer, etc.
However, two different types cannot be compared, both the argument and the Number
object invoking the method should be of the same type.
Syntax
public int compareTo( NumberSubClass referenceName )
Parameters
Here is the detail of parameters:

referenceName -- This could be a Byte, Double, Integer, Float, Long, or Short.
Return Value
 If the Integer is equal to the argument then 0 is returned.
 If the Integer is less than the argument then -1 is returned.
 If the Integer is greater than the argument then 1 is returned.
87Java
Example
public class Test{
public static void main(String args[]){
Integer x = 5;
System.out.println(x.compareTo(3));
System.out.println(x.compareTo(5));
System.out.println(x.compareTo(8));
}
}
This will produce the following result:
1
0
-1
Java – equals() Method
Description
The method determines whether the Number object that invokes the method is equal to
the object that is passed as an argument.
Syntax
public boolean equals(Object o)
Parameters
Here is the detail of parameters:

-- Any object.
Return Value

The method returns True if the argument is not null and is an object of the same
type and with the same numeric value. There are some extra requirements for
Double and Float objects that are described in the Java API documentation.
88Java
Example
public class Test{
public static void main(String args[]){
Integer x = 5;
Integer y = 10;
Integer z =5;
Short a = 5;
System.out.println(x.equals(y));
System.out.println(x.equals(z));
System.out.println(x.equals(a));
}
}
This will produce the following result:
false
true
false
Java – valueOf() Method
Description
The valueOf method returns the relevant Number Object holding the value of the argument
passed. The argument can be a primitive data type, String, etc.
This method is a static method. The method can take two arguments, where one is a
String and the other is a radix.
Syntax
Following are all the variants of this method:
static Integer valueOf(int i)
static Integer valueOf(String s)
static Integer valueOf(String s, int radix)
89Java
Parameters
Here is the detail of parameters:
 i -- An int for which Integer representation would be returned.
 s -- A String for which Integer representation would be returned.
 radix -- This would be used to decide the value of returned Integer based on the
passed String.
Return Value
 valueOf(int i): This returns an Integer object holding the value of the specified
primitive.
 valueOf(String s): This returns an Integer object holding the value of the
specified string representation.
 valueOf(String s, int radix): This returns an Integer object holding the integer
value of the specified string representation, parsed with the value of radix.
public class Test{
public static void main(String args[]){
Integer x =Integer.valueOf(9);
Double c = Double.valueOf(5);
Float a = Float.valueOf("80");
Integer b = Integer.valueOf("444",16);
System.out.println(x);
System.out.println(c);
System.out.println(a);
System.out.println(b);
}
}
This will produce the following result:
9
5.0
80.0
1092
90Java
Java – toString() Method
Description
The method is used to get a String object representing the value of the Number Object.
If the method takes a primitive data type as an argument, then the String object
representing the primitive data type value is returned.
If the method takes two arguments, then a String representation of the first argument in
the radix specified by the second argument will be returned.
Syntax
Following are all the variants of this method:
String toString()
static String toString(int i)
Parameters
Here is the detail of parameters:

i -- An int for which string representation would be returned.
Return Value
 toString(): This returns a String object representing the value of thisInteger.
 toString(int i): This returns a String object representing the specified integer.
Example
public class Test{
public static void main(String args[]){
Integer x = 5;
System.out.println(x.toString());
System.out.println(Integer.toString(12));
}
}
This will produce the following result:
5
12
91Java
Java – parseInt() Method
Description
This method is used to get the primitive data type of a certain String. parseXxx() is a static
method and can have one argument or two.
Syntax
Following are all the variants of this method:
static int parseInt(String s)
static int parseInt(String s, int radix)
Parameters
Here is the detail of parameters:
 s -- This is a string representation of decimal.
 radix -- This would be used to convert String s into integer.
Return Value
 parseInt(String s): This returns an integer (decimal only).
 parseInt(int i): This returns an integer, given a string representation of decimal,
binary, octal, or hexadecimal (radix equals 10, 2, 8, or 16 respectively) numbers
as input.
Example
public class Test{
public static void main(String args[]){
int x =Integer.parseInt("9");
double c = Double.parseDouble("5");
int b = Integer.parseInt("444",16);
System.out.println(x);
System.out.println(c);
System.out.println(b);
}
}
92Java
This will produce the following result:
9
5.0
1092
Java – abs() Method
Description
The method gives the absolute value of the argument. The argument can be int, float,
long, double, short, byte.
Syntax
Following are all the variants of this method:
double abs(double d)
float abs(float f)
int abs(int i)
long abs(long lng)
Parameters
Here is the detail of parameters:

Any primitive data type
Return Value

This method Returns the absolute value of the argument.
Example
public class Test{
public static void main(String args[]){
Integer a = -8;
double d = -100;
float f = -90;
System.out.println(Math.abs(a));
System.out.println(Math.abs(d));
System.out.println(Math.abs(f));
93Java
}
}
This will produce the following result:
8
100.0
90.0
Java – ceil() Method
Description
The method ceil gives the smallest integer that is greater than or equal to the argument.
Syntax
This method has the following variants:
double ceil(double d)
double ceil(float f)
Parameters
Here is the detail of parameters:

A double or float primitive data type
Return Value

This method returns the smallest integer that is greater than or equal to the
argument. Returned as a double.
Example
public class Test{
public static void main(String args[]){
double d = -100.675;
float f = -90;
System.out.println(Math.ceil(d));
System.out.println(Math.ceil(f));
94Java
System.out.println(Math.floor(d));
System.out.println(Math.floor(f));
}
}
This will produce the following result:
-100.0
-90.0
-101.0
-90.0
Java – floor() Method
Description
The method floor gives the largest integer that is less than or equal to the argument.
Syntax
This method has the following variants:
double floor(double d)
double floor(float f)
Parameters
Here is the detail of parameters:

A double or float primitive data type.
Return Value

This method returns the largest integer that is less than or equal to the argument.
Returned as a double.
Example
public class Test{
public static void main(String args[]){
double d = -100.675;
float f = -90;
95Java
System.out.println(Math.floor(d));
System.out.println(Math.floor(f));
System.out.println(Math.ceil(d));
System.out.println(Math.ceil(f));
}
}
This will produce the following result:
-101.0
-90.0
-100.0
-90.0
Java – rint() Method
Description
The method rint returns the integer that is closest in value to the argument.
Syntax
double rint(double d)
Parameters
Here is the detail of parameters:

d -- it accepts a double value as parameter.
Return Value

This method returns the integer that is closest in value to the argument. Returned
as a double.
Example
public class Test{
public static void main(String args[]){
double d = 100.675;
double e = 100.500;
double f = 100.200;
96Java
System.out.println(Math.rint(d));
System.out.println(Math.rint(e));
System.out.println(Math.rint(f));
}
}
This will produce the following result:
101.0
100.0
100.0
Java – round() Method
Description
The method round returns the closest long or int, as given by the methods return type.
Syntax
This method has the following variants:
long round(double d)
int round(float f)
Parameters
Here is the detail of parameters:
 d -- A double or float primitive data type
 f -- A float primitive data type
Return Value

This method returns the closest long or int, as indicated by the method's return
type, to the argument.
Example
public class Test{
public static void main(String args[]){
97Java
double d = 100.675;
double e = 100.500;
float f = 100;
float g = 90f;
System.out.println(Math.round(d));
System.out.println(Math.round(e));
System.out.println(Math.round(f));
System.out.println(Math.round(g));
}
}
This will produce the following result:
101
101
100
90
Java – min() Method
Description
The method gives the smaller of the two arguments. The argument can be int, float, long,
double.
Syntax
This method has the following variants:
double min(double arg1, double arg2)
float min(float arg1, float arg2)
int min(int arg1, int arg2)
long min(long arg1, long arg2)
Parameters
Here is the detail of parameters:

This method accepts any primitive data type as a parameter.
98Java
Return Value

This method returns the smaller of the two arguments.
Example
public class Test{
public static void main(String args[]){
System.out.println(Math.min(12.123, 12.456));
System.out.println(Math.min(23.12, 23.0));
}
}
This will produce the following result:
12.123
23.0
Java – max() Method
Description
This method gives the maximum of the two arguments. The argument can be int, float,
long, double.
Syntax
This method has the following variants:
double max(double arg1, double arg2)
float max(float arg1, float arg2)
int max(int arg1, int arg2)
long max(long arg1, long arg2)
Parameters
Here is the detail of parameters:

This method accepts any primitive data type as a parameter.
Return Value

This method returns the maximum of the two arguments.
99Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Math.max(12.123, 12.456));
System.out.println(Math.max(23.12, 23.0));
}
}
This will produce the following result:
12.456
23.12
Java – exp() Method
Description
The method returns the base of the natural logarithms, e, to the power of the argument.
Syntax
double exp(double d)
Parameters
Here is the detail of parameters:

d --Any primitive data type.
Return Value

This method returns the base of the natural logarithms, e, to the power of the
argument.
100Java
Example
public class Test{
public static void main(String args[]){
double x = 11.635;
double y = 2.76;
System.out.printf("The value of e is %.4f%n", Math.E);
System.out.printf("exp(%.3f) is %.3f%n", x, Math.exp(x));
}
}
This will produce the following result:
The value of e is 2.7183
exp(11.635) is 112983.831
Java – log() Method
Description
The method returns the natural logarithm of the argument.
Syntax
double log(double d)
Parameters
Here is the detail of parameters:

d -- Any primitive data type.
Return Value

This method returns the natural logarithm of the argument.
101Java
Example
public class Test{
public static void main(String args[]){
double x = 11.635;
double y = 2.76;
System.out.printf("The value of e is %.4f%n", Math.E);
System.out.printf("log(%.3f) is %.3f%n", x, Math.log(x));
}
}
This will produce the following result:
The value of e is 2.7183
log(11.635) is 2.454
Java – pow() Method
Description
The method returns the value of the first argument raised to the power of the second
argument.
Syntax
double pow(double base, double exponent)
Parameters
Here is the detail of parameters −
 base -- Any primitive data type.
 exponenet -- Any primitive data type.
Return Value

This method returns the value of the first argument raised to the power of the
second argument.
102Java
Example
public class Test{
public static void main(String args[]){
double x = 11.635;
double y = 2.76;
System.out.printf("The value of e is %.4f%n", Math.E);
System.out.printf("pow(%.3f, %.3f) is %.3f%n", x, y, Math.pow(x, y));
}
}
This will produce the following result −
The value of e is 2.7183
pow(11.635, 2.760) is 874.008
Java – sqrt() Method
Description
The method returns the square root of the argument.
Syntax
double sqrt(double d)
Parameters
Here is the detail of parameters:

d -- Any primitive data type.
Return Value

This method returns the square root of the argument.
103Java
Example
public class Test{
public static void main(String args[]){
double x = 11.635;
double y = 2.76;
System.out.printf("The value of e is %.4f%n", Math.E);
System.out.printf("sqrt(%.3f) is %.3f%n", x, Math.sqrt(x));
}
}
This will produce the following result:
The value of e is 2.7183
sqrt(11.635) is 3.411
Java – sin() Method
Description
The method returns the sine of the specified double value.
Syntax
double sin(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns the sine of the specified double value.
104Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The sine of %.1f degrees is %.4f%n", degrees,
Math.sin(radians));
}
}
This will produce the following result:
The value of pi is 3.1416
The sine of 45.0 degrees is 0.7071
Java – cos() Method
Description
The method returns the cosine of the specified double value.
Syntax
double cos(double d)
Parameters
Here is the detail of parameters:

d -- This method accepts a value of double data type.
Return Value

This method returns the cosine of the specified double value.
105Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The cosine of %.1f degrees is %.4f%n", degrees,
Math.cos(radians));
}
}
This will produce the following result:
The value of pi is 3.1416
The cosine of 45.0 degrees is 0.7071
Java – tan() Method
Description
The method returns the tangent of the specified double value.
Syntax
double tan(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns the tangent of the specified double value.
106Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The tangent of %.1f degrees is %.4f%n", degrees,
Math.tan(radians));
}
}
This will produce the following result:
The value of pi is 3.1416
The tangent of 45.0 degrees is 1.0000
Java – asin() Method
Description
The method returns the arcsine of the specified double value.
Syntax
double asin(double d)
Parameters
Here is the detail of parameters:

d -- A double data types.
Return Value

This method returns the arcsine of the specified double value.
107Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The arcsine of %.4f is %.4f degrees %n",
Math.sin(radians), Math.toDegrees(Math.asin(Math.sin(radians))));
}
}
This will produce the following result:
The value of pi is 3.1416
The arcsine of 0.7071 is 45.0000 degrees
Java – acos() Method
Description
The method returns the arccosine of the specified double value.
Syntax
double acos(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns the arccosine of the specified double value.
108Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The arccosine of %.4f is %.4f degrees %n",
Math.cos(radians), Math.toDegrees(Math.acos(Math.sin(radians))));
}
}
This will produce the following result:
The value of pi is 3.1416
The arccosine of 0.7071 is 45.0000 degrees
Java – atan() Method
Description
The method returns the arctangent of the specified double value.
Syntax
double atan(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns the arctangent of the specified double value.
109Java
Example
public class Test{
public static void main(String args[]){
double degrees = 45.0;
double radians = Math.toRadians(degrees);
System.out.format("The value of pi is %.4f%n", Math.PI);
System.out.format("The arctangent of %.4f is %.4f degrees %n",
Math.cos(radians), Math.toDegrees(Math.atan(Math.sin(radians))));
}
}
This will produce the following result:
The value of pi is 3.1416
The arctangent of 1.0000 is 45.0000 degrees
Java – atan2() Method
Description
The method converts rectangular coordinates (x, y) to polar coordinate (r, theta) and
returns theta.
Syntax
double atan2(double y, double x)
Parameters
Here is the detail of parameters:
 X -- X co-ordinate in double data type.
 Y -- Y co-ordinate in double data type.
Return Value

This method returns theta from polar coordinate (r, theta).
110Java
Example
public class Test{
public static void main(String args[]){
double x = 45.0;
double y = 30.0;
System.out.println( Math.atan2(x, y) );
}
}
This will produce the following result:
0.982793723247329
Java – toDegrees() Method
Description
The method converts the argument value to degrees.
Syntax
double toDegrees(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns a double value.
111Java
Example
public class Test{
public static void main(String args[]){
double x = 45.0;
double y = 30.0;
System.out.println( Math.toDegrees(x) );
System.out.println( Math.toDegrees(y) );
}
}
This will produce the following result:
2578.3100780887044
1718.8733853924698
Java – toRadians() Method
Description
The method converts the argument value to radians.
Syntax
double toRadians(double d)
Parameters
Here is the detail of parameters:

d -- A double data type.
Return Value

This method returns a double value.
112Java
Example
public class Test{
public static void main(String args[]){
double x = 45.0;
double y = 30.0;
System.out.println( Math.toRadians(x) );
System.out.println( Math.toRadians(y) );
}
}
This will produce the following result:
0.7853981633974483
0.5235987755982988
Java – random() Method
Description
The method is used to generate a random number between 0.0 and 1.0. The range is: 0.0
=< Math.random < 1.0. Different ranges can be achieved by using arithmetic operations.
Syntax
static double random()
Parameters
Here is the detail of parameters:

This is a default method and accepts no parameter.
Return Value

This method returns a double.
113Java
Example
public class Test{
public static void main(String args[]){
System.out.println( Math.random() );
System.out.println( Math.random() );
}
}
This will produce the following result:
0.16763945061451657
0.400551253762343
Note: The above result will vary every time you call random() method.
What is Next?
In the next section, we will be going through the Character class in Java. You will be
learning how to use object Characters and primitive data type char in Java.
11412.
Java – Character Class
Java
Normally, when we work with characters, we use primitive data types char.
Example
char ch = 'a';
// Unicode for uppercase Greek omega character
char uniChar = '\u039A';
// an array of chars
char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };
However in development, we come across situations where we need to use objects instead
of primitive data types. In order to achieve this, Java provides wrapper
class Character for primitive data type char.
The Character class offers a number of useful class (i.e., static) methods for manipulating
characters. You can create a Character object with the Character constructor:
Character ch = new Character('a');
The Java compiler will also create a Character object for you under some circumstances.
For example, if you pass a primitive char into a method that expects an object, the
compiler automatically converts the char to a Character for you. This feature is called
autoboxing or unboxing, if the conversion goes the other way.
Example
// Here following primitive char 'a'
// is boxed into the Character object ch
Character ch = 'a';
// Here primitive 'x' is boxed for method test,
// return is unboxed to char 'c'
char c = test('x');
Escape Sequences
A character preceded by a backslash (\) is an escape sequence and has a special meaning
to the compiler.
115Java
The newline character (\n) has been used frequently in this tutorial in System.out.println()
statements to advance to the next line after the string is printed.
Following table shows the Java escape sequences:
Escape Sequence
Description
\t Inserts a tab in the text at this point.
\b Inserts a backspace in the text at this point.
\n Inserts a newline in the text at this point.
\r Inserts a carriage return in the text at this point.
\f Inserts a form feed in the text at this point.
\' Inserts a single quote character in the text at this point.
\" Inserts a double quote character in the text at this point.
\\ Inserts a backslash character in the text at this point.
When an escape sequence is encountered in a print statement, the compiler interprets it
accordingly.
Example
If you want to put quotes within quotes, you must use the escape sequence, \", on the
interior quotes:
public class Test {
public static void main(String args[]) {
System.out.println("She said \"Hello!\" to me.");
}
}
This will produce the following result:
She said "Hello!" to me.
116Java
Character Methods
Following is the list of the important instance methods that all the subclasses of the
Character class implement:
Sr.
No.
Methods with Description
isLetter()
1
Determines whether the specified char value is a letter.
isDigit()
2
Determines whether the specified char value is a digit.
isWhitespace()
3
Determines whether the specified char value is white space.
isUpperCase()
4
Determines whether the specified char value is uppercase.
isLowerCase()
5
Determines whether the specified char value is lowercase.
toUpperCase()
6
Returns the uppercase form of the specified char value.
toLowerCase()
7
Returns the lowercase form of the specified char value.
toString()
8
Returns a String object representing the specified character value that is, a
one-character string.
Java – isLetter() Method
Description
The method determines whether the specified char value is a letter.
Syntax
boolean isLetter(char ch)
117Java
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns true if the passed character is really a character.
Example
public class Test {
public static void main(String args[]) {
System.out.println(Character.isLetter('c'));
System.out.println(Character.isLetter('5'));
}
}
This will produce the following result:
true
false
Java – isDigit() Method
Description
The method determines whether the specified char value is a digit.
Syntax
boolean isDigit(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns true, if the passed character is really a digit.
118Java
Example
public class Test {
public static void main(String args[]) {
System.out.println(Character.isDigit('c'));
System.out.println(Character.isDigit('5'));
}
}
This will produce the following result:
false
true
Java – isWhitespace() Method
Description
The method determines whether the specified char value is a white space, which includes
space, tab, or new line.
Syntax
boolean isWhitespace(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns true, if the passed character is really a white space.
119Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Character.isWhitespace('c'));
System.out.println(Character.isWhitespace(' '));
System.out.println(Character.isWhitespace('\n'));
System.out.println(Character.isWhitespace('\t'));
}
}
This will produce the following result:
false
true
true
true
Java – isUpperCase() Method
Description
This method determines whether the specified char value is uppercase.
Syntax
boolean isUpperCase(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns true, if the passed character is really an uppercase.
120Java
Example
public class Test{
public static void main(String args[]){
System.out.println( Character.isUpperCase('c'));
System.out.println( Character.isUpperCase('C'));
System.out.println( Character.isUpperCase('\n'));
System.out.println( Character.isUpperCase('\t'));
}
}
This will produce the following result:
false
true
false
false
Java – isLowerCase() Method
Description
The method determines whether the specified char value is lowercase.
Syntax
boolean isLowerCase(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns true, if the passed character is really in lowercase.
121Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Character.isLowerCase('c'));
System.out.println(Character.isLowerCase('C'));
System.out.println(Character.isLowerCase('\n'));
System.out.println(Character.isLowerCase('\t'));
}
}
This will produce the following result:
true
false
false
false
Java – toUpperCase() Method
Description
The method returns the uppercase form of the specified char value.
Syntax
char toUpperCase(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns the uppercase form of the specified char value.
122Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Character.toUpperCase('c'));
System.out.println(Character.toUpperCase('C'));
}
}
This will produce the following result:
C
C
Java – toLowerCase() Method
Description
The method returns the lowercase form of the specified char value.
Syntax
char toLowerCase(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns the lowercase form of the specified char value.
123Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Character.toLowerCase('c'));
System.out.println(Character.toLowerCase('C'));
}
}
This will produce the following result:
c
c
Java – toString() Method
Description
This method returns a String object representing the specified character value, that is, a
one-character string.
Syntax
String toString(char ch)
Parameters
Here is the detail of parameters:

ch -- Primitive character type.
Return Value

This method returns String object.
124Java
Example
public class Test{
public static void main(String args[]){
System.out.println(Character.toString('c'));
System.out.println(Character.toString('C'));
}
}
This will produce the following result:
c
C
For a complete list of methods, please refer to the java.lang.Character API specification.
What is Next?
In the next section, we will be going through the String class in Java. You will be learning
how to declare and use Strings efficiently as well as some of the important methods in the
String class.
12513.
Java – Strings Class
Java
Strings, which are widely used in Java programming, are a sequence of characters. In Java
programming language, strings are treated as objects.
The Java platform provides the String class to create and manipulate strings.
Creating Strings
The most direct way to create a string is to write:
String greeting = "Hello world!";
Whenever it encounters a string literal in your code, the compiler creates a String object
with its value in this case, "Hello world!'.
As with any other object, you can create String objects by using the new keyword and a
constructor. The String class has 11 constructors that allow you to provide the initial value
of the string using different sources, such as an array of characters.
public class StringDemo{
public static void main(String args[]){
char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.'};
String helloString = new String(helloArray);
System.out.println( helloString );
}
}
This will produce the following result:
hello.
Note: The String class is immutable, so that once it is created a String object cannot be
changed. If there is a necessity to make a lot of modifications to Strings of characters,
then you should use String Buffer & String Builder Classes.
Java – String Buffer & String Builder Classes
The StringBuffer and StringBuilder classes are used when there is a necessity to make
a lot of modifications to Strings of characters.
Unlike Strings, objects of type StringBuffer and String builder can be modified over and
over again without leaving behind a lot of new unused objects.
126Java
The StringBuilder class was introduced as of Java 5 and the main difference between the
StringBuffer and StringBuilder is that StringBuilders methods are not thread safe (not
synchronised).
It is recommended to use StringBuilder whenever possible because it is faster than
StringBuffer. However, if the thread safety is necessary, the best option is StringBuffer
objects.
Example
public class Test{
public static void main(String args[]){
StringBuffer sBuffer = new StringBuffer(" test");
sBuffer.append(" String Buffer");
System.out.println(sBuffer);
}
}
This will produce the following result:
test String Buffer
StringBuffer Methods
Here is the list of important methods supported by StringBuffer class:
Sr.
No.
Methods with Description
public StringBuffer append(String s)
1
Updates the value of the object that invoked the method. The method takes
boolean, char, int, long, Strings, etc.
public StringBuffer reverse()
2
The method reverses the value of the StringBuffer object that invoked the
method.
public delete(int start, int end)
3
Deletes the string starting from the start index until the end index.
127Java
public insert(int offset, int i)
4
This method inserts a string s at the position mentioned by the offset.
replace(int start, int end, String str)
5
This method replaces the characters in a substring of this StringBuffer with
characters in the specified String.
Java – String Buffer append() Method
Description
This method updates the value of the object that invoked the method. The method takes
boolean, char, int, long, Strings, etc.
Syntax
Here is a separate method for each primitive data type:
public StringBuffer append(boolean b)
public StringBuffer append(char c)
public StringBuffer append(char[] str)
public StringBuffer append(char[] str, int offset, int len)
public StringBuffer append(double d)
public StringBuffer append(float f)
public StringBuffer append(int i)
public StringBuffer append(long l)
public StringBuffer append(Object obj)
public StringBuffer append(StringBuffer sb)
public StringBuffer append(String str)
Parameters
Here is the detail of parameters:

Here the parameter depends on what you are trying to append in the String Buffer.
Return Value

These methods return the updated StringBuffer objects.
128Java
Example
public class Test {
public static void main(String args[]) {
StringBuffer sb = new StringBuffer("Test");
sb.append(" String Buffer");
System.out.println(sb);
}
}
This will produce the following result:
Test String Buffer
Java – String Buffer reverse() Method
Description
This method reverses the value of the StringBuffer object that invoked the method.
Let n be the length of the old character sequence, the one contained in the string buffer
just prior to the execution of the reverse method. Then, the character at index k in the
new character sequence is equal to the character at index n-k-1 in the old character
sequence.
Syntax
Here is the syntax for this method:
public StringBuffer reverse()
Parameters
Here is the detail of parameters:

NA
Return Value

This method returns StringBuffer object with the reversed sequence.
129Java
Example
public class Test {
public static void main(String args[]) {
StringBuffer buffer = new StringBuffer("Game Plan");
buffer.reverse();
System.out.println(buffer);
}
}
This will produce the following result:
nalP emaG
Java – String Buffer delete() Method
Description
This method removes the characters in a substring of this StringBuffer. The substring
begins at the specified start and extends to the character at index end - 1 or to the end of
the StringBuffer if no such character exists.
If start is equal to end, no changes are made.
Syntax
Here is the syntax of this method:
public StringBuffer delete(int start, int end)
Parameters
Here is the detail of parameters:
 start -- The beginning index, inclusive.
 end -- The ending index, exclusive.
Return Value

This method returns the StringBuffer object.
130Java
Example
public class Test {
public static void main(String args[]) {
StringBuffer sb = new StringBuffer("abcdefghijk");
sb.delete(3,7);
System.out.println(sb);
}
}
This will produce the following result:
abchijk
Java – String Buffer insert() Method
Description
This method removes the characters in a substring of this StringBuffer. The substring
begins at the specified start and extends to the character at index end - 1 or to the end of
the StringBuffer, if no such character exists.
If start is equal to end, no changes are made.
Syntax
Here is a separate method for each primitive data type:
public StringBuffer insert(int offset, boolean b)
public StringBuffer insert(int offset, char c)
public insert(int offset, char[] str)
public StringBuffer insert(int index, char[] str,
int offset, int len)
public StringBuffer insert(int offset, float f)
public StringBuffer insert(int offset, int i)
public StringBuffer insert(int offset, long l)
public StringBuffer insert(int offset, Object obj)
public StringBuffer insert(int offset, String str)
131Java
Parameters
Here is the detail of parameters:

Parameter depends on what you are trying to insert.
Return Value

This method returns the modified StringBuffer object.
Example
public class Test {
public static void main(String args[]) {
StringBuffer sb = new StringBuffer("abcdefghijk");
sb.insert(3,"123");
System.out.println(sb);
}
}
This will produce the following result:
abc123defghijk
Java – String Buffer replace() Method
Description
This method replaces the characters in a substring of this StringBuffer with characters in
the specified String.
The substring begins at the specified start and extends to the character at index end - 1
or to the end of the StringBuffer, if no such character exists. First the characters in the
substring are removed and then the specified String is inserted at start.
Syntax
Here is the syntax of this method:
public StringBuffer replace(int start, int end, String str)
132Java
Parameters
Here is the detail of parameters:
 start -- The beginning index, inclusive.
 end -- The ending index, exclusive.
 str -- String that will replace previous contents.
Return Value

This method returns the modified StringBuffer object.
Example
public class Test {
public static void main(String args[]) {
StringBuffer sb = new StringBuffer("abcdefghijk");
sb.replace(3, 8, "ZARA");
System.out.println(sb);
}
}
This will produce the following result:
abcZARAijk
Here is the list of other methods (except set methods) which are very similar to String
class:
Sr.
No.
1
Methods with Description
int capacity()
Returns the current capacity of the String buffer.
133Java
char charAt(int index)
2
The specified character of the sequence currently represented by the string
buffer, as indicated by the index argument, is returned.
void ensureCapacity(int minimumCapacity)
3
Ensures that the capacity of the buffer is at least equal to the specified
minimum.
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
4
Characters are copied from this string buffer into the destination character
array dst.
int indexOf(String str)
5
Returns the index within this string of the first occurrence of the specified
substring.
int indexOf(String str, int fromIndex)
6
Returns the index within this string of the first occurrence of the specified
substring, starting at the specified index.
int lastIndexOf(String str)
7
Returns the index within this string of the rightmost occurrence of the specified
substring.
int lastIndexOf(String str, int fromIndex)
8
9
10
Returns the index within this string of the last occurrence of the specified
substring.
int length()
Returns the length (character count) of this string buffer.
void setCharAt(int index, char ch)
The character at the specified index of this string buffer is set to ch.
134Java
11
12
void setLength(int newLength)
Sets the length of this String buffer.
CharSequence subSequence(int start, int end)
Returns a new character sequence that is a subsequence of this sequence.
String substring(int start)
13
Returns a new String that contains a subsequence of characters currently
contained in this StringBuffer.The substring begins at the specified index and
extends to the end of the StringBuffer.
String substring(int start, int end)
14
15
Returns a new String that contains a subsequence of characters currently
contained in this StringBuffer.
String toString()
Converts to a string representing the data in this string buffer.
String Length
Methods used to obtain information about an object are known as accessor methods.
One accessor method that you can use with strings is the length() method, which returns
the number of characters contained in the string object.
The following program is an example of length(), method String class.
public class StringDemo {
public static void main(String args[]) {
String palindrome = "Dot saw I was Tod";
int len = palindrome.length();
System.out.println( "String Length is : " + len );
}
}
This will produce the following result:
String Length is : 17
135Java
Concatenating Strings
The String class includes a method for concatenating two strings:
string1.concat(string2);
This returns a new string that is string1 with string2 added to it at the end. You can also
use the concat() method with string literals, as in:
"My name is ".concat("Zara");
Strings are more commonly concatenated with the + operator, as in:
"Hello," + " world" + "!"
which results in:
"Hello, world!"
Let us look at the following example:
public class StringDemo {
public static void main(String args[]) {
String string1 = "saw I was ";
System.out.println("Dot " + string1 + "Tod");
}
}
This will produce the following result:
Dot saw I was Tod
Creating Format Strings
You have printf() and format() methods to print output with formatted numbers. The
String class has an equivalent class method, format(), that returns a String object rather
than a PrintStream object.
136Java
Using String's static format() method allows you to create a formatted string that you can
reuse, as opposed to a one-time print statement. For example, instead of:
System.out.printf("The value of the float variable is " +
"%f, while the value of the integer " +
"variable is %d, and the string " +
"is %s", floatVar, intVar, stringVar);
You can write:
String fs;
fs = String.format("The value of the float variable is " +
"%f, while the value of the integer " +
"variable is %d, and the string " +
"is %s", floatVar, intVar, stringVar);
System.out.println(fs);
String Methods
Here is the list of methods supported by String class:
Sr.
No.
1
Methods with Description
char charAt(int index)
Returns the character at the specified index.
int compareTo(Object o)
2
Compares this String to another Object.
int compareTo(String anotherString)
3
Compares two strings lexicographically.
int compareToIgnoreCase(String str)
4
Compares two strings lexicographically, ignoring case differences.
137Java
String concat(String str)
5
Concatenates the specified string to the end of this string.
boolean contentEquals(StringBuffer sb)
6
Returns true if and only if this String represents the same sequence of
characters as the specified StringBuffer.
static String copyValueOf(char[] data)
7
Returns a String that represents the character sequence in the array specified.
static String copyValueOf(char[] data, int offset, int count)
8
Returns a String that represents the character sequence in the array specified.
boolean endsWith(String suffix)
9
Tests if this string ends with the specified suffix.
boolean equals(Object anObject)
10
Compares this string to the specified object.
boolean equalsIgnoreCase(String anotherString)
11
Compares this String to another String, ignoring case considerations.
byte getBytes()
12
Encodes this String into a sequence of bytes using the platform's default
charset, storing the result into a new byte array.
byte[] getBytes(String charsetName)
13
Encodes this String into a sequence of bytes using the named charset, storing
the result into a new byte array.
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
14
Copies characters from this string into the destination character array.
138Java
int hashCode()
15
Returns a hash code for this string.
int indexOf(int ch)
16
Returns the index within this string of the first occurrence of the specified
character.
int indexOf(int ch, int fromIndex)
17
Returns the index within this string of the first occurrence of the specified
character, starting the search at the specified index.
int indexOf(String str)
18
Returns the index within this string of the first occurrence of the specified
substring.
int indexOf(String str, int fromIndex)
19
Returns the index within this string of the first occurrence of the specified
substring, starting at the specified index.
String intern()
20
Returns a canonical representation for the string object.
int lastIndexOf(int ch)
21
Returns the index within this string of the last occurrence of the specified
character.
int lastIndexOf(int ch, int fromIndex)
22
Returns the index within this string of the last occurrence of the specified
character, searching backward starting at the specified index.
int lastIndexOf(String str)
23
Returns the index within this string of the rightmost occurrence of the specified
substring.
int lastIndexOf(String str, int fromIndex)
24
Returns the index within this string of the last occurrence of the specified
substring, searching backward starting at the specified index.
139Java
int length()
25
Returns the length of this string.
boolean matches(String regex)
26
Tells whether or not this string matches the given regular expression.
boolean regionMatches(boolean ignoreCase, int toffset, String other,
27
int ooffset, int len)
Tests if two string regions are equal.
boolean regionMatches(int toffset, String other, int ooffset, int len)
28
Tests if two string regions are equal.
String replace(char oldChar, char newChar)
29
Returns a new string resulting from replacing all occurrences of oldChar in this
string with newChar.
String replaceAll(String regex, String replacement
30
Replaces each substring of this string that matches the given regular
expression with the given replacement.
String replaceFirst(String regex, String replacement)
31
Replaces the first substring of this string that matches the given regular
expression with the given replacement.
String[] split(String regex)
32
Splits this string around matches of the given regular expression.
String[] split(String regex, int limit)
33
Splits this string around matches of the given regular expression.
boolean startsWith(String prefix)
34
Tests if this string starts with the specified prefix.
140Java
boolean startsWith(String prefix, int toffset)
35
Tests if this string starts with the specified prefix beginning a specified index.
CharSequence subSequence(int beginIndex, int endIndex)
36
Returns a new character sequence that is a subsequence of this sequence.
String substring(int beginIndex)
37
Returns a new string that is a substring of this string.
String substring(int beginIndex, int endIndex)
38
Returns a new string that is a substring of this string.
char[] toCharArray()
39
Converts this string to a new character array.
String toLowerCase()
40
Converts all of the characters in this String to lower case using the rules of the
default locale.
String toLowerCase(Locale locale)
41
Converts all of the characters in this String to lower case using the rules of the
given Locale.
String toString()
42
This object (which is already a string!) is itself returned.
String toUpperCase()
43
Converts all of the characters in this String to upper case using the rules of
the default locale.
String toUpperCase(Locale locale)
44
Converts all of the characters in this String to upper case using the rules of
the given Locale.
141Java
String trim()
45
Returns a copy of the string, with leading and trailing whitespace omitted.
static String valueOf(primitive data type x)
46
Returns the string representation of the passed data type argument.
Java – String chartAt() Method
Description
This method returns the character located at the String's specified index. The string
indexes start from zero.
Syntax
Here is the syntax of this method:
public char charAt(int index)
Parameters
Here is the detail of parameters:

index -- Index of the character to be returned.
Return Value

This method returns a char at the specified index.
Example
public class Test {
public static void main(String args[]) {
String s = "Strings are immutable";
char result = s.charAt(8);
System.out.println(result);
}
}
This will produce the following result:
a
142Java
Java – String compareTo(Object o) Method
Description
This method compares this String to another Object.
Syntax
Here is the syntax of this method:
int compareTo(Object o)
Parameters
Here is the detail of parameters:

O-- the Object to be compared.
Return Value

The value 0 if the argument is a string lexicographically equal to this string; a value
less than 0 if the argument is a string lexicographically greater than this string; and
a value greater than 0 if the argument is a string lexicographically less than this
string.
Example
public class Test {
public static void main(String args[]) {
String str1 = "Strings are immutable";
String str2 = new String("Strings are immutable");
String str3 = new String("Integers are not immutable");
int result = str1.compareTo( str2 );
System.out.println(result);
result = str2.compareTo( str3 );
System.out.println(result);
}
}
143Java
This will produce the following result:
0
10
Java – String compareTo(String anotherString) Method
Description
This method compares two strings lexicographically.
Syntax
Here is the syntax of this method:
int compareTo(String anotherString)
Parameters
Here is the detail of parameters:

anotherString -- the String to be compared.
Return Value

The value 0 if the argument is a string lexicographically equal to this string; a value
less than 0 if the argument is a string lexicographically greater than this string;
and a value greater than 0 if the argument is a string lexicographically less than
this string.
Example
public class Test {
public static void main(String args[]) {
String str1 = "Strings are immutable";
String str2 = "Strings are immutable";
String str3 = "Integers are not immutable";
int result = str1.compareTo( str2 );
System.out.println(result);
result = str2.compareTo( str3 );
System.out.println(result);
144Java
result = str3.compareTo( str1 );
System.out.println(result);
}
}
This will produce the following result:
0
10
-10
Java – String compareToIgnoreCase() Method
Description
This method compares two strings lexicographically, ignoring case differences.
Syntax
Here is the syntax of this method:
int compareToIgnoreCase(String str)
Parameters
Here is the detail of parameters:

str -- the String to be compared.
Return Value

This method returns a negative integer, zero, or a positive integer as the specified
String is greater than, equal to, or less than this String, ignoring case
considerations.
Example
public class Test {
public static void main(String args[]) {
String str1 = "Strings are immutable";
String str2 = "Strings are immutable";
String str3 = "Integers are not immutable";
145Java
int result = str1.compareToIgnoreCase( str2 );
System.out.println(result);
result = str2.compareToIgnoreCase( str3 );
System.out.println(result);
result = str3.compareToIgnoreCase( str1 );
System.out.println(result);
}
}
This will produce the following result:
0
10
-10
Java – String concat() Method
Description
This method appends one String to the end of another. The method returns a String with
the value of the String passed into the method, appended to the end of the String, used
to invoke this method.
Syntax
Here is the syntax of this method:
public String concat(String s)
Parameters
Here is the detail of parameters:

s -- the String that is concatenated to the end of this String.
Return Value

This methods returns a string that represents the concatenation of this object's
characters followed by the string argument's characters.
146Java
Example
public class Test {
public static void main(String args[]) {
String s = "Strings are immutable";
s = s.concat(" all the time");
System.out.println(s);
}
}
This will produce the following result:
Strings are immutable all the time
Java – String contentEquals() Method
Description
This method returns true if and only if this String represents the same sequence of
characters as specified in StringBuffer.
Syntax
Here is the syntax of this method:
public boolean contentEquals(StringBuffer sb)
Parameters
Here is the detail of parameters:

sb -- the StringBuffer to compare.
Return Value

This method returns true if and only if this String represents the same sequence
of characters as the specified in StringBuffer, otherwise false.
147Java
Example
public class Test {
public static void main(String args[]) {
String str1 = "Not immutable";
String str2 = "Strings are immutable";
StringBuffer str3 = new StringBuffer( "Not immutable");
boolean
result = str1.contentEquals( str3 );
System.out.println(result);
result = str2.contentEquals( str3 );
System.out.println(result);
}
}
This will produce the following result:
true
false
Java – String copyValueOf(char[] data) Method
Description
This method returns a String that represents the character sequence in the array specified.
Syntax
Here is the syntax of this method:
public static String copyValueOf(char[] data)
Parameters
Here is the detail of parameters:

data -- the character array.
Return Value

This method returns a String that contains the characters of the character array.
148Java
Example
public class Test {
public static void main(String args[]) {
char[] Str1 = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
String Str2 = "";
Str2 = Str2.copyValueOf( Str1 );
System.out.println("Returned String: " + Str2);
}
}
This will produce the following result:
Returned String: hello world
Java – String copyValueOf(char[] data, int offset, int count) Method
Description
This returns a String that represents the character sequence in the array specified.
Syntax
Here is the syntax of this method:
public static String copyValueOf(char[] data, int offset, int count)
Parameters
Here is the detail of parameters:
 data -- the character array.
 offset -- initial offset of the subarray.
 count -- length of the subarray.
Return Value

This method returns a String that contains the characters of the character array.
149Java
Example
public class Test {
public static void main(String args[]) {
char[] Str1 = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
String Str2 = "";
Str2 = Str2.copyValueOf( Str1, 2, 6 );
System.out.println("Returned String: " + Str2);
}
}
This will produce the following result:
Returned String: llo wo
Java – String endsWith() Method
Description
This method tests if this string ends with the specified suffix.
Syntax
Here is the syntax of this method:
public boolean endsWith(String suffix)
Parameters
Here is the detail of parameters:

suffix -- the suffix.
Return Value

This method returns true if the character sequence represented by the argument
is a suffix of the character sequence represented by this object; false otherwise.
Note that the result will be true if the argument is the empty string or is equal to
this String object as determined by the equals(Object) method.
150Java
Example
public class Test{
public static void main(String args[]){
String Str = new String("This is really not immutable!!");
boolean retVal;
retVal = Str.endsWith( "immutable!!" );
System.out.println("Returned Value = " + retVal );
retVal = Str.endsWith( "immu" );
System.out.println("Returned Value = " + retVal );
}
}
This will produce the following result:
Returned Value = true
Returned Value = false
Java – String equals() Method
Description
This method compares this string to the specified object. The result is true if and only if
the argument is not null and is a String object that represents the same sequence of
characters as this object.
Syntax
Here is the syntax of this method:
public boolean equals(Object anObject)
Parameters
Here is the detail of parameters:

anObject -- the object to compare this String against.
151Java
Return Value

This method returns true if the String are equal; false otherwise.
Example
public class Test {
public static void main(String args[]) {
String Str1 = new String("This is really not immutable!!");
String Str2 = Str1;
String Str3 = new String("This is really not immutable!!");
boolean retVal;
retVal = Str1.equals( Str2 );
System.out.println("Returned Value = " + retVal );
retVal = Str1.equals( Str3 );
System.out.println("Returned Value = " + retVal );
}
}
This will produce the following result:
Returned Value = true
Returned Value = true
Java – String equalsIgnoreCase() Method
Description
This method compares this String to another String, ignoring case considerations. Two
strings are considered equal ignoring case, if they are of the same length, and
corresponding characters in the two strings are equal ignoring case.
Syntax
Here is the syntax of this method:
public boolean equalsIgnoreCase(String anotherString)
152Java
Parameters
Here is the detail of parameters:

anotherString -- the String to compare this String against
Return Value

This method returns true if the argument is not null and the Strings are equal,
ignoring case; false otherwise.
Example
public class Test {
public static void main(String args[]) {
String Str1 = new String("This is really not immutable!!");
String Str2 = Str1;
String Str3 = new String("This is really not immutable!!");
String Str4 = new String("This IS REALLY NOT IMMUTABLE!!");
boolean retVal;
retVal = Str1.equals( Str2 );
System.out.println("Returned Value = " + retVal );
retVal = Str1.equals( Str3 );
System.out.println("Returned Value = " + retVal );
retVal = Str1.equalsIgnoreCase( Str4 );
System.out.println("Returned Value = " + retVal );
}
}
This will produce the following result:
Returned Value = true
Returned Value = true
Returned Value = true
153Java
Java – String getBytes(String charsetName) Method
This method encodes this String into a sequence of bytes using the named charset, storing
the result into a new byte array.
Syntax
Here is the syntax of this method:
public byte[] getBytes(String charsetName) throws UnsupportedEncodingException
Parameters
Here is the detail of parameters:

charsetName -- the name of a supported charset.
Return Value

This method returns the resultant byte array.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
try{
Str2 = Str1.getBytes( "UTF-8" );
System.out.println("Returned
Value " + Str2 );
Str2 = Str1.getBytes( "ISO-8859-1" );
System.out.println("Returned
Value " + Str2 );
}catch( UnsupportedEncodingException e){
System.out.println("Unsupported character set");
}
}
}
154Java
This will produce the following result:
Returned Value [B@15ff48b
Returned Value [B@1b90b39
Java – String getBytes() Method
Description
This method encodes this String into a sequence of bytes using the platform's default
charset, storing the result into a new byte array.
Syntax
Here is the syntax of this method:
public byte[] getBytes()
Return Value

This method returns the resultant byte array.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
try{
byte[] Str2 = Str1.getBytes();
System.out.println("Returned
Value " + Str2 );
}catch( UnsupportedEncodingException e){
System.out.println("Unsupported character set");
}
}
}
This will produce the following result:
Returned
Value [B@192d342
155Java
Java – String getChars() Method
Description
This method copies characters from this string into the destination character array.
Syntax
Here is the syntax of this method:
public void getChars(int srcBegin, int srcEnd, char[] dst,
int dstBegin)
Parameters
Here is the detail of parameters:
 srcBegin -- index of the first character in the string to copy.
 srcEnd -- index after the last character in the string to copy.
 dst -- the destination array.
 dstBegin -- the start offset in the destination array.
Return Value

It does not return any value but throws IndexOutOfBoundsException.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
char[] Str2 = new char[7];
try{
Str1.getChars(2, 9, Str2, 0);
System.out.print("Copied Value = " );
System.out.println(Str2 );
156Java
}catch( Exception ex){
System.out.println("Raised exception...");
}
}
}
This will produce the following result:
Copied Value = lcome t
Java – String hashCode() Method
Description
This method returns a hash code for this string. The hash code for a String object is
computed as:
s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
Using int arithmetic, where s[i] is the ith character of the string, n is the length of the
string, and ^ indicates exponentiation. (The hash value of the empty string is zero.)
Syntax
Here is the syntax of this method:
public int hashCode()
Parameters
Here is the detail of parameters:

This is a default method and this will not accept any parameters.
Return Value

This method returns a hash code value for this object.
157Java
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.println("Hashcode for Str :" + Str.hashCode() );
}
}
This will produce the following result:
Hashcode for Str :1186874997
Java – String indexOf(int ch) Method
Description
This method returns the index within this string of the first occurrence of the specified
character or -1, if the character does not occur.
Syntax
Here is the syntax of this method:
public int indexOf(int ch )
Parameters
Here is the detail of parameters:

ch -- a character.
Return Value

See the description.
158Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Found Index :" );
System.out.println(Str.indexOf( 'o' ));
}
}
This will produce the following result:
Found Index :4
Java – String indexOf(int ch, int fromIndex) Method
Description
This method returns the index within this string of the first occurrence of the specified
character, starting the search at the specified index or -1, if the character does not occur.
Syntax
Here is the syntax of this method:
public int indexOf(int ch, int fromIndex)
Parameters
Here is the detail of parameters:
 ch -- a character.
 fromIndex -- the index to start the search from.
Return Value

See the description.
159Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Found Index :" );
System.out.println(Str.indexOf( 'o', 5 ));
}
}
This will produce the following result:
Found Index :9
Java – String indexOf(String str) Method
Description
This method returns the index within this string of the first occurrence of the specified
substring. If it does not occur as a substring, -1 is returned.
Syntax
Here is the syntax of this method:
int indexOf(String str)
Parameters
Here is the detail of parameters:

str -- a string.
Return Value

See the description.
160Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
String SubStr1 = new String("Tutorials");
System.out.println( Str.indexOf( SubStr1 ));
}
}
This will produce the following result:
Found Index :11
Java – String indexOf(String str, int fromIndex) Method
This method returns the index within this string of the first occurrence of the specified
substring, starting at the specified index. If it does not occur, -1 is returned.
Syntax
Here is the syntax of this method:
int indexOf(String str, int fromIndex)
Parameters
Here is the detail of parameters:
 fromIndex -- the index to start the search from.
 str -- a string.
Return Value

See the description.
161Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
String SubStr1 = new String("Tutorials" );
System.out.print("Found Index :" );
System.out.println( Str.indexOf( SubStr1, 15 ));
}
}
This will produce the following result:
Found Index :-1
Java – String Intern() Method
Description
This method returns a canonical representation for the string object. It follows that for any
two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.
Syntax
Here is the syntax of this method:
public String intern()
Parameters
Here is the detail of parameters:

This is a default method and this do not accept any parameters.
Return Value

This method returns a canonical representation for the string object.
162Java
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
String Str2 = new String("WELCOME TO SUTORIALSPOINT.COM");
System.out.print("Canonical representation:" );
System.out.println(Str1.intern());
System.out.print("Canonical representation:" );
System.out.println(Str2.intern());
}
}
This will produce the following result:
Canonical representation: Welcome to Tutorialspoint.com
Canonical representation: WELCOME TO SUTORIALSPOINT.COM
Java – String lastIndexOf(int ch) Method
Description
This method returns the index of the last occurrence of the character in the character
sequence represented by this object that is less than or equal to fromIndex, or -1 if the
character does not occur before that point.
Syntax
Here is the syntax of this method:
int lastIndexOf(int ch)
163Java
Parameters
Here is the detail of parameters:

ch -- a character.
Return Value

This method returns the index.
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Found Last Index :" );
System.out.println(Str.lastIndexOf( 'o' ));
}
}
This will produce the following result:
Found Last Index :27
Java – String lastIndexOf(int ch, int fromIndex) Method
Description
This method returns the index of the last occurrence of the character in the character
sequence represented by this object that is less than or equal to fromIndex, or -1 if the
character does not occur before that point.
Syntax
Here is the syntax of this method:
public int lastIndexOf(int ch, int fromIndex)
Parameters
Here is the detail of parameters:

ch -- a character.
164Java

fromIndex -- the index to start the search from.
Return Value

This method returns the index.
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Found Last Index :" );
System.out.println(Str.lastIndexOf( 'o', 5 ));
}
}
This will produce the following result:
Found Last Index :4
Java – String lastIndexOf(String str) Method
Description
This method accepts a String as an argument, if the string argument occurs one or more
times as a substring within this object, then it returns the index of the first character of
the last such substring is returned. If it does not occur as a substring, -1 is returned.
Syntax
Here is the syntax of this method:
public int lastIndexOf(String str)
Parameters
Here is the detail of parameters:

str -- a string.
Return Value

This method returns the index.
165Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
String SubStr1 = new String("Tutorials" );
System.out.print("Found Last Index :" );
System.out.println( Str.lastIndexOf( SubStr1 ));
}
}
This will produce the following result:
Found Last Index :11
Java – String lastIndexOf(String str, int fromIndex) Method
Description
This method returns the index within this string of the last occurrence of the specified
substring, searching backward starting at the specified index.
Syntax
Here is the syntax of this method:
public int lastIndexOf(String str, int fromIndex)
Parameters
Here is the detail of parameters:
 fromIndex -- the index to start the search from.
 str -- a string.
Return Value

This method returns the index.
166Java
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
String SubStr1 = new String("Tutorials" );
System.out.print("Found Last Index :" );
System.out.println( Str.lastIndexOf( SubStr1, 15 ));
}
}
This will produce the following result:
Found Last Index :11
Java – String length() Method
Description
This method returns the length of this string. The length is equal to the number of 16-bit
Unicode characters in the string.
Syntax
Here is the syntax of this method:
public int length()
Parameters
Here is the detail of parameters:

NA
Return Value

This method returns the the length of the sequence of characters represented by
this object.
167Java
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
String Str2 = new String("Tutorials" );
System.out.print("String Length :" );
System.out.println(Str1.length());
System.out.print("String Length :" );
System.out.println(Str2.length());
}
}
This will produce the following result:
String Length :29
String Length :9
Java – String matches() Method
Description
This method tells whether or not this string matches the given regular expression. An
invocation of this method of the form str.matches(regex) yields exactly the same result
as the expression Pattern.matches(regex, str).
Syntax
Here is the syntax of this method:
public boolean matches(String regex)
Parameters
Here is the detail of parameters:

regex -- the regular expression to which this string is to be matched.
168Java
Return Value

This method returns true if, and only if, this string matches the given regular
expression.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.matches("(.*)Tutorials(.*)"));
System.out.print("Return Value :" );
System.out.println(Str.matches("Tutorials"));
System.out.print("Return Value :" );
System.out.println(Str.matches("Welcome(.*)"));
}
}
This will produce the following result:
Return Value :true
Return Value :false
Return Value :true
Java – String regionMatches() Method
Description
This method has two variants which can be used to test if two string regions are equal.
Syntax
Here is the syntax of this method:
public boolean regionMatches(int toffset,
String other,
int ooffset,
169Java
int len)
or
public boolean regionMatches(boolean ignoreCase,
int toffset,
String other,
int ooffset,
int len)
Parameters
Here is the detail of parameters:
 toffset -- the starting offset of the subregion in this string.
 other -- the string argument.
 ooffset -- the starting offset of the subregion in the string argument.
 len -- the number of characters to compare.
 ignoreCase -- if true, ignore case when comparing characters.
Return Value

It returns true if the specified subregion of this string matches the specified
subregion of the string argument; false otherwise. Whether the matching is exact
or case insensitive depends on the ignoreCase argument.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
String Str2 = new String("Tutorials");
String Str3 = new String("TUTORIALS");
System.out.print("Return Value :" );
System.out.println(Str1.regionMatches(11, Str2, 0, 9));
System.out.print("Return Value :" );
170Java
System.out.println(Str1.regionMatches(11, Str3, 0, 9));
System.out.print("Return Value :" );
System.out.println(Str1.regionMatches(true, 11, Str3, 0, 9));
}
}
This will produce the following result:
Return Value :true
Return Value :false
Return Value :true
Java – String regionMatches() Method
Description
This method has two variants which can be used to test if two string regions are equal.
Syntax
Here is the syntax of this method:
public boolean regionMatches(int toffset,
String other,
int ooffset,
int len)
or
public boolean regionMatches(boolean ignoreCase,
int toffset,
String other,
int ooffset,
int len)
171Java
Parameters
Here is the detail of parameters:
 toffset -- the starting offset of the subregion in this string.
 other -- the string argument.
 ooffset -- the starting offset of the subregion in the string argument.
 len -- the number of characters to compare.
 ignoreCase -- if true, ignore case when comparing characters.
Return Value

It returns true if the specified subregion of this string matches the specified
subregion of the string argument; false otherwise. Whether the matching is exact
or case insensitive depends on the ignoreCase argument.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str1 = new String("Welcome to Tutorialspoint.com");
String Str2 = new String("Tutorials");
String Str3 = new String("TUTORIALS");
System.out.print("Return Value :" );
System.out.println(Str1.regionMatches(11, Str2, 0, 9));
System.out.print("Return Value :" );
System.out.println(Str1.regionMatches(11, Str3, 0, 9));
System.out.print("Return Value :" );
System.out.println(Str1.regionMatches(true, 11, Str3, 0, 9));
}
}
This will produce the following result:
Return Value :true
Return Value :false
Return Value :true
172Java
Java – String replace() Method
Description
This method returns a new string resulting from replacing all occurrences of oldChar in
this string with newChar.
Syntax
Here is the syntax of this method:
public String replace(char oldChar, char newChar)
Parameters
Here is the detail of parameters:
 oldChar -- the old character.
 newChar -- the new character.
Return Value

It returns a string derived from this string by replacing every occurrence of oldChar
with newChar.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.replace('o', 'T'));
System.out.print("Return Value :" );
System.out.println(Str.replace('l', 'D'));
}
}
This will produce the following result:
Return Value :WelcTme tT TutTrialspTint.cTm
Return Value :WeDcome to TutoriaDspoint.com
173Java
Java – String replaceAll() Method
Description
This method replaces each substring of this string that matches the given regular
expression with the given replacement.
Syntax
Here is the syntax of this method:
public String replaceAll(String regex, String replacement)
Parameters
Here is the detail of parameters:
 regex -- the regular expression to which this string is to be matched.
 replacement -- the string which would replace found expression.
Return Value

This method returns the resulting String.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.replaceAll("(.*)Tutorials(.*)",
"AMROOD" ));
}
}
This will produce the following result:
Return Value :AMROOD
174Java
Java – String replaceFirst() Method
Description
This method replaces the first substring of this string that matches the given regular
expression with the given replacement.
Syntax
Here is the syntax of this method:
public String replaceFirst(String regex, String replacement)
Parameters
Here is the detail of parameters:


regex -- the regular expression to which this string is to be matched.
replacement -- the string which would replace found expression.
Return Value

This method returns a resulting String.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.replaceFirst("(.*)Tutorials(.*)",
"AMROOD" ));
System.out.print("Return Value :" );
System.out.println(Str.replaceFirst("Tutorials", "AMROOD" ));
}
}
This will produce the following result:
Return Value :AMROOD
Return Value :Welcome to AMROODpoint.com
175Java
Java – String split() Method
Description
This method has two variants and splits this string around matches of the given regular
expression.
Syntax
Here is the syntax of this method:
public String[] split(String regex, int limit)
or
public String[] split(String regex)
Parameters
Here is the detail of parameters:
 regex -- the delimiting regular expression.
 limit -- the result threshold, which means how many strings to be returned.
Return Value

It returns the array of strings computed by splitting this string around matches of
the given regular expression.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome-to-Tutorialspoint.com");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 2)){
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 3)){
176Java
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 0)){
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-")){
System.out.println(retval);
}
}
}
This will produce the following result:
Return Value :
Welcome
to-Tutorialspoint.com
Return Value :
Welcome
to
Tutorialspoint.com
Return Value:
Welcome
to
Tutorialspoint.com
Return Value :
Welcome
to
Tutorialspoint.com
177Java
Java – String split() Method
Description
This method has two variants and splits this string around matches of the given regular
expression.
Syntax
Here is the syntax of this method:
public String[] split(String regex, int limit)
or
public String[] split(String regex)
Parameters
Here is the detail of parameters:
 regex -- the delimiting regular expression.
 limit -- the result threshold which means how many strings to be returned.
Return Value

It returns the array of strings computed by splitting this string around matches of
the given regular expression.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome-to-Tutorialspoint.com");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 2)){
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 3)){
178Java
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-", 0)){
System.out.println(retval);
}
System.out.println("");
System.out.println("Return Value :" );
for (String retval: Str.split("-")){
System.out.println(retval);
}
}
}
This will produce the following result:
Return Value :
Welcome
to-Tutorialspoint.com
Return Value :
Welcome
to
Tutorialspoint.com
Return Value:
Welcome
to
Tutorialspoint.com
Return Value :
Welcome
to
Tutorialspoint.com
179Java
Java – String startsWith() Method
Description
This method has two variants and tests if a string starts with the specified prefix beginning
a specified index or by default at the beginning.
Syntax
Here is the syntax of this method:
public boolean startsWith(String prefix, int toffset)
or
public boolean startsWith(String prefix)
Parameters
Here is the detail of parameters:
 prefix -- the prefix to be matched.
 toffset -- where to begin looking in the string.
Return Value

It returns true if the character sequence represented by the argument is a prefix
of the character sequence represented by this string; false otherwise.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.startsWith("Welcome") );
System.out.print("Return Value :" );
System.out.println(Str.startsWith("Tutorials") );
System.out.print("Return Value :" );
180Java
System.out.println(Str.startsWith("Tutorials", 11) );
}
}
This will produce the following result:
Return Value :true
Return Value :false
Return Value :true
Java – String startsWith() Method
Description
This method has two variants and tests if a string starts with the specified prefix beginning
a specified index or by default at the beginning.
Syntax
Here is the syntax of this method:
public boolean startsWith(String prefix, int toffset)
or
public boolean startsWith(String prefix)
Parameters
Here is the detail of parameters:
 prefix -- the prefix to be matched.
 toffset -- where to begin looking in the string.
Return Value

It returns true if the character sequence represented by the argument is a prefix
of the character sequence represented by this string; false otherwise.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
181Java
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.startsWith("Welcome") );
System.out.print("Return Value :" );
System.out.println(Str.startsWith("Tutorials") );
System.out.print("Return Value :" );
System.out.println(Str.startsWith("Tutorials", 11) );
}
}
This will produce the following result:
Return Value :true
Return Value :false
Return Value :true
Java – String subsequence() Method
Description
This method returns a new character sequence that is a subsequence of this sequence.
Syntax
Here is the syntax of this method:
public CharSequence subSequence(int beginIndex, int endIndex)
Parameters
Here is the detail of parameters:
 beginIndex -- the begin index, inclusive.
 endIndex -- the end index, exclusive.
Return Value

This method returns the specified subsequence.
182Java
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.subSequence(0, 10) );
System.out.print("Return Value :" );
System.out.println(Str.subSequence(10, 15) );
}
}
This will produce the following result:
Return Value :Welcome to
Return Value : Tuto
Java – String substring() Method
Description
This method has two variants and returns a new string that is a substring of this string.
The substring begins with the character at the specified index and extends to the end of
this string or up to endIndex – 1, if the second argument is given.
Syntax
Here is the syntax of this method:
public String substring(int beginIndex)
or
public String substring(int beginIndex, int endIndex)
183Java
Parameters
Here is the detail of parameters:
 beginIndex -- the begin index, inclusive.
 endIndex -- the end index, exclusive.
Return Value

The specified substring.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.substring(10) );
System.out.print("Return Value :" );
System.out.println(Str.substring(10, 15) );
}
}
This will produce the following result:
Return Value : Tutorialspoint.com
Return Value : Tuto
Java – String substring() Method
Description
This method has two variants and returns a new string that is a substring of this string.
The substring begins with the character at the specified index and extends to the end of
this string or up to endIndex – 1, if the second argument is given.
184Java
Syntax
Here is the syntax of this method:
public String substring(int beginIndex)
or
public String substring(int beginIndex, int endIndex)
Parameters
Here is the detail of parameters:
 beginIndex -- the begin index, inclusive.
 endIndex -- the end index, exclusive.
Return Value

The specified substring.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.substring(10) );
System.out.print("Return Value :" );
System.out.println(Str.substring(10, 15) );
}
}
This will produce the following result:
Return Value : Tutorialspoint.com
Return Value : Tuto
185Java
Java – String toCharArray() Method
Description
This method converts this string to a new character array.
Syntax
Here is the syntax of this method:
public char[] toCharArray()
Parameters
Here is the detail of parameters:

NA
Return Value

It returns a newly allocated character array, whose length is the length of this string
and whose contents are initialized to contain the character sequence represented
by this string.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.toCharArray() );
}
}
This will produce the following result:
Return Value :Welcome to Tutorialspoint.com
186Java
Java – String toLowerCase() Method
Description
This method has two variants. The first variant converts all of the characters in this String
to lower case using the rules of the given Locale. This is equivalent to calling
toLowerCase(Locale.getDefault()).
The second variant takes locale as an argument to be used while converting into lower
case.
Syntax
Here is the syntax of this method:
public String toLowerCase()
or
public String toLowerCase(Locale locale)
Parameters
Here is the detail of parameters:

NA
Return Value

It returns the String, converted to lowercase.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :");
System.out.println(Str.toLowerCase());
}
}
This will produce the following result:
Return Value :welcome to tutorialspoint.com
187Java
Java – String toLowerCase() Method
Description
This method has two variants. The first variant converts all of the characters in this String
to lower case using the rules of the given Locale. This is equivalent to calling
toLowerCase(Locale.getDefault()).
The second variant takes locale as an argument to be used while converting into lower
case.
Syntax
Here is the syntax of this method:
public String toLowerCase()
or
public String toLowerCase(Locale locale)
Parameters
Here is the detail of parameters:

NA
Return Value

It returns the String, converted to lowercase.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :");
System.out.println(Str.toLowerCase());
}
}
This will produce the following result:
Return Value :welcome to tutorialspoint.com
188Java
Java – String toString() Method
Description
This method returns itself a string.
Syntax
Here is the syntax of this method:
public String toString()
Parameters
Here is the detail of parameters:

NA
Return Value

This method returns the string itself.
Example
import java.io.*;
public class Test {
public static void main(String args[]) {
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :");
System.out.println(Str.toString());
}
}
This will produce the following result:
Return Value :Welcome to Tutorialspoint.com
Java – String toUpperCase() Method
This method has two variants. The first variant converts all of the characters in this String
to upper case using the rules of the given Locale. This is equivalent to calling
toUpperCase(Locale.getDefault()).
The second variant takes locale as an argument to be used while converting into upper
case.
189Java
Syntax
Here is the syntax of this method:
public String toUpperCase()
or
public String toUpperCase(Locale locale)
Parameters
Here is the detail of parameters:

NA
Return Value

It returns the String, converted to uppercase.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.toUpperCase() );
}
}
This will produce the following result:
Return Value :WELCOME TO TUTORIALSPOINT.COM
Java – String toUpperCase() Method
This method has two variants. The first variant converts all of the characters in this String
to upper case using the rules of the given Locale. This is equivalent to calling
toUpperCase(Locale.getDefault()).
The second variant takes locale as an argument to be used while converting into upper
case.
190Java
Syntax
Here is the syntax of this method:
public String toUpperCase()
or
public String toUpperCase(Locale locale)
Parameters
Here is the detail of parameters:

NA
Return Value

It returns the String, converted to uppercase.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("Welcome to Tutorialspoint.com");
System.out.print("Return Value :" );
System.out.println(Str.toUpperCase() );
}
}
This produces the following result:
Return Value :WELCOME TO TUTORIALSPOINT.COM
Java – String trim() Method
Description
This method returns a copy of the string, with leading and trailing whitespace omitted.
191Java
Syntax
Here is the syntax of this method:
public String trim()
Parameters
Here is the detail of parameters:

NA
Return Value

It returns a copy of this string with leading and trailing white space removed, or
this string if it has no leading or trailing white space.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
String Str = new String("
Welcome to Tutorialspoint.com
");
System.out.print("Return Value :" );
System.out.println(Str.trim() );
}
}
This produces the following result:
Return Value :Welcome to Tutorialspoint.com
Java – String valueOf() Method
Description
This method has the following variants, which depend on the passed parameters. This
method returns the string representation of the passed argument.
 valueOf(boolean b): Returns the string representation of the boolean argument.
 valueOf(char c): Returns the string representation of the char argument.
 valueOf(char[] data): Returns the string representation of the char array
argument.
192Java
 valueOf(char[] data, int offset, int count): Returns the string representation
of a specific subarray of the char array argument.
 valueOf(double d): Returns the string representation of the double argument.
 valueOf(float f): Returns the string representation of the float argument.
 valueOf(int i): Returns the string representation of the int argument.
 valueOf(long l): Returns the string representation of the long argument.
 valueOf(Object obj): Returns the string representation of the Object argument.
Syntax
Here is the syntax of this method:
static String valueOf(boolean b)
or
static String valueOf(char c)
or
static String valueOf(char[] data)
or
static String valueOf(char[] data, int offset, int count)
or
static String valueOf(double d)
or
static String valueOf(float f)
or
static String valueOf(int i)
193Java
or
static String valueOf(long l)
or
static String valueOf(Object obj)
Parameters
Here is the detail of parameters:

See the description.
Return Value

This method returns the string representation.
Example
import java.io.*;
public class Test{
public static void main(String args[]){
double d = 102939939.939;
boolean b = true;
long l = 1232874;
char[] arr = {'a', 'b', 'c', 'd', 'e', 'f','g' };
System.out.println("Return Value : " + String.valueOf(d) );
System.out.println("Return Value : " + String.valueOf(b) );
System.out.println("Return Value : " + String.valueOf(l) );
System.out.println("Return Value : " + String.valueOf(arr) );
}
}
194Java
This will produce the following result:
Return Value : 1.02939939939E8
Return Value : true
Return Value : 1232874
Return Value : abcdefg
19514.
Java – Arrays
Java
Java provides a data structure, the array, which stores a fixed-size sequential collection
of elements of the same type. An array is used to store a collection of data, but it is often
more useful to think of an array as a collection of variables of the same type.
Instead of declaring individual variables, such as number0, number1, ..., and number99,
you declare one array variable such as numbers and use numbers[0], numbers[1], and
..., numbers[99] to represent individual variables.
This tutorial introduces how to declare array variables, create arrays, and process arrays
using indexed variables.
Declaring Array Variables
To use an array in a program, you must declare a variable to reference the array, and you
must specify the type of array the variable can reference. Here is the syntax for declaring
an array variable:
dataType[] arrayRefVar;
// preferred way.
or
dataType arrayRefVar[];
//
works but not preferred way.
Note: The
style dataType[]
arrayRefVar is
preferred.
The
style dataType
arrayRefVar[] comes from the C/C++ language and was adopted in Java to
accommodate C/C++ programmers.
Example
The following code snippets are examples of this syntax:
double[] myList;
// preferred way.
or
double myList[];
//
works but not preferred way.
Creating Arrays
You can create an array by using the new operator with the following syntax:
arrayRefVar = new dataType[arraySize];
196Java
The above statement does two things:
 It creates an array using new dataType[arraySize].
 It assigns the reference of the newly created array to the variable arrayRefVar.
Declaring an array variable, creating an array, and assigning the reference of the array to
the variable can be combined in one statement, as shown below:
dataType[] arrayRefVar = new dataType[arraySize];
Alternatively you can create arrays as follows:
dataType[] arrayRefVar = {value0, value1, ..., valuek};
The array elements are accessed through the index. Array indices are 0-based; that is,
they start from 0 to arrayRefVar.length-1.
Example
Following statement declares an array variable, myList, creates an array of 10 elements
of double type and assigns its reference to myList:
double[] myList = new double[10];
Following picture represents array myList. Here, myList holds ten double values and the
indices are from 0 to 9.
197Java
Processing Arrays
When processing array elements, we often use either for loop or foreach loop because
all of the elements in an array are of the same type and the size of the array is known.
Example
Here is a complete example showing how to create, initialize, and process arrays:
public class TestArray {
public static void main(String[] args) {
double[] myList = {1.9, 2.9, 3.4, 3.5};
// Print all the array elements
for (int i = 0; i < myList.length; i++) {
System.out.println(myList[i] + " ");
}
// Summing all elements
double total = 0;
for (int i = 0; i < myList.length; i++) {
total += myList[i];
}
System.out.println("Total is " + total);
// Finding the largest element
double max = myList[0];
for (int i = 1; i < myList.length; i++) {
if (myList[i] > max) max = myList[i];
}
System.out.println("Max is " + max);
}
}
This will produce the following result:
1.9
2.9
3.4
3.5
Total is 11.7
Max is 3.5
198Java
The foreach Loops
JDK 1.5 introduced a new for loop known as foreach loop or enhanced for loop, which
enables you to traverse the complete array sequentially without using an index variable.
Example
The following code displays all the elements in the array myList:
public class TestArray {
public static void main(String[] args) {
double[] myList = {1.9, 2.9, 3.4, 3.5};
// Print all the array elements
for (double element: myList) {
System.out.println(element);
}
}
}
This will produce the following result:
1.9
2.9
3.4
3.5
Passing Arrays to Methods
Just as you can pass primitive type values to methods, you can also pass arrays to
methods. For example, the following method displays the elements in an int array:
public static void printArray(int[] array) {
for (int i = 0; i < array.length; i++) {
System.out.print(array[i] + " ");
}
}
199Java
You can invoke it by passing an array. For example, the following statement invokes the
printArray method to display 3, 1, 2, 6, 4, and 2:
printArray(new int[]{3, 1, 2, 6, 4, 2});
Returning an Array from a Method
A method may also return an array. For example, the following method returns an array
that is the reversal of another array:
public static int[] reverse(int[] list) {
int[] result = new int[list.length];
for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
result[j] = list[i];
}
return result;
}
The Arrays Class
The java.util.Arrays class contains various static methods for sorting and searching arrays,
comparing arrays, and filling array elements. These methods are overloaded for all
primitive types.
Sr.
No.
Methods with Description
public static int binarySearch(Object[] a, Object key)
1
Searches the specified array of Object ( Byte, Int , double, etc.) for the specified
value using the binary search algorithm. The array must be sorted prior to
making this call. This returns index of the search key, if it is contained in the list;
otherwise, it returns ( – (insertion point + 1)).
public static boolean equals(long[] a, long[] a2)
2
Returns true if the two specified arrays of longs are equal to one another. Two
arrays are considered equal if both arrays contain the same number of elements,
and all corresponding pairs of elements in the two arrays are equal. This returns
true if the two arrays are equal. Same method could be used by all other primitive
data types (Byte, short, Int, etc.)
200Java
public static void fill(int[] a, int val)
3
Assigns the specified int value to each element of the specified array of ints. The
same method could be used by all other primitive data types (Byte, short, Int,
etc.)
public static void sort(Object[] a)
4
Sorts the specified array of objects into an ascending order, according to the
natural ordering of its elements. The same method could be used by all other
primitive data types ( Byte, short, Int, etc.)
20115.
Java – Date & Time
Java
Java provides the Date class available in java.util package, this class encapsulates the
current date and time.
The Date class supports two constructors as shown in the following table.
Sr.No.
Constructor and Description
Date( )
1
This constructor initializes the object with the current date and time.
Date(long millisec)
2
This constructor accepts an argument that equals the number of
milliseconds that have elapsed since midnight, January 1, 1970.
Following are the methods of the date class.
Sr.No.
1
Methods with Description
boolean after(Date date)
Returns true if the invoking Date object contains a date that is later than the
one specified by date, otherwise, it returns false.
boolean before(Date date)
2
3
4
Returns true if the invoking Date object contains a date that is earlier than the
one specified by date, otherwise, it returns false.
Object clone( )
Duplicates the invoking Date object.
int compareTo(Date date)
Compares the value of the invoking object with that of date. Returns 0 if the
values are equal. Returns a negative value if the invoking object is earlier than
date. Returns a positive value if the invoking object is later than date.
202Java
int compareTo(Object obj)
5
Operates identically to compareTo(Date) if obj is of class Date. Otherwise, it
throws a ClassCastException.
boolean equals(Object date)
6
7
8
Returns true if the invoking Date object contains the same time and date as
the one specified by date, otherwise, it returns false.
long getTime( )
Returns the number of milliseconds that have elapsed since January 1, 1970.
int hashCode( )
Returns a hash code for the invoking object.
void setTime(long time)
9
10
Sets the time and date as specified by time, which represents an elapsed time
in milliseconds from midnight, January 1, 1970
String toString( )
Converts the invoking Date object into a string and returns the result.
Getting Current Date & Time
This is a very easy method to get current date and time in Java. You can use a simple
Date object with toString() method to print the current date and time as follows:
import java.util.Date;
public class DateDemo {
public static void main(String args[]) {
// Instantiate a Date object
Date date = new Date();
// display time and date using toString()
System.out.println(date.toString());
}
}
203Java
This will produce the following result:
on May 04 09:51:52 CDT 2009
Date Comparison
Following are the three ways to compare two dates:
 You can use getTime( ) to obtain the number of milliseconds that have elapsed
since midnight, January 1, 1970, for both objects and then compare these two
values.
 You can use the methods before( ), after( ), and equals( ). Because the 12th of the
month comes before the 18th, for example, new Date(99, 2, 12).before(new Date
(99, 2, 18)) returns true.
 You can use the compareTo( ) method, which is defined by the Comparable
interface and implemented by Date.
Date Formatting Using SimpleDateFormat
SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive
manner. SimpleDateFormat allows you to start by choosing any user-defined patterns for
date-time formatting. For example:
import java.util.*;
import java.text.*;
public class DateDemo {
public static void main(String args[]) {
Date dNow = new Date( );
SimpleDateFormat ft =
new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz");
System.out.println("Current Date: " + ft.format(dNow));
}
}
This will produce the following result:
Current Date: Sun 2004.07.18 at 04:14:09 PM PDT
204Java
Simple DateFormat Format Codes
To specify the time format, use a time pattern string. In this pattern, all ASCII letters are
reserved as pattern letters, which are defined as the following:
Character Description Example
G Era designator AD
y Year in four digits 2001
M Month in year July or 07
d Day in month 10
h Hour in A.M./P.M. (1~12) 12
H Hour in day (0~23) 22
m Minute in hour 30
s Second in minute 55
S Millisecond 234
E Day in week Tuesday
D Day in year 360
F Day of week in month 2 (second Wed. in July)
w Week in year 40
W Week in month 1
a A.M./P.M. marker PM
k Hour in day (1~24) 24
K Hour in A.M./P.M. (0~11) 10
z Time zone Eastern Standard Time
' Escape for text Delimiter
" Single quote `
205Java
Date Formatting Using printf
Date and time formatting can be done very easily using printf method. You use a two-
letter format, starting with t and ending in one of the letters of the table as shown in the
following code. For example:
import java.util.Date;
public class DateDemo {
public static void main(String args[]) {
// Instantiate a Date object
Date date = new Date();
// display time and date using toString()
String str = String.format("Current Date/Time : %tc", date );
System.out.printf(str);
}
}
This will produce the following result:
Current Date/Time : Sat Dec 15 16:37:57 MST 2012
It would be a bit silly if you had to supply the date multiple times to format each part. For
that reason, a format string can indicate the index of the argument to be formatted.
The index must immediately follow the % and it must be terminated by a $. For example:
import java.util.Date;
public class DateDemo {
public static void main(String args[]) {
// Instantiate a Date object
Date date = new Date();
206Java
// display time and date using toString()
System.out.printf("%1$s %2$tB %2$td, %2$tY",
"Due date:", date);
}
}
This will produce the following result:
Due date: February 09, 2004
Alternatively, you can use the < flag. It indicates that the same argument as in the
preceding format specification should be used again. For example:
import java.util.Date;
public class DateDemo {
public static void main(String args[]) {
// Instantiate a Date object
Date date = new Date();
// display formatted date
System.out.printf("%s %tB %<te, %<tY",
"Due date:", date);
}
}
This will produce the following result:
Due date: February 09, 2004
207Java
Date and Time Conversion Characters
Character Description Example
c Complete date and time Mon May 04 09:51:52
CDT 2009
F ISO 8601 date 2004-02-09
D U.S. formatted date (month/day/year) 02/09/2004
T 24-hour time 18:05:19
r 12-hour time 06:05:19 pm
R 24-hour time, no seconds 18:05
Y Four-digit year (with leading zeroes) 2004
y Last two digits of the year (with leading
zeroes) 04
C First two digits of the year (with leading
zeroes) 20
B Full month name February
b Abbreviated month name Feb
m Two-digit month (with leading zeroes) 02
d Two-digit day (with leading zeroes) 03
e Two-digit day (without leading zeroes) 9
A Full weekday name Monday
a Abbreviated weekday name Mon
j Three-digit day of year (with leading
zeroes) 069
H Two-digit hour (with leading zeroes),
between 00 and 23 18
k Two-digit hour (without leading zeroes),
between 0 and 23 18
208Java
I Two-digit hour (with leading zeroes),
between 01 and 12 06
l Two-digit hour (without leading zeroes),
between 1 and 12 6
M Two-digit minutes (with leading zeroes) 05
S Two-digit seconds (with leading zeroes) 19
L Three-digit milliseconds (with leading
zeroes) 047
N Nine-digit nanoseconds (with leading
zeroes) 047000000
P Uppercase morning or afternoon marker PM
p Lowercase morning or afternoon marker pm
z RFC 822 numeric offset from GMT -0800
Z Time zone PST
s Seconds since 1970-01-01 00:00:00 GMT 1078884319
Q Milliseconds since 1970-01-01 00:00:00
GMT 1078884319047
There are other useful classes related to Date and time. For more details, you can refer to
Java Standard documentation.
Parsing Strings into Dates
The SimpleDateFormat class has some additional methods, notably parse( ), which tries
to parse a string according to the format stored in the given SimpleDateFormat object. For
example:
import java.util.*;
import java.text.*;
public class DateDemo {
public static void main(String args[]) {
SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd");
209Java
String input = args.length == 0 ? "1818-11-11" : args[0];
System.out.print(input + " Parses as ");
Date t;
try {
t = ft.parse(input);
System.out.println(t);
} catch (ParseException e) {
System.out.println("Unparseable using " + ft);
}
}
}
A sample run of the above program would produce the following result:
$ java DateDemo
1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818
$ java DateDemo 2007-12-01
2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007
Sleeping for a While
You can sleep for any period of time from one millisecond up to the lifetime of your
computer. For example, the following program would sleep for 10 seconds:
import java.util.*;
public class SleepDemo {
public static void main(String args[]) {
try {
System.out.println(new Date( ) + "\n");
Thread.sleep(5*60*10);
System.out.println(new Date( ) + "\n");
210Java
} catch (Exception e) {
System.out.println("Got an exception!");
}
}
}
This will produce the following result:
Sun May 03 18:04:41 GMT 2009
Sun May 03 18:04:51 GMT 2009
Measuring Elapsed Time
Sometimes, you may need to measure point in time in milliseconds. So let's re-write the
above example once again:
import java.util.*;
public class DiffDemo {
public static void main(String args[]) {
try {
long start = System.currentTimeMillis( );
System.out.println(new Date( ) + "\n");
Thread.sleep(5*60*10);
System.out.println(new Date( ) + "\n");
long end = System.currentTimeMillis( );
long diff = end - start;
System.out.println("Difference is : " + diff);
} catch (Exception e) {
System.out.println("Got an exception!");
}
}
}
211Java
This will produce the following result:
Sun May 03 18:16:51 GMT 2009
Sun May 03 18:16:57 GMT 2009
Difference is : 5993
GregorianCalendar Class
GregorianCalendar is a concrete implementation of a Calendar class that implements the
normal Gregorian calendar with which you are familiar. We did not discuss Calendar class
in this tutorial, you can look up standard Java documentation for this.
The getInstance( ) method of Calendar returns a GregorianCalendar initialized with the
current date and time in the default locale and time zone. GregorianCalendar defines two
fields: AD and BC. These represent the two eras defined by the Gregorian calendar.
There are also several constructors for GregorianCalendar objects:
Sr. No.
1
Constructor with Description
GregorianCalendar()
Constructs a default GregorianCalendar using the current time in the default
time zone with the default locale.
GregorianCalendar(int year, int month, int date)
2
Constructs a GregorianCalendar with the given date set in the default time
zone with the default locale.
GregorianCalendar(int year, int month, int date, int hour, int minute)
3
4
Constructs a GregorianCalendar with the given date and time set for the
default time zone with the default locale.
GregorianCalendar(int year, int month, int date, int hour, int minute,
int second)
Constructs a GregorianCalendar with the given date and time set for the
default time zone with the default locale.
212Java
GregorianCalendar(Locale aLocale)
5
Constructs a GregorianCalendar based on the current time in the default time
zone with the given locale.
GregorianCalendar(TimeZone zone)
6
Constructs a GregorianCalendar based on the current time in the given time
zone with the default locale.
GregorianCalendar(TimeZone zone, Locale aLocale)
7
Constructs a GregorianCalendar based on the current time in the given time
zone with the given locale.
Here is the list of few useful support methods provided by GregorianCalendar class:
Sr. No.
1
Methods with Description
void add(int field, int amount)
Adds the specified (signed) amount of time to the given time field, based
on the calendar's rules.
2
3
4
5
protected void computeFields()
Converts UTC as milliseconds to time field values.
protected void computeTime()
Overrides Calendar Converts time field values to UTC as milliseconds.
boolean equals(Object obj)
Compares this GregorianCalendar to an object reference.
int get(int field)
Gets the value for a given time field.
213Java
int getActualMaximum(int field)
6
Returns the maximum value that this field could have, given the current date.
7
int getActualMinimum(int field)
Returns the minimum value that this field could have, given the current date.
8
9
10
11
12
13
14
15
16
17
int getGreatestMinimum(int field)
Returns highest minimum value for the given field if varies.
Date getGregorianChange()
Gets the Gregorian Calendar change date.
int getLeastMaximum(int field)
Returns lowest maximum value for the given field if varies.
int getMaximum(int field)
Returns maximum value for the given field.
Date getTime()
Gets this Calendar's current time.
long getTimeInMillis()
Gets this Calendar's current time as a long.
TimeZone getTimeZone()
Gets the time zone.
int getMinimum(int field)
Returns minimum value for the given field.
int hashCode()
Overrides hashCode.
boolean isLeapYear(int year)
Determines if the given year is a leap year.
214Java
void roll(int field, boolean up)
18
19
20
Adds or subtracts (up/down) a single unit of time on the given time field without
changing larger fields.
void set(int field, int value)
Sets the time field with the given value.
void set(int year, int month, int date)
Sets the values for the fields year, month, and date.
21
22
23
24
25
26
27
void set(int year, int month, int date, int hour, int minute)
Sets the values for the fields year, month, date, hour, and minute.
void set(int year, int month, int date, int hour, int minute, int second)
Sets the values for the fields year, month, date, hour, minute, and second.
void setGregorianChange(Date date)
Sets the GregorianCalendar change date.
void setTime(Date date)
Sets this Calendar's current time with the given Date.
void setTimeInMillis(long millis)
Sets this Calendar's current time from the given long value.
void setTimeZone(TimeZone value)
Sets the time zone with the given time zone value.
String toString()
Returns a string representation of this calendar.
215Java
Example
import java.util.*;
public class GregorianCalendarDemo {
public static void main(String args[]) {
String months[] = {
"Jan", "Feb", "Mar", "Apr",
"May", "Jun", "Jul", "Aug",
"Sep", "Oct", "Nov", "Dec"};
int year;
// Create a Gregorian calendar initialized
// with the current date and time in the
// default locale and timezone.
GregorianCalendar gcalendar = new GregorianCalendar();
// Display current time and date information.
System.out.print("Date: ");
System.out.print(months[gcalendar.get(Calendar.MONTH)]);
System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");
System.out.println(year = gcalendar.get(Calendar.YEAR));
System.out.print("Time: ");
System.out.print(gcalendar.get(Calendar.HOUR) + ":");
System.out.print(gcalendar.get(Calendar.MINUTE) + ":");
System.out.println(gcalendar.get(Calendar.SECOND));
// Test if the current year is a leap year
if(gcalendar.isLeapYear(year)) {
System.out.println("The current year is a leap year");
}
else {
System.out.println("The current year is not a leap year");
}
}
}
216Java
This will produce the following result:
Date: Apr 22 2009
Time: 11:25:27
The current year is not a leap year
For a complete list of constant available in Calendar class, you can refer the standard Java
documentation.
21716.
Java – Regular Expressions
Java
Java provides the java.util.regex package for pattern matching with regular expressions.
Java regular expressions are very similar to the Perl programming language and very easy
to learn.
A regular expression is a special sequence of characters that helps you match or find other
strings or sets of strings, using a specialized syntax held in a pattern. They can be used
to search, edit, or manipulate text and data.
The java.util.regex package primarily consists of the following three classes:
 Pattern Class: A Pattern object is a compiled representation of a regular
expression. The Pattern class provides no public constructors. To create a pattern,
you must first invoke one of its public static compile() methods, which will then
return a Pattern object. These methods accept a regular expression as the first
argument.
 Matcher Class: A Matcher object is the engine that interprets the pattern and
performs match operations against an input string. Like the Pattern class, Matcher
defines no public constructors. You obtain a Matcher object by invoking
the matcher() method on a Pattern object.
 PatternSyntaxException: A PatternSyntaxException object is an unchecked
exception that indicates a syntax error in a regular expression pattern.
Capturing Groups
Capturing groups are a way to treat multiple characters as a single unit. They are created
by placing the characters to be grouped inside a set of parentheses. For example, the
regular expression (dog) creates a single group containing the letters "d", "o", and "g".
Capturing groups are numbered by counting their opening parentheses from the left to
the right. In the expression ((A)(B(C))), for example, there are four such groups:
 ((A)(B(C)))
 (A)
 (B(C))
 (C)
To find out how many groups are present in the expression, call the groupCount method
on a matcher object. The groupCount method returns an int showing the number of
capturing groups present in the matcher's pattern.
There is also a special group, group 0, which always represents the entire expression. This
group is not included in the total reported by groupCount.
218Java
Example
Following example illustrates how to find a digit string from the given alphanumeric string:
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexMatches
{
public static void main( String args[] ){
// String to be scanned to find the pattern.
String line = "This order was placed for QT3000! OK?";
String pattern = "(.*)(\\d+)(.*)";
// Create a Pattern object
Pattern r = Pattern.compile(pattern);
// Now create matcher object.
Matcher m = r.matcher(line);
if (m.find( )) {
System.out.println("Found value: " + m.group(0) );
System.out.println("Found value: " + m.group(1) );
System.out.println("Found value: " + m.group(2) );
} else {
System.out.println("NO MATCH");
}
}
}
This will produce the following result:
Found value: This order was placed for QT3000! OK?
Found value: This order was placed for QT300
Found value: 0
219Java
Regular Expression Syntax
Here is the table listing down all the regular expression metacharacter syntax available in
Java:
Subexpression
Matches
^
Matches the beginning of the line.
$
Matches the end of the line.
.
Matches any single character except newline. Using m option allows
it to match the newline as well.
[...]
Matches any single character in brackets.
[^...]
Matches any single character not in brackets.
\A
Beginning of the entire string.
\z
End of the entire string.
\Z
End of the entire string except allowable final line terminator.
re*
Matches 0 or more occurrences of the preceding expression.
re+
Matches 1 or more of the previous thing.
220Java
re?
Matches 0 or 1 occurrence of the preceding expression.
re{ n}
Matches exactly n number of occurrences of the preceding expression.
re{ n,}
Matches n or more occurrences of the preceding expression.
re{ n, m}
Matches at least n and at most m occurrences of the preceding
expression.
a| b
Matches either a or b.
(re)
Groups regular expressions and remembers the matched text.
(?: re)
Groups regular expressions without remembering the matched text.
(?> re)
Matches the independent pattern without backtracking.
\w
Matches the word characters.
\W
Matches the nonword characters.
\s
Matches the whitespace. Equivalent to [\t\n\r\f].
\S
Matches the nonwhitespace.
221Java
\d
Matches the digits. Equivalent to [0-9].
\D
Matches the nondigits.
\A
Matches the beginning of the string.
\Z
Matches the end of the string. If a newline exists, it matches just
before newline.
\z
Matches the end of the string.
\G
Matches the point where the last match finished.
\n
Back-reference to capture group number "n".
\b
Matches the word boundaries when outside the brackets. Matches the
backspace (0x08) when inside the brackets.
\B
Matches the nonword boundaries.
\n, \t, etc.
Matches newlines, carriage returns, tabs, etc.
\Q
Escape (quote) all characters up to \E.
\E
Ends quoting begun with \Q.
222Java
Methods of the Matcher Class
Here is a list of useful instance methods:
Index Methods
Index methods provide useful index values that show precisely where the match was found
in the input string:
Sr.
No.
1
Methods with Description
public int start()
Returns the start index of the previous match.
public int start(int group)
2
Returns the start index of the subsequence captured by the given group during
the previous match operation.
public int end()
3
Returns the offset after the last character matched.
public int end(int group)
4
Returns the offset after the last character of the subsequence captured by the
given group during the previous match operation.
Study Methods
Study methods review the input string and return a Boolean indicating whether or not the
pattern is found:
Sr.
No.
Methods with Description
public boolean lookingAt()
1
Attempts to match the input sequence, starting at the beginning of the region,
against the pattern.
public boolean find()
2
Attempts to find the next subsequence of the input sequence that matches the
pattern.
223Java
public boolean find(int start)
3
4
Resets this matcher and then attempts to find the next subsequence of the
input sequence that matches the pattern, starting at the specified index.
public boolean matches()
Attempts to match the entire region against the pattern.
Replacement Methods
Replacement methods are useful methods for replacing text in an input string:
Sr.
No.
1
Methods with Description
public Matcher appendReplacement(StringBuffer sb, String
replacement)
Implements a non-terminal append-and-replace step.
2
public StringBuffer appendTail(StringBuffer sb)
Implements a terminal append-and-replace step.
public String replaceAll(String replacement)
3
Replaces every subsequence of the input sequence that matches the pattern
with the given replacement string.
public String replaceFirst(String replacement)
4
Replaces the first subsequence of the input sequence that matches the pattern
with the given replacement string.
public static String quoteReplacement(String s)
5
Returns a literal replacement String for the specified String. This method
produces a String that will work as a literal replacement s in the
appendReplacement method of the Matcher class.
224Java
The start and end Methods
Following is the example that counts the number of times the word "cat" appears in the
input string:
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexMatches
{
private static final String REGEX = "\\bcat\\b";
private static final String INPUT =
"cat cat cat cattie cat";
public static void main( String args[] ){
Pattern p = Pattern.compile(REGEX);
Matcher m = p.matcher(INPUT); // get a matcher object
int count = 0;
while(m.find()) {
count++;
System.out.println("Match number "+count);
System.out.println("start(): "+m.start());
System.out.println("end(): "+m.end());
}
}
}
This will produce the following result:
Match number 1
start(): 0
end(): 3
Match number 2
start(): 4
end(): 7
225Java
Match number 3
start(): 8
end(): 11
Match number 4
start(): 19
end(): 22
You can see that this example uses word boundaries to ensure that the letters "c" "a" "t"
are not merely a substring in a longer word. It also gives some useful information about
where in the input string the match has occurred.
The start method returns the start index of the subsequence captured by the given group
during the previous match operation, and the end returns the index of the last character
matched, plus one.
The matches and lookingAt Methods
The matches and lookingAt methods both attempt to match an input sequence against a
pattern. The difference, however, is that matches requires the entire input sequence to be
matched, while lookingAt does not.
Both methods always start at the beginning of the input string. Here is the example
explaining the functionality:
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexMatches
{
private static final String REGEX = "foo";
private static final String INPUT = "fooooooooooooooooo";
private static Pattern pattern;
private static Matcher matcher;
public static void main( String args[] ){
pattern = Pattern.compile(REGEX);
matcher = pattern.matcher(INPUT);
System.out.println("Current REGEX is: "+REGEX);
System.out.println("Current INPUT is: "+INPUT);
226Java
System.out.println("lookingAt(): "+matcher.lookingAt());
System.out.println("matches(): "+matcher.matches());
}
}
This will produce the following result:
Current REGEX is: foo
Current INPUT is: fooooooooooooooooo
lookingAt(): true
matches(): false
The replaceFirst and replaceAll Methods
The replaceFirst and replaceAll methods replace the text that matches a given regular
expression. As their names indicate, replaceFirst replaces the first occurrence, and
replaceAll replaces all occurrences.
Here is the example explaining the functionality:
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexMatches
{
private static String REGEX = "dog";
private static String INPUT = "The dog says meow. " +
"All dogs say meow.";
private static String REPLACE = "cat";
public static void main(String[] args) {
Pattern p = Pattern.compile(REGEX);
// get a matcher object
Matcher m = p.matcher(INPUT);
INPUT = m.replaceAll(REPLACE);
System.out.println(INPUT);
}
}
227Java
This will produce the following result:
The cat says meow. All cats say meow.
The appendReplacement and appendTail Methods
The Matcher class also provides appendReplacement and appendTail methods for text
replacement.
Here is the example explaining the functionality:
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexMatches
{
private static String REGEX = "a*b";
private static String INPUT = "aabfooaabfooabfoob";
private static String REPLACE = "-";
public static void main(String[] args) {
Pattern p = Pattern.compile(REGEX);
// get a matcher object
Matcher m = p.matcher(INPUT);
StringBuffer sb = new StringBuffer();
while(m.find()){
m.appendReplacement(sb,REPLACE);
}
m.appendTail(sb);
System.out.println(sb.toString());
}
}
This will produce the following result:
-foo-foo-foo-
228Java
PatternSyntaxException Class Methods
A PatternSyntaxException is an unchecked exception that indicates a syntax error in a
regular expression pattern. The PatternSyntaxException class provides the following
methods to help you determine what went wrong:
Sr.
No.
1
Methods with Description
public String getDescription()
Retrieves the description of the error.
2
3
public int getIndex()
Retrieves the error index.
public String getPattern()
Retrieves the erroneous regular expression pattern.
public String getMessage()
4
Returns a multi-line string containing the description of the syntax error and its
index, the erroneous regular expression pattern, and a visual indication of the
error index within the pattern.
22917.
Java – Methods
Java
A Java method is a collection of statements that are grouped together to perform an
operation. When you call the System.out.println() method, for example, the system
actually executes several statements in order to display a message on the console.
Now you will learn how to create your own methods with or without return values, invoke
a method with or without parameters, and apply method abstraction in the program
design.
Creating Method
Considering the following example to explain the syntax of a method:
public static int methodName(int a, int b) {
// body
}
Here,
 public static: modifier
 int: return type
 methodName: name of the method
 a, b: formal parameters
 int a, int b: list of parameters
Method definition consists of a method header and a method body. The same is shown in
the following syntax:
modifier returnType nameOfMethod (Parameter List) {
// method body
}
The syntax shown above includes:
 modifier: It defines the access type of the method and it is optional to use.
 returnType: Method may return a value.
 nameOfMethod: This is the method name. The method signature consists of the
method name and the parameter list.
230Java
 Parameter List: The list of parameters, it is the type, order, and number of
parameters of a method. These are optional, method may contain zero parameters.
 method body: The method body defines what the method does with the
statements.
Example
Here is the source code of the above defined method called max(). This method takes
two parameters num1 and num2 and returns the maximum between the two:
/** the snippet returns the minimum between two numbers */
public static int minFunction(int n1, int n2) {
int min;
if (n1 > n2)
min = n2;
else
min = n1;
return min;
}
Method Calling
For using a method, it should be called. There are two ways in which a method is called
i.e., method returns a value or returning nothing (no return value).
The process of method calling is simple. When a program invokes a method, the program
control gets transferred to the called method. This called method then returns control to
the caller in two conditions, when:
 the return statement is executed.
 it reaches the method ending closing brace.
The methods returning void is considered as call to a statement. Lets consider an example:
System.out.println("This is tutorialspoint.com!");
The method returning value can be understood by the following example:
int result = sum(6, 9);
231Java
Example
Following is the example to demonstrate how to define a method and how to call it:
public class ExampleMinNumber{
public static void main(String[] args) {
int a = 11;
int b = 6;
int c = minFunction(a, b);
System.out.println("Minimum Value = " + c);
}
/** returns the minimum of two numbers */
public static int minFunction(int n1, int n2) {
int min;
if (n1 > n2)
min = n2;
else
min = n1;
return min;
}
}
This will produce the following result:
Minimum value = 6
The void Keyword
The void keyword allows us to create methods which do not return a value. Here, in the
following example we're considering a void method methodRankPoints. This method is a
void method, which does not return any value. Call to a void method must be a statement
i.e. methodRankPoints(255.7);. It is a Java statement which ends with a semicolon as
shown in the following example.
232Java
Example
public class ExampleVoid {
public static void main(String[] args) {
methodRankPoints(255.7);
}
public static void methodRankPoints(double points) {
if (points >= 202.5) {
System.out.println("Rank:A1");
}
else if (points >= 122.4) {
System.out.println("Rank:A2");
}
else {
System.out.println("Rank:A3");
}
}
}
This will produce the following result:
Rank:A1
Passing Parameters by Value
While working under calling process, arguments is to be passed. These should be in the
same order as their respective parameters in the method specification. Parameters can be
passed by value or by reference.
Passing Parameters by Value means calling a method with a parameter. Through this, the
argument value is passed to the parameter.
233Java
Example
The following program shows an example of passing parameter by value. The values of
the arguments remains the same even after the method invocation.
public class swappingExample {
public static void main(String[] args) {
int a = 30;
int b = 45;
System.out.println("Before swapping, a = " +
a + " and b = " + b);
// Invoke the swap method
swapFunction(a, b);
System.out.println("\n**Now, Before and After swapping values will be
same here**:");
System.out.println("After swapping, a = " +
a + " and b is " + b);
}
public static void swapFunction(int a, int b) {
System.out.println("Before swapping(Inside), a = " + a
+ " b = " + b);
// Swap n1 with n2
int c = a;
a = b;
b = c;
System.out.println("After swapping(Inside), a = " + a
+ " b = " + b);
}
}
234Java
This will produce the following result:
Before swapping, a = 30 and b = 45
Before swapping(Inside), a = 30 b = 45
After swapping(Inside), a = 45 b = 30
**Now, Before and After swapping values will be same here**:
After swapping, a = 30 and b is 45
Method Overloading
When a class has two or more methods by the same name but different parameters, it is
known as method overloading. It is different from overriding. In overriding, a method has
the same method name, type, number of parameters, etc.
Let’s consider the example discussed earlier for finding minimum numbers of integer type.
If, let’s say we want to find the minimum number of double type. Then the concept of
overloading will be introduced to create two or more methods with the same name but
different parameters.
The following example explains the same:
public class ExampleOverloading{
public static void main(String[] args) {
int a = 11;
int b = 6;
double c = 7.3;
double d = 9.4;
int result1 = minFunction(a, b);
// same function name with different parameters
double result2 = minFunction(c, d);
System.out.println("Minimum Value = " + result1);
System.out.println("Minimum Value = " + result2);
}
// for integer
public static int minFunction(int n1, int n2) {
int min;
if (n1 > n2)
min = n2;
else
235Java
min = n1;
return min;
}
// for double
public static double minFunction(double n1, double n2) {
double min;
if (n1 > n2)
min = n2;
else
min = n1;
return min;
}
}
This will produce the following result:
Minimum Value = 6
Minimum Value = 7.3
Overloading methods makes program readable. Here, two methods are given by the same
name but with different parameters. The minimum number from integer and double types
is the result.
Using Command-Line Arguments
Sometimes you will want to pass some information into a program when you run it. This
is accomplished by passing command-line arguments to main( ).
A command-line argument is the information that directly follows the program's name on
the command line when it is executed. To access the command-line arguments inside a
Java program is quite easy. They are stored as strings in the String array passed
to main( ).
236Java
Example
The following program displays all of the command-line arguments that it is called with:
public class CommandLine {
public static void main(String args[]){
for(int i=0; i<args.length; i++){
System.out.println("args[" + i + "]: " +
args[i]);
}
}
}
Try executing this program as shown here:
$java CommandLine this is a command line 200 -100
This will produce the following result:
args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
The Constructors
A constructor initializes an object when it is created. It has the same name as its class and
is syntactically similar to a method. However, constructors have no explicit return type.
Typically, you will use a constructor to give initial values to the instance variables defined
by the class, or to perform any other startup procedures required to create a fully formed
object.
All classes have constructors, whether you define one or not, because Java automatically
provides a default constructor that initializes all member variables to zero. However, once
you define your own constructor, the default constructor is no longer used.
237Java
Example
Here is a simple example that uses a constructor without parameters:
// A simple constructor.
class MyClass {
int x;
// Following is the constructor
MyClass() {
x = 10;
}
}
You will have to call constructor to initialize objects as follows:
public class ConsDemo {
public static void main(String args[]) {
MyClass t1 = new MyClass();
MyClass t2 = new MyClass();
System.out.println(t1.x + " " + t2.x);
}
}
Parameterized Constructor
Most often, you will need a constructor that accepts one or more parameters. Parameters
are added to a constructor in the same way that they are added to a method, just declare
them inside the parentheses after the constructor's name.
Example
Here is a simple example that uses a constructor with a parameter:
// A simple constructor.
class MyClass {
int x;
// Following is the constructor
MyClass(int i ) {
x = i;
238Java
}
}
You will need to call a constructor to initialize objects as follows:
public class ConsDemo {
public static void main(String args[]) {
MyClass t1 = new MyClass( 10 );
MyClass t2 = new MyClass( 20 );
System.out.println(t1.x + " " + t2.x);
}
}
This will produce the following result:
10 20
The this keyword
this is a keyword in Java which is used as a reference to the object of the current class,
with in an instance method or a constructor. Using this you can refer the members of a
class such as constructors, variables and methods.
Note: The keyword this is used only within instance methods or constructors
In general, the keyword this is used to :

Differentiate the instance variables from local variables if they have same names,
within a constructor or a method.
239Java
class Student{
int age;
Student(int age){
this.age=age;
}
}

Call one type of constructor (parametrized constructor or default) from other in a
class. It is known as explicit constructor invocation.
class Student{
int age
Student(){
this(20);
}
Student(int age){
this.age=age;
}
}
Example
Here is an example that uses this keyword to access the members of a class. Copy and
paste the following program in a file with the name, This_Example.java.
public class This_Example {
//Instance variable num
int num=10;
This_Example(){
System.out.println("This is an example program on keyword this ");
}
This_Example(int num){
//Invoking the default constructor
240Java
this();
//Assigning the local variable num to the instance variable num
this.num=num;
}
public void greet(){
System.out.println("Hi Welcome to Tutorialspoint");
}
public void print(){
//Local variable num
int num=20;
//Printing the instance variable
System.out.println("value of local variable num is : "+num);
//Printing the local variable
System.out.println("value of instance variable num is : "+this.num);
//Invoking the greet method of a class
this.greet();
}
public static void main(String[] args){
//Instantiating the class
This_Example obj1=new This_Example();
//Invoking the print method
obj1.print();
//Passing a new value to the num variable through parametrized constructor
This_Example obj2=new This_Example(30);
//Invoking the print method again
obj2.print();
}
}
This will produce the following result:
241Java
This is an example program on keyword this
value of local variable num is : 20
value of instance variable num is : 10
Hi Welcome to Tutorialspoint
This is an example program on keyword this
value of local variable num is : 20
value of instance variable num is : 30
Hi Welcome to Tutorialspoint
Variable Arguments(var-args)
JDK 1.5 enables you to pass a variable number of arguments of the same type to a method.
The parameter in the method is declared as follows:
typeName... parameterName
In the method declaration, you specify the type followed by an ellipsis (...). Only one
variable-length parameter may be specified in a method, and this parameter must be the
last parameter. Any regular parameters must precede it.
Example
public class VarargsDemo {
public static void main(String args[]) {
// Call method with variable args
printMax(34, 3, 3, 2, 56.5);
printMax(new double[]{1, 2, 3});
}
public static void printMax( double... numbers) {
if (numbers.length == 0) {
System.out.println("No argument passed");
return;
}
double result = numbers[0];
for (int i = 1; i <
if (numbers[i] >
numbers.length; i++)
result)
result = numbers[i];
242Java
System.out.println("The max value is " + result);
}
}
This will produce the following result:
The max value is 56.5
The max value is 3.0
The finalize( ) Method
It is possible to define a method that will be called just before an object's final destruction
by the garbage collector. This method is called finalize( ), and it can be used to ensure
that an object terminates cleanly.
For example, you might use finalize( ) to make sure that an open file owned by that object
is closed.
To add a finalizer to a class, you simply define the finalize( ) method. The Java runtime
calls that method whenever it is about to recycle an object of that class.
Inside the finalize( ) method, you will specify those actions that must be performed before
an object is destroyed.
The finalize( ) method has this general form:
protected void finalize( )
{
// finalization code here
}
Here, the keyword protected is a specifier that prevents access to finalize( ) by code
defined outside its class.
This means that you cannot know when or even if finalize( ) will be executed. For example,
if your program ends before garbage collection occurs, finalize( ) will not execute.
24318.
Java – Files and I/O
Java
The java.io package contains nearly every class you might ever need to perform input and
output (I/O) in Java. All these streams represent an input source and an output
destination. The stream in the java.io package supports many data such as primitives,
object, localized characters, etc.
Stream
A stream can be defined as a sequence of data. There are two kinds of Streams:
 InPutStream: The InputStream is used to read data from a source.
 OutPutStream: T he OutputStream is used for writing data to a destination.
Java provides strong but flexible support for I/O related to files and networks but this
tutorial covers very basic functionality related to streams and I/O. We will see the most
commonly used examples one by one:
Byte Streams
Java byte streams are used to perform input and output of 8-bit bytes. Though there are
many classes related to byte streams but the most frequently used classes
are, FileInputStream and FileOutputStream. Following is an example which makes use
of these two classes to copy an input file into an output file:
import java.io.*;
public class CopyFile {
public static void main(String args[]) throws IOException
{
FileInputStream in = null;
FileOutputStream out = null;
try {
in = new FileInputStream("input.txt");
244Java
out = new FileOutputStream("output.txt");
int c;
while ((c = in.read()) != -1) {
out.write(c);
}
}finally {
if (in != null) {
in.close();
}
if (out != null) {
out.close();
}
}
}
}
Now let's have a file input.txt with the following content:
This is test for copy file.
As a next step, compile the above program and execute it, which will result in creating
output.txt file with the same content as we have in input.txt. So let's put the above code
in CopyFile.java file and do the following:
$javac CopyFile.java
$java CopyFile
Character Streams
Java Byte streams are used to perform input and output of 8-bit bytes, whereas
Java Character streams are used to perform input and output for 16-bit unicode. Though
there are many classes related to character streams but the most frequently used classes
are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and
FileWriter uses FileOutputStream but here the major difference is that FileReader reads
two bytes at a time and FileWriter writes two bytes at a time.
245Java
We can re-write the above example, which makes the use of these two classes to copy an
input file (having unicode characters) into an output file:
import java.io.*;
public class CopyFile {
public static void main(String args[]) throws IOException
{
FileReader in = null;
FileWriter out = null;
try {
in = new FileReader("input.txt");
out = new FileWriter("output.txt");
int c;
while ((c = in.read()) != -1) {
out.write(c);
}
}finally {
if (in != null) {
in.close();
}
if (out != null) {
out.close();
}
}
}
}
Now let's have a file input.txt with the following content:
This is test for copy file.
As a next step, compile the above program and execute it, which will result in creating
output.txt file with the same content as we have in input.txt. So let's put the above code
in CopyFile.java file and do the following:
$javac CopyFile.java
$java CopyFile
246Java
Standard Streams
All the programming languages provide support for standard I/O where the user's program
can take input from a keyboard and then produce an output on the computer screen. If
you are aware of C or C++ programming languages, then you must be aware of three
standard devices STDIN, STDOUT and STDERR. Similarly, Java provides the following
three standard streams:
 Standard Input: This is used to feed the data to user's program and usually a
keyboard is used as standard input stream and represented as System.in.
 Standard Output: This is used to output the data produced by the user's program
and usually a computer screen is used for standard output stream and represented
as System.out.
 Standard Error: This is used to output the error data produced by the user's
program and usually a computer screen is used for standard error stream and
represented as System.err.
Following is a simple program, which creates InputStreamReader to read standard input
stream until the user types a "q":
import java.io.*;
public class ReadConsole {
public static void main(String args[]) throws IOException
{
InputStreamReader cin = null;
try {
cin = new InputStreamReader(System.in);
System.out.println("Enter characters, 'q' to quit.");
char c;
do {
c = (char) cin.read();
System.out.print(c);
} while(c != 'q');
}finally {
if (cin != null) {
cin.close();
}
}
}
}
247Java
Let's keep the above code in ReadConsole.java file and try to compile and execute it as
shown in the following program. This program continues to raed and output the same
character until we press 'q':
$javac ReadConsole.java
$java ReadConsole
Enter characters, 'q' to quit.
1
1
e
e
q
q
Reading and Writing Files
As described earlier, a stream can be defined as a sequence of data. The InputStream is
used to read data from a source and the OutputStream is used for writing data to a
destination.
Here is a hierarchy of classes to deal with Input and Output streams.
248Java
The two important streams are FileInputStream and FileOutputStream, which would
be discussed in this tutorial.
FileInputStream
This stream is used for reading data from the files. Objects can be created using the
keyword new and there are several types of constructors available.
Following constructor takes a file name as a string to create an input stream object to read
the file:
InputStream f = new FileInputStream("C:/java/hello");
Following constructor takes a file object to create an input stream object to read the file.
First we create a file object using File() method as follows:
File f = new File("C:/java/hello");
InputStream f = new FileInputStream(f);
Once you have InputStream object in hand, then there is a list of helper methods which
can be used to read to stream or to do other operations on the stream.
Sr.
No.
1
Methods with Description
public void close() throws IOException{}
This method closes the file output stream. Releases any system resources
associated with the file. Throws an IOException.
protected void finalize()throws IOException {}
2
This method cleans up the connection to the file. Ensures that the close
method of this file output stream is called when there are no more references
to this stream. Throws an IOException.
public int read(int r)throws IOException{}
3
This method reads the specified byte of data from the InputStream. Returns
an int. Returns the next byte of data and -1 will be returned if it's the end of
the file.
public int read(byte[] r) throws IOException{}
4
This method reads r.length bytes from the input stream into an array. Returns
the total number of bytes read. If it is the end of the file, -1 will be returned.
249Java
public int available() throws IOException{}
5
Gives the number of bytes that can be read from this file input stream.
Returns an int.
There are other important input streams available, for more detail you can refer to the
following links:


ByteArrayInputStream
DataInputStream
ByteArrayInputStream
The ByteArrayInputStream class allows a buffer in the memory to be used as an
InputStream. The input source is a byte array.
ByteArrayInputStream class provides the following constructors.
Sr.No
1
Constructor and Description
ByteArrayInputStream(byte [] a)
This constructor accepts a byte array as a parameter.
ByteArrayInputStream(byte [] a, int off, int len)
2
This constructor takes an array of bytes, and two integer values, where off is
the first byte to be read and len is the number of bytes to be read.
Once you have ByteArrayInputStream object in hand then there is a list of helper methods
which can be used to read the stream or to do other operations on the stream.
Sr.
No.
1
Methods with Description
public int read()
This method reads the next byte of data from the InputStream. Returns an
int as the next byte of data. If it is the end of the file, then it returns -1.
2
public int read(byte[] r, int off, int len)
250Java
This method reads upto len number of bytes starting from off from the input
stream into an array. Returns the total number of bytes read. If it is the end
of the file, -1 will be returned.
public int available()
3
Gives the number of bytes that can be read from this file input stream. Returns
an int that gives the number of bytes to be read.
public void mark(int read)
4
This sets the current marked position in the stream. The parameter gives the
maximum limit of bytes that can be read before the marked position becomes
invalid.
public long skip(long n)
5
Skips ‘n’ number of bytes from the stream. This returns the actual number of
bytes skipped.
Example
Following
is
the
example
ByteArrayOutputStream.
to
demonstrate
ByteArrayInputStream
and
import java.io.*;
public class ByteStreamTest {
public static void main(String args[])throws IOException {
ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12);
while( bOutput.size()!= 10 ) {
// Gets the inputs from the user
bOutput.write(System.in.read());
}
byte b [] = bOutput.toByteArray();
System.out.println("Print the content");
for(int x= 0 ; x < b.length; x++) {
// printing the characters
251Java
System.out.print((char)b[x]
+ "
");
}
System.out.println("
");
int c;
ByteArrayInputStream bInput = new ByteArrayInputStream(b);
System.out.println("Converting characters to Upper case " );
for(int y = 0 ; y < 1; y++ ) {
while(( c= bInput.read())!= -1) {
System.out.println(Character.toUpperCase((char)c));
}
bInput.reset();
}
}
}
Following is the sample run of the above program:
asdfghjkly
Print the content
a
s
d
f
g
h
j
k
l
y
Converting characters to Upper case
A
S
D
F
G
H
J
K
L
Y
252Java
DataInputStream
The DataInputStream is used in the context of DataOutputStream and can be used to read
primitives.
Following is the constructor to create an InputStream:
InputStream in = DataInputStream(InputStream in);
Once you have DataInputStream object in hand, then there is a list of helper methods,
which can be used to read the stream or to do other operations on the stream.
Sr.
No.
1
Methods with Description
public final int read(byte[] r, int off, int len)throws IOException
Reads up to len bytes of data from the input stream into an array of bytes.
Returns the total number of bytes read into the buffer otherwise -1 if it is end
of file.
Public final int read(byte [] b)throws IOException
2
3
Reads some bytes from the inputstream an stores in to the byte array. Returns
the total number of bytes read into the buffer otherwise -1 if it is end of file.
(a) public final Boolean readBooolean()throws IOException
(b) public final byte readByte()throws IOException
(c) public final short readShort()throws IOException
(d) public final Int readInt()throws IOException
These methods will read the bytes from the contained InputStream. Returns
the next two bytes of the InputStream as the specific primitive type.
public String readLine() throws IOException
4
Reads the next line of text from the input stream. It reads successive bytes,
converting each byte separately into a character, until it encounters a line
terminator or end of file; the characters read are then returned as a String.
253Java
Example
Following is an example to demonstrate DataInputStream and DataOutputStream. This
example reads 5 lines given in a file test.txt and converts those lines into capital letters
and finally copies them into another file test1.txt.
import java.io.*;
public class DataInput_Stream{
public static void main(String args[])throws IOException{
//writing string to a file encoded as modified UTF-8
DataOutputStream dataOut = new DataOutputStream(new
FileOutputStream("E:\\file.txt"));
dataOut.writeUTF("hello");
//Reading data from the same file
DataInputStream dataIn = new DataInputStream(new
FileInputStream("E:\\file.txt"));
while(dataIn.available()>0){
String k = dataIn.readUTF();
System.out.print(k+" ");
}
}
}
Following is the sample run of the above program:
hello
254Java
FileOutputStream
FileOutputStream is used to create a file and write data into it. The stream would create a
file, if it doesn't already exist, before opening it for output.
Here are two constructors which can be used to create a FileOutputStream object.
Following constructor takes a file name as a string to create an input stream object to
write the file:
OutputStream f = new FileOutputStream("C:/java/hello")
Following constructor takes a file object to create an output stream object to write the file.
First, we create a file object using File() method as follows:
File f = new File("C:/java/hello");
OutputStream f = new FileOutputStream(f);
Once you have OutputStream object in hand, then there is a list of helper methods, which
can be used to write to stream or to do other operations on the stream.
Sr. No.
1
Methods with Description
public void close() throws IOException{}
This method closes the file output stream. Releases any system resources
associated with the file. Throws an IOException.
protected void finalize()throws IOException {}
2
3
4
This method cleans up the connection to the file. Ensures that the close
method of this file output stream is called when there are no more references
to this stream. Throws an IOException.
public void write(int w)throws IOException{}
This methods writes the specified byte to the output stream.
public void write(byte[] w)
Writes w.length bytes from the mentioned byte array to the OutputStream.
255Java
There are other important output streams available, for more detail you can refer to the
following links:


ByteArrayOutputStream
DataOutputStream
ByteArrayOutputStream
The ByteArrayOutputStream class stream creates a buffer in memory and all the data sent
to the stream is stored in the buffer.
Following is the list of the constructors to be provided by ByteArrayOutputStream class.
Sr. No.
1
Constructors and Description
ByteArrayOutputStream()
This constructor creates a ByteArrayOutputStream having buffer of 32 byte
ByteArrayOutputStream(int a)
2
This constructor creates a ByteArrayOutputStream having buffer of the
given size
Once you have ByteArrayOutputStream object in hand, then there is a list of helper
methods which can be used to write the stream or to do other operations on the stream.
Sr. No.
1
Methods with Description
public void reset()
This method resets the number of valid bytes of the byte array output
stream to zero, so all the accumulated output in the stream will be
discarded.
public byte[] toByteArray()
2
This method creates a newly allocated Byte array. Its size would be the
current size of the output stream and the contents of the buffer will be
copied into it. Returns the current contents of the output stream as a byte
array.
256Java
public String toString()
3
Converts the buffer content into a string. Translation will be done according
to the default character encoding. Returns the String translated from the
buffer's content.
public void write(int w)
4
Writes the specified array to the output stream.
public void write(byte []b, int of, int len)
5
Writes len number of bytes starting from offset off to the stream.
public void writeTo(OutputStream outSt)
6
Writes the entire content of this Stream to the specified stream argument.
Example
Following
is
an
example
ByteArrayInputStream.
to
demonstrate
ByteArrayOutputStream
and
import java.io.*;
public class ByteStreamTest {
public static void main(String args[])throws IOException {
ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12);
while( bOutput.size()!= 10 ) {
// Gets the inputs from the user
bOutput.write(System.in.read());
}
byte b [] = bOutput.toByteArray();
System.out.println("Print the content");
for(int x= 0 ; x < b.length; x++) {
//printing the characters
System.out.print((char)b[x]
+ "
");
}
257Java
System.out.println("
");
int c;
ByteArrayInputStream bInput = new ByteArrayInputStream(b);
System.out.println("Converting characters to Upper case " );
for(int y = 0 ; y < 1; y++ ) {
while(( c= bInput.read())!= -1) {
System.out.println(Character.toUpperCase((char)c));
}
bInput.reset();
}
}
}
Here is the sample run of the above program:
asdfghjkly
Print the content
a
s
d
f
g
h
j
k
l
y
Converting characters to Upper case
A
S
D
F
G
H
J
K
L
Y
258Java
DataOutputStream
The DataOutputStream stream lets you write the primitives to an output source.
Following is the constructor to create a DataOutputStream.
DataOutputStream out = DataOutputStream(OutputStream
out);
Once you have DataOutputStream object in hand, then there is a list of helper methods,
which can be used to write the stream or to do other operations on the stream.
Sr.
No.
1
Methods with Description
public final void write(byte[] w, int off, int len)throws IOException
Writes len bytes from the specified byte array starting at point off, to the
underlying stream.
Public final int write(byte [] b)throws IOException
2
3
Writes the current number of bytes written to this data output stream. Returns
the total number of bytes written into the buffer.
(a) public final void writeBooolean()throws IOException,
(b) public final void writeByte()throws IOException,
(c) public final void writeShort()throws IOException
(d) public final void writeInt()throws IOException
These methods will write the specific primitive type data into the output stream
as bytes.
4
Public void flush()throws IOException
Flushes the data output stream.
public final void writeBytes(String s) throws IOException
5
Writes out the string to the underlying output stream as a sequence of bytes.
Each character in the string is written out, in sequence, by discarding its high
eight bits.
259Java
Example
Following is an example to demonstrate DataInputStream and DataOutputStream. This
example reads 5 lines given in a file test.txt and converts those lines into capital letters
and finally copies them into another file test1.txt.
import java.io.*;
public class DataInput_Stream{
public static void main(String args[])throws IOException{
//writing string to a file encoded as modified UTF-8
DataOutputStream dataOut = new DataOutputStream(new
FileOutputStream("E:\\file.txt"));
dataOut.writeUTF("hello");
//Reading data from the same file
DataInputStream dataIn = new DataInputStream(new
FileInputStream("E:\\file.txt"));
while(dataIn.available()>0){
String k = dataIn.readUTF();
System.out.print(k+" ");
}
}
}
Here is the sample run of the above program:
THIS IS TEST 1 ,
THIS IS TEST 2 ,
THIS IS TEST 3 ,
THIS IS TEST 4 ,
THIS IS TEST 5 ,
260Java
Example
Following is the example to demonstrate InputStream and OutputStream:
import java.io.*;
public class fileStreamTest{
public static void main(String args[]){
try{
byte bWrite [] = {11,21,3,40,5};
OutputStream os = new FileOutputStream("test.txt");
for(int x=0; x < bWrite.length ; x++){
os.write( bWrite[x] ); // writes the bytes
}
os.close();
InputStream is = new FileInputStream("test.txt");
int size = is.available();
for(int i=0; i< size; i++){
System.out.print((char)is.read() + "
");
}
is.close();
}catch(IOException e){
System.out.print("Exception");
}
}
}
The above code would create file test.txt and would write given numbers in binary format.
Same would be the output on the stdout screen.
File Navigation and I/O
There are several other classes that we would be going through to get to know the basics
of File Navigation and I/O.



File Class
FileReader Class
FileWriter Class
261Java
File Class
Java File class represents the files and directory pathnames in an abstract manner. This
class is used for creation of files and directories, file searching, file deletion, etc.
The File object represents the actual file/directory on the disk. Following is the list of
constructors to create a File object.
Sr. No.
1
Methods with Description
File(File parent, String child)
This constructor creates a new File instance from a parent abstract pathname
and a child pathname string.
File(String pathname)
2
This constructor creates a new File instance by converting the given
pathname string into an abstract pathname.
File(String parent, String child)
3
This constructor creates a new File instance from a parent pathname string
and a child pathname string.
File(URI uri)
4
This constructor creates a new File instance by converting the given file: URI
into an abstract pathname.
Once you have File object in hand, then there is a list of helper methods which can be
used to manipulate the files.
Sr. No.
Methods with Description
public String getName()
1
Returns the name of the file or directory denoted by this abstract pathname.
public String getParent()
2
Returns the pathname string of this abstract pathname's parent, or null if
this pathname does not name a parent directory.
262Java
public File getParentFile()
3
4
Returns the abstract pathname of this abstract pathname's parent, or null if
this pathname does not name a parent directory.
public String getPath()
Converts this abstract pathname into a pathname string.
public boolean isAbsolute()
5
Tests whether this abstract pathname is absolute. Returns true if this
abstract pathname is absolute, false otherwise.
public String getAbsolutePath()
6
Returns the absolute pathname string of this abstract pathname.
public boolean canRead()
7
Tests whether the application can read the file denoted by this abstract
pathname. Returns true if and only if the file specified by this abstract
pathname exists and can be read by the application; false otherwise.
public boolean canWrite()
8
Tests whether the application can modify to the file denoted by this abstract
pathname. Returns true if and only if the file system actually contains a file
denoted by this abstract pathname and the application is allowed to write to
the file; false otherwise.
public boolean exists()
9
Tests whether the file or directory denoted by this abstract pathname exists.
Returns true if and only if the file or directory denoted by this abstract
pathname exists; false otherwise.
public boolean isDirectory()
10
Tests whether the file denoted by this abstract pathname is a directory.
Returns true if and only if the file denoted by this abstract pathname exists
and is a directory; false otherwise.
263Java
public boolean isFile()
11
Tests whether the file denoted by this abstract pathname is a normal file. A
file is normal if it is not a directory and, in addition, satisfies other system-
dependent criteria. Any non-directory file created by a Java application is
guaranteed to be a normal file. Returns true if and only if the file denoted by
this abstract pathname exists and is a normal file; false otherwise.
public long lastModified()
12
Returns the time that the file denoted by this abstract pathname was last
modified. Returns a long value representing the time the file was last
modified, measured in milliseconds since the epoch (00:00:00 GMT, January
1, 1970), or 0L if the file does not exist or if an I/O error occurs.
public long length()
13
Returns the length of the file denoted by this abstract pathname. The return
value is unspecified if this pathname denotes a directory.
public boolean createNewFile() throws IOException
14
Atomically creates a new, empty file named by this abstract pathname if and
only if a file with this name does not yet exist. Returns true if the named file
does not exist and was successfully created; false if the named file already
exists.
public boolean delete()
15
Deletes the file or directory denoted by this abstract pathname. If this
pathname denotes a directory, then the directory must be empty in order to
be deleted. Returns true if and only if the file or directory is successfully
deleted; false otherwise.
public void deleteOnExit()
16
Requests that the file or directory denoted by this abstract pathname be
deleted when the virtual machine terminates.
public String[] list()
17
Returns an array of strings naming the files and directories in the directory
denoted by this abstract pathname.
264Java
public String[] list(FilenameFilter filter)
18
Returns an array of strings naming the files and directories in the directory
denoted by this abstract pathname that satisfy the specified filter.
public File[] listFiles()
20
Returns an array of abstract pathnames denoting the files in the directory
denoted by this abstract pathname.
public File[] listFiles(FileFilter filter)
21
Returns an array of abstract pathnames denoting the files and directories in
the directory denoted by this abstract pathname that satisfy the specified
filter.
public boolean mkdir()
22
Creates the directory named by this abstract pathname. Returns true if and
only if the directory was created; false otherwise.
public boolean mkdirs()
23
Creates the directory named by this abstract pathname, including any
necessary but nonexistent parent directories. Returns true if and only if the
directory was created, along with all necessary parent directories; false
otherwise.
public boolean renameTo(File dest)
24
Renames the file denoted by this abstract pathname. Returns true if and only
if the renaming succeeded; false otherwise.
public boolean setLastModified(long time)
25
Sets the last-modified time of the file or directory named by this abstract
pathname. Returns true if and only if the operation succeeded; false
otherwise.
public boolean setReadOnly()
26
Marks the file or directory named by this abstract pathname so that only read
operations are allowed. Returns true if and only if the operation succeeded;
false otherwise.
265Java
public static File createTempFile(String prefix, String suffix, File
directory) throws IOException
27
Creates a new empty file in the specified directory, using the given prefix
and suffix strings to generate its name. Returns an abstract pathname
denoting a newly-created empty file.
public static File createTempFile(String prefix, String suffix) throws
IOException
28
Creates an empty file in the default temporary-file directory, using the given
prefix and suffix to generate its name. Invoking this method is equivalent
to invoking createTempFile(prefix, suffix, null). Returns abstract pathname
denoting a newly-created empty file.
public int compareTo(File pathname)
29
Compares two abstract pathnames lexicographically. Returns zero if the
argument is equal to this abstract pathname, a value less than zero if this
abstract pathname is lexicographically less than the argument, or a value
greater than zero if this abstract pathname is lexicographically greater than
the argument.
public int compareTo(Object o)
30
Compares this abstract pathname to another object. Returns zero if the
argument is equal to this abstract pathname, a value less than zero if this
abstract pathname is lexicographically less than the argument, or a value
greater than zero if this abstract pathname is lexicographically greater than
the argument.
public boolean equals(Object obj)
31
Tests this abstract pathname for equality with the given object. Returns true
if and only if the argument is not null and is an abstract pathname that
denotes the same file or directory as this abstract pathname.
public String toString()
32
Returns the pathname string of this abstract pathname. This is just the
string returned by the getPath() method.
266Java
Example
Following is an example to demonstrate File object:
package com.tutorialspoint;
import java.io.File;
public class FileDemo {
public static void main(String[] args) {
File f = null;
String[] strs = {"test1.txt", "test2.txt"};
try{
// for each string in string array
for(String s:strs )
{
// create new file
f= new File(s);
// true if the file is executable
boolean bool = f.canExecute();
// find the absolute path
String a = f.getAbsolutePath();
// prints absolute path
System.out.print(a);
// prints
System.out.println(" is executable: "+ bool);
}
}catch(Exception e){
// if any I/O error occurs
e.printStackTrace();
}
}
}
267Java
Consider there is an executable file test1.txt and another file test2.txt is non executable
in the current directory. Let us compile and run the above program, this will produce the
following result:
test1.txt is executable: true
test2.txt is executable: false
FileReader Class
This class inherits from the InputStreamReader class. FileReader is used for reading
streams of characters.
This class has several constructors to create required objects. Following is the list of
constructors provided by the FileReader class.
Sr. No.
1
Constructors and Description
FileReader(File file)
This constructor creates a new FileReader, given the File to read from.
FileReader(FileDescriptor fd)
2
This constructor creates a new FileReader, given the FileDescriptor to read
from.
FileReader(String fileName)
3
This constructor creates a new FileReader, given the name of the file to
read from.
Once you have FileReader object in hand then there is a list of helper methods which can
be used to manipulate the files.
Sr. No.
Methods with Description
public int read() throws IOException
1
Reads a single character. Returns an int, which represents the character
read.
public int read(char [] c, int offset, int len)
2
Reads characters into an array. Returns the number of characters read.
268Java
Example
Following is an example to demonstrate class:
import java.io.*;
public class FileRead{
public static void main(String args[])throws IOException{
File file = new File("Hello1.txt");
// creates the file
file.createNewFile();
// creates a FileWriter Object
FileWriter writer = new FileWriter(file);
// Writes the content to the file
writer.write("This\n is\n an\n example\n");
writer.flush();
writer.close();
//Creates a FileReader Object
FileReader fr = new FileReader(file);
char [] a = new char[50];
fr.read(a); // reads the content to the array
for(char c : a)
System.out.print(c); //prints the characters one by one
fr.close();
}
}
This will produce the following result:
This
is
an
example
269Java
FileWriter Class
This class inherits from the OutputStreamWriter class. The class is used for writing streams
of characters.
This class has several constructors to create required objects. Following is a list.
Sr. No.
1
Constructors and Description
FileWriter(File file)
This constructor creates a FileWriter object given a File object.
FileWriter(File file, boolean append)
2
This constructor creates a FileWriter object given a File object with a boolean
indicating whether or not to append the data written.
FileWriter(FileDescriptor fd)
3
This constructor creates a FileWriter object associated with the given file
descriptor.
4
FileWriter(String fileName)
This constructor creates a FileWriter object, given a file name.
5
FileWriter(String fileName, boolean append)
This constructor creates a FileWriter object given a file name with a boolean
indicating whether or not to append the data written.
Once you have FileWriter object in hand, then there is a list of helper methods, which can
be used to manipulate the files.
Sr. No.
1
Methods with Description
public void write(int c) throws IOException
Writes a single character.
2
public void write(char [] c, int offset, int len)
270Java
Writes a portion of an array of characters starting from offset and with a
length of len.
public void write(String s, int offset, int len)
3
Write a portion of a String starting from offset and with a length of len.
Example
Following is an example to demonstrate class:
import java.io.*;
public class FileRead{
public static void main(String args[])throws IOException{
File file = new File("Hello1.txt");
// creates the file
file.createNewFile();
// creates a FileWriter Object
FileWriter writer = new FileWriter(file);
// Writes the content to the file
writer.write("This\n is\n an\n example\n");
writer.flush();
writer.close();
//Creates a FileReader Object
FileReader fr = new FileReader(file);
char [] a = new char[50];
fr.read(a); // reads the content to the array
for(char c : a)
System.out.print(c); //prints the characters one by one
fr.close();
}
}
271Java
This will produce the following result:
This
is
an
example
Directories in Java
A directory is a File which can contain a list of other files and directories. You
use File object to create directories, to list down files available in a directory. For complete
detail, check a list of all the methods which you can call on File object and what are related
to directories.
Creating Directories
There are two useful File utility methods, which can be used to create directories:
 The mkdir( ) method creates a directory, returning true on success and false on
failure. Failure indicates that the path specified in the File object already exists, or
that the directory cannot be created because the entire path does not exist yet.
 The mkdirs() method creates both a directory and all the parents of the directory.
Following example creates "/tmp/user/java/bin" directory:
import java.io.File;
public class CreateDir {
public static void main(String args[]) {
String dirname = "/tmp/user/java/bin";
File d = new File(dirname);
// Create directory now.
d.mkdirs();
}
}
Compile and execute the above code to create "/tmp/user/java/bin".
Note: Java automatically takes care of path separators on UNIX and Windows as per
conventions. If you use a forward slash (/) on a Windows version of Java, the path will still
resolve correctly.
272Java
Listing Directories
You can use list( ) method provided by File object to list down all the files and directories
available in a directory as follows:
import java.io.File;
public class ReadDir {
public static void main(String[] args) {
File file = null;
String[] paths;
try{
// create new file object
file = new File("/tmp");
// array of files and directory
paths = file.list();
// for each name in the path array
for(String path:paths)
{
// prints filename and directory name
System.out.println(path);
}
}catch(Exception e){
// if any error occurs
e.printStackTrace();
}
}
}
This will produce the following result based on the directories and files available in
your /tmp directory:
test1.txt
test2.txt
ReadDir.java
ReadDir.class
27319.
Java – Exceptions
Java
An exception (or exceptional event) is a problem that arises during the execution of a
program. When an Exception occurs the normal flow of the program is disrupted and the
program/Application terminates abnormally, which is not recommended, therefore, these
exceptions are to be handled.
An exception can occur for many different reasons. Following are some scenarios where
an exception occurs.
 A user has entered an invalid data.
 A file that needs to be opened cannot be found.
 A network connection has been lost in the middle of communications or the
JVM has run out of memory.
Some of these exceptions are caused by user error, others by programmer error, and
others by physical resources that have failed in some manner.
Based on these, we have three categories of Exceptions. You need to understand them to
know how exception handling works in Java.

Checked exceptions: A checked exception is an exception that occurs at the
compile time, these are also called as compile time exceptions. These exceptions
cannot simply be ignored at the time of compilation, the programmer should take
care of (handle) these exceptions.
For example, if you use FileReader class in your program to read data from a file, if the
file specified in its constructor doesn't exist, then a FileNotFoundException occurs, and the
compiler prompts the programmer to handle the exception.
import java.io.File;
import java.io.FileReader;
public class FilenotFound_Demo {
public static void main(String args[]){
File file=new File("E://file.txt");
FileReader fr = new FileReader(file);
}
}
274Java
If you try to compile the above program, you will get the following exceptions.
C:\>javac FilenotFound_Demo.java
FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException;
must be caught or declared to be thrown
FileReader fr = new FileReader(file);
^
1 error
Note: Since the methods read() and close() of FileReader class throws IOException, you
can observe that the compiler notifies to handle IOException, along with
FileNotFoundException.

Unchecked exceptions: An unchecked exception is an exception that occurs at
the time of execution. These are also called as Runtime Exceptions. These include
programming bugs, such as logic errors or improper use of an API. Runtime
exceptions are ignored at the time of compilation.
For example, if you have declared an array of size 5 in your program, and trying to call
the 6th element of the array then an ArrayIndexOutOfBoundsExceptionexception occurs.
public class Unchecked_Demo {
public static void main(String args[]){
int num[]={1,2,3,4};
System.out.println(num[5]);
}
}
If you compile and execute the above program, you will get the following exception.
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)

Errors: These are not exceptions at all, but problems that arise beyond the control
of the user or the programmer. Errors are typically ignored in your code because
you can rarely do anything about an error. For example, if a stack overflow occurs,
an error will arise. They are also ignored at the time of compilation.
Exception Hierarchy
All exception classes are subtypes of the java.lang.Exception class. The exception class is
a subclass of the Throwable class. Other than the exception class there is another subclass
called Error which is derived from the Throwable class.
Errors are abnormal conditions that happen in case of severe failures, these are not
handled by the Java programs. Errors are generated to indicate errors generated by the
275Java
runtime environment. Example: JVM is out of memory. Normally, programs cannot recover
from errors.
The Exception class has two main subclasses: IOException class and RuntimeException
Class.
Following is a list of most common checked and unchecked Java's Built-in Exceptions.
Built-in Exceptions
Java defines several exception classes inside the standard package java.lang.
The most general of these exceptions are subclasses of the standard type
RuntimeException. Since java.lang is implicitly imported into all Java programs, most
exceptions derived from RuntimeException are automatically available.
Java defines several other types of exceptions that relate to its various class libraries.
Following is the list of Java Unchecked RuntimeException.
Exception
Description
ArithmeticException Arithmetic error, such as divide-by-zero.
ArrayIndexOutOfBoundsException Array index is out-of-bounds.
ArrayStoreException Assignment to an array element of an incompatible
type.
ClassCastException Invalid cast.
IllegalArgumentException Illegal argument used to invoke a method.
276Java
IllegalMonitorStateException Illegal monitor operation, such as waiting on an
unlocked thread.
IllegalStateException Environment or application is in incorrect state.
IllegalThreadStateException Requested operation not compatible with the
current thread state.
IndexOutOfBoundsException Some type of index is out-of-bounds.
NegativeArraySizeException Array created with a negative size.
NullPointerException Invalid use of a null reference.
NumberFormatException Invalid conversion of a string to a numeric format.
SecurityException Attempt to violate security.
StringIndexOutOfBounds Attempt to index outside the bounds of a string.
UnsupportedOperationException An unsupported operation was encountered.
Following is the list of Java Checked Exceptions Defined in java.lang.
Exception
Description
ClassNotFoundException Class not found.
CloneNotSupportedException Attempt to clone an object that does not implement the
Cloneable interface.
IllegalAccessException Access to a class is denied.
InstantiationException Attempt to create an object of an abstract class or
interface.
InterruptedException One thread has been interrupted by another thread.
NoSuchFieldException A requested field does not exist.
NoSuchMethodException A requested method does not exist.
277Java
Exceptions Methods
Following is the list of important methods available in the Throwable class.
Sr.
No.
1
Methods with Description
public String getMessage()
Returns a detailed message about the exception that has occurred. This message
is initialized in the Throwable constructor.
2
3
public Throwable getCause()
Returns the cause of the exception as represented by a Throwable object.
public String toString()
Returns the name of the class concatenated with the result of getMessage().
public void printStackTrace()
4
Prints the result of toString() along with the stack trace to System.err, the error
output stream.
public StackTraceElement [] getStackTrace()
5
Returns an array containing each element on the stack trace. The element at
index 0 represents the top of the call stack, and the last element in the array
represents the method at the bottom of the call stack.
public Throwable fillInStackTrace()
6
Fills the stack trace of this Throwable object with the current stack trace, adding
to any previous information in the stack trace.
278Java
Catching Exceptions
A method catches an exception using a combination of the try and catch keywords. A
try/catch block is placed around the code that might generate an exception. Code within
a try/catch block is referred to as protected code, and the syntax for using try/catch looks
like the following:
try
{
//Protected code
}catch(ExceptionName e1)
{
//Catch block
}
The code which is prone to exceptions is placed in the try block. When an exception occurs,
that exception occurred is handled by catch block associated with it. Every try block should
be immediately followed either by a catch block or finally block.
A catch statement involves declaring the type of exception you are trying to catch. If an
exception occurs in protected code, the catch block (or blocks) that follows the try is
checked. If the type of exception that occurred is listed in a catch block, the exception is
passed to the catch block much as an argument is passed into a method parameter.
Example
The following is an array declared with 2 elements. Then the code tries to access the 3rd
element of the array which throws an exception.
// File Name : ExcepTest.java
import java.io.*;
public class ExcepTest{
public static void main(String args[]){
try{
int a[] = new int[2];
System.out.println("Access element three :" + a[3]);
}catch(ArrayIndexOutOfBoundsException e){
System.out.println("Exception thrown
:" + e);
}
System.out.println("Out of the block");
}
}
279Java
This will produce the following result:
Exception thrown
:java.lang.ArrayIndexOutOfBoundsException: 3
Out of the block
Multiple Catch Blocks
A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks
looks like the following:
try
{
//Protected code
}catch(ExceptionType1 e1)
{
//Catch block
}catch(ExceptionType2 e2)
{
//Catch block
}catch(ExceptionType3 e3)
{
//Catch block
}
The previous statements demonstrate three catch blocks, but you can have any number
of them after a single try. If an exception occurs in the protected code, the exception is
thrown to the first catch block in the list. If the data type of the exception thrown matches
ExceptionType1, it gets caught there. If not, the exception passes down to the second
catch statement. This continues until the exception either is caught or falls through all
catches, in which case the current method stops execution and the exception is thrown
down to the previous method on the call stack.
Example
Here is code segment showing how to use multiple try/catch statements.
try
{
file = new FileInputStream(fileName);
x = (byte) file.read();
}catch(IOException i)
{
i.printStackTrace();
280Java
return -1;
}catch(FileNotFoundException f) //Not valid!
{
f.printStackTrace();
return -1;
}
Catching Multiple Type of Exceptions
Since Java 7, you can handle more than one exception using a single catch block, this
feature simplifies the code. Here is how you would do it:
catch (IOException|FileNotFoundException ex) {
logger.log(ex);
throw ex;
The Throws/Throw Keywords
If a method does not handle a checked exception, the method must declare it using
the throws keyword. The throws keyword appears at the end of a method's signature.
You can throw an exception, either a newly instantiated one or an exception that you just
caught, by using the throw keyword.
Try to understand the difference between throws and throw keywords, throws is used to
postpone the handling of a checked exception and throw is used to invoke an exception
explicitly.
The following method declares that it throws a RemoteException:
import java.io.*;
public class className
{
public void deposit(double amount) throws RemoteException
{
// Method implementation
throw new RemoteException();
}
//Remainder of class definition
}
281Java
A method can declare that it throws more than one exception, in which case the exceptions
are declared in a list separated by commas. For example, the following method declares
that it throws a RemoteException and an InsufficientFundsException:
import java.io.*;
public class className
{
public void withdraw(double amount) throws RemoteException,
InsufficientFundsException
{
// Method implementation
}
//Remainder of class definition
}
The Finally Block
The finally block follows a try block or a catch block. A finally block of code always
executes, irrespective of occurrence of an Exception.
Using a finally block allows you to run any cleanup-type statements that you want to
execute, no matter what happens in the protected code.
A finally block appears at the end of the catch blocks and has the following syntax:
try
{
//Protected code
}catch(ExceptionType1 e1)
{
//Catch block
}catch(ExceptionType2 e2)
{
//Catch block
}catch(ExceptionType3 e3)
{
//Catch block
}finally
{
//The finally block always executes.
}
282Java
Example
public class ExcepTest{
public static void main(String args[]){
int a[] = new int[2];
try{
System.out.println("Access element three :" + a[3]);
}catch(ArrayIndexOutOfBoundsException e){
System.out.println("Exception thrown
:" + e);
}
finally{
a[0] = 6;
System.out.println("First element value: " +a[0]);
System.out.println("The finally statement is executed");
}
}
}
This will produce the following result:
Exception thrown
:java.lang.ArrayIndexOutOfBoundsException: 3
First element value: 6
The finally statement is executed
Note the following:
 A catch clause cannot exist without a try statement.
 It is not compulsory to have finally clauses whenever a try/catch block is present.
 The try block cannot be present without either catch clause or finally clause.
 Any code cannot be present in between the try, catch, finally blocks.
283Java
The try-with-resources
Generally, when we use any resources like streams, connections, etc. we have to close
them explicitly using finally block. In the following program, we are reading data from a
file using FileReader and we are closing it using finally block.
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
public class ReadData_Demo {
public static void main(String args[]){
FileReader fr=null;
try{
File file=new File("file.txt");
fr = new FileReader(file);
char [] a = new char[50];
fr.read(a); // reads the content to the array
for(char c : a)
System.out.print(c); //prints the characters one by one
}catch(IOException e){
e.printStackTrace();
}
finally{
try{
fr.close();
}catch(IOException ex){
ex.printStackTrace();
}
}
}
}
try-with-resources, also referred as automatic resource management, is a new
exception handling mechanism that was introduced in Java 7, which automatically closes
the resources used within the try catch block.
To use this statement, you simply need to declare the required resources within the
parenthesis, and the created resource will be closed automatically at the end of the block.
Following is the syntax of try-with-resources statement.
284Java
try(FileReader fr=new FileReader("file path"))
{
//use the resource
}catch(){
//body of catch
}
}
Following is the program that reads the data in a file using try-with-resources statement.
import java.io.FileReader;
import java.io.IOException;
public class Try_withDemo {
public static void main(String args[]){
try(FileReader fr=new FileReader("E://file.txt")){
char [] a = new char[50];
fr.read(a); // reads the contentto the array
for(char c : a)
System.out.print(c); //prints the characters one by one
}catch(IOException e){
e.printStackTrace();
}
}
}
Following points are to be kept in mind while working with try-with-resources statement.
 To use a class with try-with-resources statement it should implement
AutoCloseable interface and the close() method of it gets invoked automatically
at runtime.
 You can declare more than one class in try-with-resources statement.
 While you declare multiple classes in the try block of try-with-resources statement
these classes are closed in reverse order.
 Except the deceleration of resources within the parenthesis everything is the same
as normal try/catch block of a try block.
285Java
 The resource declared in try gets instantiated just before the start of the try-block.
 The resource declared at the try block is implicitly declared as final.
User-defined Exceptions
You can create your own exceptions in Java. Keep the following points in mind when writing
your own exception classes:
 All exceptions must be a child of Throwable.
 If you want to write a checked exception that is automatically enforced by the
Handle or Declare Rule, you need to extend the Exception class.
 If you want to write a runtime exception, you need to extend the RuntimeException
class.
We can define our own Exception class as below:
class MyException extends Exception{
}
You just need to extend the predefined Exception class to create your own Exception.
These
are
considered
to
be
checked
exceptions.
The
following
InsufficientFundsException class is a user-defined exception that extends the
Exception class, making it a checked exception. An exception class is like any other class,
containing useful fields and methods.
Example
// File Name InsufficientFundsException.java
import java.io.*;
public class InsufficientFundsException extends Exception
{
private double amount;
public InsufficientFundsException(double amount)
{
this.amount = amount;
}
public double getAmount()
{
return amount;
}
}
286Java
To demonstrate using our user-defined exception, the following CheckingAccount class
contains a withdraw() method that throws an InsufficientFundsException.
// File Name CheckingAccount.java
import java.io.*;
public class CheckingAccount
{
private double balance;
private int number;
public CheckingAccount(int number)
{
this.number = number;
}
public void deposit(double amount)
{
balance += amount;
}
public void withdraw(double amount) throws InsufficientFundsException
{
if(amount <= balance)
{
balance -= amount;
}
else
{
double needs = amount - balance;
throw new InsufficientFundsException(needs);
}
}
public double getBalance()
{
return balance;
}
287Java
public int getNumber()
{
return number;
}
}
The following BankDemo program demonstrates invoking the deposit() and withdraw()
methods of CheckingAccount.
// File Name BankDemo.java
public class BankDemo
{
public static void main(String [] args)
{
CheckingAccount c = new CheckingAccount(101);
System.out.println("Depositing $500...");
c.deposit(500.00);
try
{
System.out.println("\nWithdrawing $100...");
c.withdraw(100.00);
System.out.println("\nWithdrawing $600...");
c.withdraw(600.00);
}catch(InsufficientFundsException e)
{
System.out.println("Sorry, but you are short $" + e.getAmount());
e.printStackTrace();
}
}
}
Compile all the above three files and run BankDemo. This will produce the following result:
Depositing $500...
Withdrawing $100...
Withdrawing $600...
288Java
Sorry, but you are short $200.0
InsufficientFundsException
at CheckingAccount.withdraw(CheckingAccount.java:25)
at BankDemo.main(BankDemo.java:13)
Common Exceptions
In Java, it is possible to define two catergories of Exceptions and Errors.
 JVM Exceptions: These are exceptions/errors that are exclusively or logically
thrown
by
the
JVM.
Examples:
NullPointerException,
ArrayIndexOutOfBoundsException, ClassCastException.
 Programmatic Exceptions: These exceptions are thrown explicitly by the
application or the API programmers. Examples: IllegalArgumentException,
IllegalStateException.
28920.
Java – Inner Classes
Java
In this chapter, we will discuss inner classes of Java.
Nested Classes
In Java, just like methods, variables of a class too can have another class as its member.
Writing a class within another is allowed in Java. The class written within is called
the nested class, and the class that holds the inner class is called the outer class.
Syntax
Following is the syntax to write a nested class. Here, the class Outer_Demo is the outer
class and the class Inner_Demo is the nested class.
class Outer_Demo{
class Nested_Demo{
}
}
Nested classes are divided into two types:
 Non-static nested classes: These are the non-static members of a class.
 Static nested classes: These are the static members of a class.
290Java
Inner Classes (Non-static Nested Classes)
Inner classes are a security mechanism in Java. We know a class cannot be associated
with the access modifier private, but if we have the class as a member of other class,
then the inner class can be made private. And this is also used to access the private
members of a class.
Inner classes are of three types depending on how and where you define them. They are:
 Inner Class
 Method-local Inner Class
 Anonymous Inner Class
Inner Class
Creating an inner class is quite simple. You just need to write a class within a class. Unlike
a class, an inner class can be private and once you declare an inner class private, it cannot
be accessed from an object outside the class.
Following is the program to create an inner class and access it. In the given example, we
make the inner class private and access the class through a method.
class Outer_Demo{
int num;
//inner class
private class Inner_Demo{
public void print(){
System.out.println("This is an inner class");
}
}
//Accessing he inner class from the method within
void display_Inner(){
Inner_Demo inner = new Inner_Demo();
inner.print();
}
}
public class My_class{
public static void main(String args[]){
//Instantiating the outer class
Outer_Demo outer = new Outer_Demo();
//Accessing the display_Inner() method.
outer.display_Inner();
291Java
}
}
Here you can observe that Outer_Demo is the outer class, Inner_Demo is the inner
class, display_Inner() is the method inside which we are instantiating the inner class,
and this method is invoked from the main method.
If you compile and execute the above program, you will get the following result.
This is an inner class.
Accessing the Private Members
As mentioned earlier, inner classes are also used to access the private members of a class.
Suppose, a class is having private members to access them. Write an inner class in it,
return the private members from a method within the inner class, say, getValue(), and
finally from another class (from which you want to access the private members) call the
getValue() method of the inner class.
To instantiate the inner class, initially you have to instantiate the outer class. Thereafter,
using the object of the outer class, following is the way in which you can instantiate the
inner class.
Outer_Demo outer=new Outer_Demo();
Outer_Demo.Inner_Demo inner=outer.new Inner_Demo();
The following program shows how to access the private members of a class using inner
class.
class Outer_Demo {
//private variable of the outer class
private int num= 175;
//inner class
public class Inner_Demo{
public int getNum(){
System.out.println("This is the getnum method of the inner class");
return num;
}
}
}
public class My_class2{
public static void main(String args[]){
//Instantiating the outer class
Outer_Demo outer=new Outer_Demo();
//Instantiating the inner class
292Java
Outer_Demo.Inner_Demo inner=outer.new Inner_Demo();
System.out.println(inner.getNum());
}
}
If you compile and execute the above program, you will get the following result.
The value of num in the class Test is: 175
Method-local Inner Class
In Java, we can write a class within a method and this will be a local type. Like local
variables, the scope of the inner class is restricted within the method.
A method-local inner class can be instantiated only within the method where the inner
class is defined. The following program shows how to use a method-local inner class.
public class Outerclass{
//instance method of the outer class
void my_Method(){
int num = 23;
//method-local inner class
class MethodInner_Demo{
public void print(){
System.out.println("This is method inner class "+num);
}
}//end of inner class
//Accessing the inner class
MethodInner_Demo inner = new MethodInner_Demo();
inner.print();
}
public static void main(String args[]){
Outerclass outer = new Outerclass();
outer.my_Method();
}
}
293Java
If you compile and execute the above program, you will get the following result.
This is method inner class 23
Anonymous Inner Class
An inner class declared without a class name is known as an anonymous inner class. In
case of anonymous inner classes, we declare and instantiate them at the same time.
Generally, they are used whenever you need to override the method of a class or an
interface. The syntax of an anonymous inner class is as follows:
AnonymousInner an_inner = new AnonymousInner(){
public void my_method(){
........
........
}
};
The following program shows how to override the method of a class using anonymous
inner class.
abstract class AnonymousInner{
public abstract void mymethod();
}
public class Outer_class {
public static void main(String args[]){
AnonymousInner inner = new AnonymousInner(){
public void mymethod(){
System.out.println("This is an example of anonymous inner class");
}
};
inner.mymethod();
}
}
If you compile and execute the above program, you will get the following result.
This is an example of anonymous inner class
In the same way, you can override the methods of the concrete class as well as the
interface using an anonymous inner class.
294Java
Anonymous Inner Class as Argument
Generally, if a method accepts an object of an interface, an abstract class, or a concrete
class, then we can implement the interface, extend the abstract class, and pass the object
to the method. If it is a class, then we can directly pass it to the method.
But in all the three cases, you can pass an anonymous inner class to the method. Here is
the syntax of passing an anonymous inner class as a method argument:
obj.my_Method(new My_Class(){
public void Do(){
.....
.....
}
});
The following program shows how to pass an anonymous inner class as a method
argument.
//interface
interface Message{
String greet();
}
public class My_class {
//method which accepts the object of interface Message
public void displayMessage(Message m){
System.out.println(m.greet() +", This is an example of anonymous inner
calss as an argument");
}
public static void main(String args[]){
//Instantiating the class
My_class obj = new My_class();
//Passing an anonymous inner class as an argument
obj.displayMessage(new Message(){
public String greet(){
return "Hello";
}
});
295Java
}
}
If you compile and execute the above program, it gives you the following result.
Hello This is an example of anonymous inner class as an argument
Static Nested Class
A static inner class is a nested class which is a static member of the outer class. It can be
accessed without instantiating the outer class, using other static members. Just like static
members, a static nested class does not have access to the instance variables and methods
of the outer class. The syntax of static nested class is as follows:
class MyOuter {
static class Nested_Demo{
}
}
Instantiating a static nested class is a bit different from instantiating an inner class. The
following program shows how to use a static nested class.
public class Outer{
static class Nested_Demo{
public void my_method(){
System.out.println("This is my nested class");
}
}
public static void main(String args[]){
Outer.Nested_Demo nested = new Outer.Nested_Demo();
nested.my_method();
}
}
If you compile and execute the above program, you will get the following result.
This is my nested class
296Java
297Java
298Java
Java - Object Oriented
29921.
Java – Inheritance
Java
Inheritance can be defined as the process where one class acquires the properties
(methods and fields) of another. With the use of inheritance the information is made
manageable in a hierarchical order.
The class which inherits the properties of other is known as subclass (derived class, child
class) and the class whose properties are inherited is known as superclass (base class,
parent class).
extends Keyword
extends is the keyword used to inherit the properties of a class. Following is the syntax
of extends keyword.
class Super{
.....
.....
}
class Sub extends Super{
.....
.....
}
Sample Code
Following is an example demonstrating Java inheritance. In this example, you can observe
two classes namely Calculation and My_Calculation.
Using extends keyword, the My_Calculation inherits the methods addition() and
Subtraction() of Calculation class.
300Java
Copy and paste the following program in a file with name My_Calculation.java
class Calculation{
int z;
public void addition(int x, int y){
z = x+y;
System.out.println("The sum of the given numbers:"+z);
}
public void Substraction(int x,int y){
z = x-y;
System.out.println("The difference between the given numbers:"+z);
}
}
public class My_Calculation extends Calculation{
public void multiplication(int x, int y){
z = x*y;
System.out.println("The product of the given numbers:"+z);
}
public static void main(String args[]){
int a = 20, b = 10;
My_Calculation demo = new My_Calculation();
demo.addition(a, b);
demo.Substraction(a, b);
demo.multiplication(a, b);
}
}
Compile and execute the above code as shown below.
javac My_Calculation.java
java My_Calculation
301Java
After executing the program, it will produce the following result.
The sum of the given numbers:30
The difference between the given numbers:10
The product of the given numbers:200
In the given program, when an object to My_Calculation class is created, a copy of the
contents of the superclass is made within it. That is why, using the object of the subclass
you can access the members of a superclass.
The Superclass reference variable can hold the subclass object, but using that variable you
can access only the members of the superclass, so to access the members of both classes
it is recommended to always create reference variable to the subclass.
If you consider the above program, you can instantiate the class as given below. But using
the superclass reference variable ( cal in this case) you cannot call the
method multiplication(), which belongs to the subclass My_Calculation.
Calculation cal = new My_Calculation();
demo.addition(a, b);
demo.Subtraction(a, b);
Note − A subclass inherits all the members (fields, methods, and nested classes) from its
superclass. Constructors are not members, so they are not inherited by subclasses, but
the constructor of the superclass can be invoked from the subclass.
The super keyword
The super keyword is similar to this keyword. Following are the scenarios where the
super keyword is used.
 It is used to differentiate the members of superclass from the members of
subclass, if they have same names.
 It is used to invoke the superclass constructor from subclass.
302Java
Differentiating the Members
If a class is inheriting the properties of another class. And if the members of the superclass
have the names same as the sub class, to differentiate these variables we use super
keyword as shown below.
super.variable
super.method();
Sample Code
This section provides you a program that demonstrates the usage of the super keyword.
In the given program, you have two classes namely Sub_class and Super_class, both have
a method named display() with different implementations, and a variable named num with
different values. We are invoking display() method of both classes and printing the value
of the variable num of both classes. Here you can observe that we have used super
keyword to differentiate the members of superclass from subclass.
Copy and paste the program in a file with name Sub_class.java.
class Super_class{
int num = 20;
//display method of superclass
public void display(){
System.out.println("This is the display method of superclass");
}
}
public class Sub_class extends Super_class {
int num = 10;
//display method of sub class
public void display(){
System.out.println("This is the display method of subclass");
}
303Java
public void my_method(){
//Instantiating subclass
Sub_class sub = new Sub_class();
//Invoking the display() method of sub class
sub.display();
//Invoking the display() method of superclass
super.display();
//printing the value of variable num of subclass
System.out.println("value of the variable named num in sub class:"+ sub.num);
//printing the value of variable num of superclass
System.out.println("value of the variable named num in super class:"+
super.num);
}
public static void main(String args[]){
Sub_class obj = new Sub_class();
obj.my_method();
}
}
Compile and execute the above code using the following syntax.
javac Super_Demo
java Super
On executing the program, you will get the following result −
This is the display method of subclass
This is the display method of superclass
value of the variable named num in sub class:10
value of the variable named num in super class:20
304Java
Invoking Superclass Constructor
If a class is inheriting the properties of another class, the subclass automatically acquires
the default constructor of the superclass. But if you want to call a parameterized
constructor of the superclass, you need to use the super keyword as shown below.
super(values);
Sample Code
The program given in this section demonstrates how to use the super keyword to invoke
the parametrized constructor of the superclass. This program contains a superclass and a
subclass, where the superclass contains a parameterized constructor which accepts a
string value, and we used the super keyword to invoke the parameterized constructor of
the superclass.
Copy and paste the following program in a file with the name Subclass.java
class Superclass{
int age;
Superclass(int age){
this.age = age;
}
public void getAge(){
System.out.println("The value of the variable named age in super class
is: " +age);
}
}
public class Subclass extends Superclass {
Subclass(int age){
super(age);
}
305Java
public static void main(String argd[]){
Subclass s = new Subclass(24);
s.getAge();
}
}
Compile and execute the above code using the following syntax.
javac Subclass
java Subclass
On executing the program, you will get the following result −
The value of the variable named age in super class is: 24
IS-A Relationship
IS-A is a way of saying: This object is a type of that object. Let us see how the
extends keyword is used to achieve inheritance.
public class Animal{
}
public class Mammal extends Animal{
}
public class Reptile extends Animal{
}
public class Dog extends Mammal{
}
Now, based on the above example, in Object-Oriented terms, the following are true −
 Animal is the superclass of Mammal class.
 Animal is the superclass of Reptile class.
 Mammal and Reptile are subclasses of Animal class.
 Dog is the subclass of both Mammal and Animal classes.
306Java
Now, if we consider the IS-A relationship, we can say −
 Mammal IS-A Animal
 Reptile IS-A Animal
 Dog IS-A Mammal
 Hence: Dog IS-A Animal as well
With the use of the extends keyword, the subclasses will be able to inherit all the properties
of the superclass except for the private properties of the superclass.
We can assure that Mammal is actually an Animal with the use of the instance operator.
Example
class Animal{
}
class Mammal extends Animal{
}
class Reptile extends Animal{
}
public class Dog extends Mammal{
public static void main(String args[]){
Animal a = new Animal();
Mammal m = new Mammal();
Dog d = new Dog();
System.out.println(m instanceof Animal);
System.out.println(d instanceof Mammal);
System.out.println(d instanceof Animal);
}
}
This will produce the following result −
true
true
true
307Java
Since we have a good understanding of the extends keyword, let us look into how
the implements keyword is used to get the IS-A relationship.
Generally, the implements keyword is used with classes to inherit the properties of an
interface. Interfaces can never be extended by a class.
Example
public interface Animal {
}
public class Mammal implements Animal{
}
public class Dog extends Mammal{
}
The instanceof Keyword
Let us use the instanceof operator to check determine whether Mammal is actually an
Animal, and dog is actually an Animal.
interface Animal{}
class Mammal implements Animal{}
public class Dog extends Mammal{
public static void main(String args[]){
Mammal m = new Mammal();
Dog d = new Dog();
System.out.println(m instanceof Animal);
System.out.println(d instanceof Mammal);
System.out.println(d instanceof Animal);
}
}
308Java
This will produce the following result:
true
true
true
HAS-A relationship
These relationships are mainly based on the usage. This determines whether a certain
class HAS-A certain thing. This relationship helps to reduce duplication of code as well as
bugs.
Lets look into an example −
public class Vehicle{}
public class Speed{}
public class Van extends Vehicle{
private Speed sp;
}
This shows that class Van HAS-A Speed. By having a separate class for Speed, we do not
have to put the entire code that belongs to speed inside the Van class, which makes it
possible to reuse the Speed class in multiple applications.
In Object-Oriented feature, the users do not need to bother about which object is doing
the real work. To achieve this, the Van class hides the implementation details from the
users of the Van class. So, basically what happens is the users would ask the Van class to
do a certain action and the Van class will either do the work by itself or ask another class
to perform the action.
Types of Inheritance
There are various types of inheritance as demonstrated below.
309Java
A very important fact to remember is that Java does not support multiple inheritance. This
means that a class cannot extend more than one class. Therefore following is illegal −
public class extends Animal, Mammal{}
However, a class can implement one or more interfaces, which ha helped Java get rid of
the impossibility of multiple inheritance.
31022.
Java – Overriding
Java
In the previous chapter, we talked about superclasses and subclasses. If a class inherits a
method from its superclass, then there is a chance to override the method provided that
it is not marked final.
The benefit of overriding is: ability to define a behavior that's specific to the subclass type,
which means a subclass can implement a parent class method based on its requirement.
In object-oriented terms, overriding means to override the functionality of an existing
method.
Example
Let us look at an example.
class Animal{
public void move(){
System.out.println("Animals can move");
}
}
class Dog extends Animal{
public void move(){
System.out.println("Dogs can walk and run");
}
}
public class TestDog{
public static void main(String args[]){
Animal a = new Animal(); // Animal reference and object
Animal b = new Dog(); // Animal reference but Dog object
a.move();// runs the method in Animal class
b.move();//Runs the method in Dog class
}
}
311Java
This will produce the following result:
Animals can move
Dogs can walk and run
In the above example, you can see that even though b is a type of Animal it runs the
move method in the Dog class. The reason for this is: In compile time, the check is made
on the reference type. However, in the runtime, JVM figures out the object type and would
run the method that belongs to that particular object.
Therefore, in the above example, the program will compile properly since Animal class has
the method move. Then, at the runtime, it runs the method specific for that object.
Consider the following example:
class Animal{
public void move(){
System.out.println("Animals can move");
}
}
class Dog extends Animal{
public void move(){
System.out.println("Dogs can walk and run");
}
public void bark(){
System.out.println("Dogs can bark");
}
}
public class TestDog{
public static void main(String args[]){
Animal a = new Animal(); // Animal reference and object
Animal b = new Dog(); // Animal reference but Dog object
a.move();// runs the method in Animal class
b.move();//Runs the method in Dog class
312Java
b.bark();
}
}
This will produce the following result:
TestDog.java:30: cannot find symbol
symbol
: method bark()
location: class Animal
b.bark();
^
This program will throw a compile time error since b's reference type Animal doesn't have
a method by the name of bark.
Rules for Method Overriding
 The argument list should be exactly the same as that of the overridden method.
 The return type should be the same or a subtype of the return type declared in the
original overridden method in the superclass.
 The access level cannot be more restrictive than the overridden method's access
level. For example: If the superclass method is declared public then the overridding
method in the sub lass cannot be either private or protected.
 Instance methods can be overridden only if they are inherited by the subclass.
 A method declared final cannot be overridden.
 A method declared static cannot be overridden but can be re-declared.
 If a method cannot be inherited, then it cannot be overridden.
 A subclass within the same package as the instance's superclass can override any
superclass method that is not declared private or final.
 A subclass in a different package can only override the non-final methods declared
public or protected.
 An overriding method can throw any uncheck exceptions, regardless of whether
the overridden method throws exceptions or not. However, the overriding method
should not throw checked exceptions that are new or broader than the ones
declared by the overridden method. The overriding method can throw narrower or
fewer exceptions than the overridden method.
 Constructors cannot be overridden.
313Java
Using the super Keyword
When invoking a superclass version of an overridden method the super keyword is used.
class Animal{
public void move(){
System.out.println("Animals can move");
}
}
class Dog extends Animal{
public void move(){
super.move(); // invokes the super class method
System.out.println("Dogs can walk and run");
}
}
public class TestDog{
public static void main(String args[]){
Animal b = new Dog(); // Animal reference but Dog object
b.move(); //Runs the method in Dog class
}
}
This will produce the following result:
Animals can move
Dogs can walk and run
31423.
Java – Polymorphism
Java
Polymorphism is the ability of an object to take on many forms. The most common use of
polymorphism in OOP occurs when a parent class reference is used to refer to a child class
object.
Any Java object that can pass more than one IS-A test is considered to be polymorphic.
In Java, all Java objects are polymorphic since any object will pass the IS-A test for their
own type and for the class Object.
It is important to know that the only possible way to access an object is through a
reference variable. A reference variable can be of only one type. Once declared, the type
of a reference variable cannot be changed.
The reference variable can be reassigned to other objects provided that it is not declared
final. The type of the reference variable would determine the methods that it can invoke
on the object.
A reference variable can refer to any object of its declared type or any subtype of its
declared type. A reference variable can be declared as a class or interface type.
Example
Let us look at an example.
public interface Vegetarian{}
public class Animal{}
public class Deer extends Animal implements Vegetarian{}
Now, the Deer class is considered to be polymorphic since this has multiple inheritance.
Following are true for the above examples:
 A Deer IS-A Animal
 A Deer IS-A Vegetarian
 A Deer IS-A Deer
 A Deer IS-A Object
When we apply the reference variable facts to a Deer object reference, the following
declarations are legal:
Deer d = new Deer();
Animal a = d;
Vegetarian v = d;
Object o = d;
All the reference variables d, a, v, o refer to the same Deer object in the heap.
315Java
Virtual Methods
In this section, I will show you how the behavior of overridden methods in Java allows you
to take advantage of polymorphism when designing your classes.
We already have discussed method overriding, where a child class can override a method
in its parent. An overridden method is essentially hidden in the parent class, and is not
invoked unless the child class uses the super keyword within the overriding method.
/* File name : Employee.java */
public class Employee
{
private String name;
private String address;
private int number;
public Employee(String name, String address, int number)
{
System.out.println("Constructing an Employee");
this.name = name;
this.address = address;
this.number = number;
}
public void mailCheck()
{
System.out.println("Mailing a check to " + this.name
+ " " + this.address);
}
public String toString()
{
return name + " " + address + " " + number;
}
public String getName()
{
return name;
}
public String getAddress()
{
return address;
}
316Java
public void setAddress(String newAddress)
{
address = newAddress;
}
public int getNumber()
{
return number;
}
}
Now suppose we extend Employee class as follows:
/* File name : Salary.java */
public class Salary extends Employee
{
private double salary; //Annual salary
public Salary(String name, String address, int number, double
salary)
{
super(name, address, number);
setSalary(salary);
}
public void mailCheck()
{
System.out.println("Within mailCheck of Salary class ");
System.out.println("Mailing check to " + getName()
+ " with salary " + salary);
}
public double getSalary()
{
return salary;
}
public void setSalary(double newSalary)
{
if(newSalary >= 0.0)
{
salary = newSalary;
317Java
}
}
public double computePay()
{
System.out.println("Computing salary pay for " + getName());
return salary/52;
}
}
Now, you study the following program carefully and try to determine its output:
/* File name : VirtualDemo.java */
public class VirtualDemo
{
public static void main(String [] args)
{
Salary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00);
Employee e = new Salary("John Adams", "Boston, MA", 2, 2400.00);
System.out.println("Call mailCheck using Salary reference --");
s.mailCheck();
System.out.println("\n Call mailCheck using Employee reference--");
e.mailCheck();
}
}
This will produce the following result:
Constructing an Employee
Constructing an Employee
Call mailCheck using Salary reference --
Within mailCheck of Salary class
ailing check to Mohd Mohtashim with salary 3600.0
Call mailCheck using Employee reference--
Within mailCheck of Salary class
ailing check to John Adams with salary 2400.0
Here, we instantiate two Salary objects. One using a Salary reference s, and the other
using an Employee reference e.
While invoking s.mailCheck(), the compiler sees mailCheck() in the Salary class at compile
time, and the JVM invokes mailCheck() in the Salary class at run time. Invoking
318Java
mailCheck() on e is quite different because e is an Employee reference. When the compiler
sees e.mailCheck(), the compiler sees the mailCheck() method in the Employee class.
Here, at compile time, the compiler used mailCheck() in Employee to validate this
statement. At run time, however, the JVM invokes mailCheck() in the Salary class.
This behavior is referred to as virtual method invocation, and the methods are referred to
as virtual methods. All methods in Java behave in this manner, whereby an overridden
method is invoked at run time, no matter what data type the reference is that was used
in the source code at compile time.
31924.
Java – Abstraction
Java
As per dictionary, abstraction is the quality of dealing with ideas rather than events. For
example, when you consider the case of e-mail, complex details such as what happens as
soon as you send an e-mail, the protocol your e-mail server uses are hidden from the
user. Therefore, to send an e-mail you just need to type the content, mention the address
of the receiver, and click send.
Likewise in Object-oriented programming, abstraction is a process of hiding the
implementation details from the user, only the functionality will be provided to the user.
In other words, the user will have the information on what the object does instead of how
it does it.
In Java, abstraction is achieved using Abstract classes and interfaces.
Abstract Class
A class which contains the abstract keyword in its declaration is known as abstract class.
 Abstract classes may or may not contain abstract methods, i.e., methods without
body ( public void get(); )
 But, if a class has at least one abstract method, then the class must be declared
abstract.
 If a class is declared abstract, it cannot be instantiated.
 To use an abstract class, you have to inherit it from another class, provide
implementations to the abstract methods in it.
 If you inherit an abstract class, you have to provide implementations to all the
abstract methods in it.
Example
This section provides you an example of the abstract class. To create an abstract class,
just use the abstract keyword before the class keyword, in the class declaration.
/* File name : Employee.java */
public abstract class Employee
{
private String name;
private String address;
private int number;
public Employee(String name, String address, int number)
320Java
{
System.out.println("Constructing an Employee");
this.name = name;
this.address = address;
this.number = number;
}
public double computePay()
{
System.out.println("Inside Employee computePay");
return 0.0;
}
public void mailCheck()
{
System.out.println("Mailing a check to " + this.name
+ " " + this.address);
}
public String toString()
{
return name + " " + address + " " + number;
}
public String getName()
{
return name;
}
public String getAddress()
{
return address;
}
public void setAddress(String newAddress)
{
address = newAddress;
}
321Java
public int getNumber()
{
return number;
}
}
You can observe that except abstract methods the Employee class is same as normal class
in Java. The class is now abstract, but it still has three fields, seven methods, and one
constructor.
Now you can try to instantiate the Employee class in the following way:
/* File name : AbstractDemo.java */
public class AbstractDemo
{
public static void main(String [] args)
{
/* Following is not allowed and would raise error */
Employee e = new Employee("George W.", "Houston, TX", 43);
System.out.println("\n Call mailCheck using Employee reference--");
e.mailCheck();
}
}
When you compile the above class, it gives you the following error:
Employee.java:46: Employee is abstract; cannot be instantiated
Employee e = new Employee("George W.", "Houston, TX", 43);
^
1 error
322Java
Inheriting the Abstract Class
We can inherit the properties of Employee class just like concrete class in the following
way:
/* File name : Salary.java */
public class Salary extends Employee
{
private double salary; //Annual salary
public Salary(String name, String address, int number, double
salary)
{
super(name, address, number);
setSalary(salary);
}
public void mailCheck()
{
System.out.println("Within mailCheck of Salary class ");
System.out.println("Mailing check to " + getName()
+ " with salary " + salary);
}
public double getSalary()
{
return salary;
}
public void setSalary(double newSalary)
{
if(newSalary >= 0.0)
{
salary = newSalary;
}
}
public double computePay()
{
System.out.println("Computing salary pay for " + getName());
return salary/52;
}
}
323Java
Here, you cannot instantiate the Employee class, but you can instantiate the Salary Class,
and using this instance you can access all the three fields and seven methods of Employee
class as shown below.
/* File name : AbstractDemo.java */
public class AbstractDemo
{
public static void main(String [] args)
{
Salary s = new Salary("Mohd Mohtashim", "Ambehta, UP", 3, 3600.00);
Employee e = new Salary("John Adams", "Boston, MA", 2, 2400.00);
System.out.println("Call mailCheck using Salary reference --");
s.mailCheck();
System.out.println("\n Call mailCheck using Employee reference--");
e.mailCheck();
}
}
This produces the following result:
Constructing an Employee
Constructing an Employee
Call mailCheck using
Salary reference --
Within mailCheck of Salary class
ailing check to Mohd Mohtashim with salary 3600.0
Call mailCheck using Employee reference--
Within mailCheck of Salary class
ailing check to John Adams with salary 2400.
Abstract Methods
If you want a class to contain a particular method but you want the actual implementation
of that method to be determined by child classes, you can declare the method in the parent
class as an abstract.

abstract keyword is used to declare the method as abstract.
324Java
 You have to place the abstract keyword before the method name in the method
declaration.
 An abstract method contains a method signature, but no method body.
 Instead of curly braces, an abstract method will have a semoi colon (;) at the end.
Following is an example of the abstract method.
public abstract class Employee
{
private String name;
private String address;
private int number;
public abstract double computePay();
//Remainder of class definition
}
Declaring a method as abstract has two consequences:
 The class containing it must be declared as abstract.
 Any class inheriting the current class must either override the abstract method or
declare itself as abstract.
Note: Eventually, a descendant class has to implement the abstract method; otherwise,
you would have a hierarchy of abstract classes that cannot be instantiated.
Suppose Salary class inherits the Employee
the computePay() method as shown below:
class,
then
it
should
implement
/* File name : Salary.java */
public class Salary extends Employee
{
private double salary; // Annual salary
public double computePay()
{
System.out.println("Computing salary pay for " + getName());
return salary/52;
}
//Remainder of class definition
}
32525.
Java – Encapsulation
Java
Encapsulation is one of the four fundamental OOP concepts. The other three are
inheritance, polymorphism, and abstraction.
Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on
the data (methods) together as a single unit. In encapsulation, the variables of a class will
be hidden from other classes, and can be accessed only through the methods of their
current class. Therefore, it is also known as data hiding.
To achieve encapsulation in Java:
 Declare the variables of a class as private.
 Provide public setter and getter methods to modify and view the variables values.
Example
Following is an example that demonstrates how to achieve Encapsulation in Java:
/* File name : EncapTest.java */
public class EncapTest{
private String name;
private String idNum;
private int age;
public int getAge(){
return age;
}
public String getName(){
return name;
}
public String getIdNum(){
return idNum;
}
326Java
public void setAge( int newAge){
age = newAge;
}
public void setName(String newName){
name = newName;
}
public void setIdNum( String newId){
idNum = newId;
}
}
The public setXXX() and getXXX() methods are the access points of the instance variables
of the EncapTest class. Normally, these methods are referred as getters and setters.
Therefore, any class that wants to access the variables should access them through these
getters and setters.
The variables of the EncapTest class can be accessed using the following program:
/* File name : RunEncap.java */
public class RunEncap{
public static void main(String args[]){
EncapTest encap = new EncapTest();
encap.setName("James");
encap.setAge(20);
encap.setIdNum("12343ms");
System.out.print("Name : " + encap.getName() + " Age : " +
encap.getAge());
}
}
This will produce the following result:
Name : James Age : 20
327Java
Benefits of Encapsulation
 The fields of a class can be made read-only or write-only.
 A class can have total control over what is stored in its fields.
 The users of a class do not know how the class stores its data. A class can change
the data type of a field and users of the class do not need to change any of their
code.
32826.
Java – Interfaces
Java
An interface is a reference type in Java. It is similar to class. It is a collection of abstract
methods. A class implements an interface, thereby inheriting the abstract methods of the
interface.
Along with abstract methods, an interface may also contain constants, default methods,
static methods, and nested types. Method bodies exist only for default methods and static
methods.
Writing an interface is similar to writing a class. But a class describes the attributes and
behaviors of an object. And an interface contains behaviors that a class implements.
Unless the class that implements the interface is abstract, all the methods of the interface
need to be defined in the class.
An interface is similar to a class in the following ways:
 An interface can contain any number of methods.
 An interface is written in a file with a .java extension, with the name of the
interface matching the name of the file.
 The byte code of an interface appears in a .class file.
 Interfaces appear in packages, and their corresponding bytecode file must be in a
directory structure that matches the package name.
However, an interface is different from a class in several ways, including:
 You cannot instantiate an interface.
 An interface does not contain any constructors.
 All of the methods in an interface are abstract.
 An interface cannot contain instance fields. The only fields that can appear in an
interface must be declared both static and final.
 An interface is not extended by a class; it is implemented by a class.
 An interface can extend multiple interfaces.
329Java
Declaring Interfaces
The interface keyword is used to declare an interface. Here is a simple example to declare
an interface.
Example
Following is an example of an interface:
/* File name : NameOfInterface.java */
import java.lang.*;
//Any number of import statements
public interface NameOfInterface
{
//Any number of final, static fields
//Any number of abstract method declarations\
}
Interfaces have the following properties:
 An interface is implicitly abstract. You do not need to use the abstract keyword
while declaring an interface.
 Each method in an interface is also implicitly abstract, so the abstract keyword is
not needed.
 Methods in an interface are implicitly public.
Example
/* File name : Animal.java */
interface Animal {
public void eat();
public void travel();
}
Implementing Interfaces
When a class implements an interface, you can think of the class as signing a contract,
agreeing to perform the specific behaviors of the interface. If a class does not perform all
the behaviors of the interface, the class must declare itself as abstract.
330Java
A class uses the implements keyword to implement an interface. The implements
keyword appears in the class declaration following the extends portion of the declaration.
/* File name : MammalInt.java */
public class MammalInt implements Animal{
public void eat(){
System.out.println("Mammal eats");
}
public void travel(){
System.out.println("Mammal travels");
}
public int noOfLegs(){
return 0;
}
public static void main(String args[]){
MammalInt m = new MammalInt();
m.eat();
m.travel();
}
}
This will produce the following result:
Mammal eats
Mammal travels
When overriding methods defined in interfaces, there are several rules to be followed:
 Checked exceptions should not be declared on implementation methods other than
the ones declared by the interface method or subclasses of those declared by the
interface method.
 The signature of the interface method and the same return type or subtype should
be maintained when overriding the methods.
 An implementation class itself can be abstract and if so, interface methods need
not be implemented.
331Java
When implementation interfaces, there are several rules:
 A class can implement more than one interface at a time.
 A class can extend only one class, but implement many interfaces.
 An interface can extend another interface, in a similar way as a class can extend
another class.
Extending Interfaces
An interface can extend another interface in the same way that a class can extend another
class. The extends keyword is used to extend an interface, and the child interface inherits
the methods of the parent interface.
The following Sports interface is extended by Hockey and Football interfaces.
//Filename: Sports.java
public interface Sports
{
public void setHomeTeam(String name);
public void setVisitingTeam(String name);
}
//Filename: Football.java
public interface Football extends Sports
{
public void homeTeamScored(int points);
public void visitingTeamScored(int points);
public void endOfQuarter(int quarter);
}
//Filename: Hockey.java
public interface Hockey extends Sports
{
public void homeGoalScored();
public void visitingGoalScored();
public void endOfPeriod(int period);
public void overtimePeriod(int ot);
}
332Java
The Hockey interface has four methods, but it inherits two from Sports; thus, a class that
implements Hockey needs to implement all six methods. Similarly, a class that implements
Football needs to define the three methods from Football and the two methods from
Sports.
Extending Multiple Interfaces
A Java class can only extend one parent class. Multiple inheritance is not allowed.
Interfaces are not classes, however, and an interface can extend more than one parent
interface.
The extends keyword is used once, and the parent interfaces are declared in a comma-
separated list.
For example, if the Hockey interface extended both Sports and Event, it would be declared
as:
public interface Hockey extends Sports, Event
Tagging Interfaces
The most common use of extending interfaces occurs when the parent interface does not
contain any methods. For example, the MouseListener interface in the java.awt.event
package extended java.util.EventListener, which is defined as:
package java.util;
public interface EventListener
{}
An interface with no methods in it is referred to as a tagging interface. There are two
basic design purposes of tagging interfaces:
Creates a common parent: As with the EventListener interface, which is extended by
dozens of other interfaces in the Java API, you can use a tagging interface to create a
common parent among a group of interfaces. For example, when an interface extends
EventListener, the JVM knows that this particular interface is going to be used in an event
delegation scenario.
Adds a data type to a class: This situation is where the term, tagging comes from. A
class that implements a tagging interface does not need to define any methods (since the
interface does not have any), but the class becomes an interface type through
polymorphism.
33327.
Java – Packages
Java
Packages are used in Java in order to prevent naming conflicts, to control access, to make
searching/locating and usage of classes, interfaces, enumerations and annotations easier,
etc.
A Package can be defined as a grouping of related types (classes, interfaces,
enumerations and annotations ) providing access protection and namespace management.
Some of the existing packages in Java are:
 java.lang - bundles the fundamental classes
 java.io - classes for input, output functions are bundled in this package
Programmers can define their own packages to bundle group of classes/interfaces, etc. It
is a good practice to group related classes implemented by you so that a programmer can
easily determine that the classes, interfaces, enumerations, and annotations are related.
Since the package creates a new namespace there won't be any name conflicts with names
in other packages. Using packages, it is easier to provide access control and it is also
easier to locate the related classes.
Creating a Package
While creating a package, you should choose a name for the package and include
a package statement along with that name at the top of every source file that contains
the classes, interfaces, enumerations, and annotation types that you want to include in
the package.
The package statement should be the first line in the source file. There can be only one
package statement in each source file, and it applies to all types in the file.
If a package statement is not used then the class, interfaces, enumerations, and
annotation types will be placed in the current default package.
To compile the Java programs with package statements, you have to use -d option as
shown below.
javac -d Destination_folder file_name.java
Then a folder with the given package name is created in the specified destination, and the
compiled class files will be placed in that folder.
Example
Let us look at an example that creates a package called animals. It is a good practice to
use names of packages with lower case letters to avoid any conflicts with the names of
classes and interfaces.
334Java
Following package example contains interface named animals:
/* File name : Animal.java */
package animals;
interface Animal {
public void eat();
public void travel();
}
Now, let us implement the above interface in the same package animals:
package animals;
/* File name : MammalInt.java */
public class MammalInt implements Animal{
public void eat(){
System.out.println("Mammal eats");
}
public void travel(){
System.out.println("Mammal travels");
}
public int noOfLegs(){
return 0;
}
public static void main(String args[]){
MammalInt m = new MammalInt();
m.eat();
m.travel();
}
}
Now compile the java files as shown below:
$ javac -d . Animal.java
$ javac -d . MammalInt.java
335Java
Now a package/folder with the name animals will be created in the current directory and
these class files will be placed in it as shown below.
You can execute the class file within the package and get the result as shown below.
$ java animals.MammalInt
ammal eats
ammal travels
The import Keyword
If a class wants to use another class in the same package, the package name need not be
used. Classes in the same package find each other without any special syntax.
Example
Here, a class named Boss is added to the payroll package that already contains Employee.
The Boss can then refer to the Employee class without using the payroll prefix, as
demonstrated by the following Boss class.
package payroll;
public class Boss
{
public void payEmployee(Employee e)
{
e.mailCheck();
}
}
336Java
What happens if the Employee class is not in the payroll package? The Boss class must
then use one of the following techniques for referring to a class in a different package.

The fully qualified name of the class can be used. For example:
payroll.Employee

The package can be imported using the import keyword and the wild card (*). For
example:
import payroll.*;

The class itself can be imported using the import keyword. For example:
import payroll.Employee;
Note: A class file can contain any number of import statements. The import statements
must appear after the package statement and before the class declaration.
The Directory Structure of Packages
Two major results occur when a class is placed in a package:
 The name of the package becomes a part of the name of the class, as we just
discussed in the previous section.
 The name of the package must match the directory structure where the
corresponding bytecode resides.
Here is simple way of managing your files in Java:
Put the source code for a class, interface, enumeration, or annotation type in a text file
whose name is the simple name of the type and whose extension is .java. For example:
// File Name :
Car.java
package vehicle;
public class Car {
// Class implementation.
}
Now, put the source file in a directory whose name reflects the name of the package to
which the class belongs:
....\vehicle\Car.java
337Java
Now, the qualified class name and pathname would be as follows:


Class name -> vehicle.Car
Path name -> vehicle\Car.java (in windows)
In general, a company uses its reversed Internet domain name for its package names.
Example: A company's Internet domain name is apple.com, then all its package names
would start with com.apple. Each component of the package name corresponds to a
subdirectory.
Example: The company had a com.apple.computers package that contained a Dell.java
source file, it would be contained in a series of subdirectories like this:
....\com\apple\computers\Dell.java
At the time of compilation, the compiler creates a different output file for each class,
interface and enumeration defined in it. The base name of the output file is the name of
the type, and its extension is .class.
For example:
// File Name: Dell.java
package com.apple.computers;
public class Dell{
}
class Ups{
}
Now, compile this file as follows using -d option:
$javac -d . Dell.java
The files will be compiled as follows:
.\com\apple\computers\Dell.class
.\com\apple\computers\Ups.class
You can import all the classes or interfaces defined in \com\apple\computers\ as follows:
import com.apple.computers.*;
338Java
Like the .java source files, the compiled .class files should be in a series of directories that
reflect the package name. However, the path to the .class files does not have to be the
same as the path to the .java source files. You can arrange your source and class
directories separately, as:
<path-one>\sources\com\apple\computers\Dell.java
<path-two>\classes\com\apple\computers\Dell.class
By doing this, it is possible to give access to the classes directory to other programmers
without revealing your sources. You also need to manage source and class files in this
manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your
program uses.
The full path to the classes directory, <path-two>\classes, is called the class path, and is
set with the CLASSPATH system variable. Both the compiler and the JVM construct the
path to your .class files by adding the package name to the class path.
Say <path-two>\classes is the class path, and the package name is com.apple.computers,
then
the
compiler
and
JVM
will
look
for
.class
files
in
<path-
two>\classes\com\apple\computers.
A class path may include several paths. Multiple paths should be separated by a semicolon
(Windows) or colon (Unix). By default, the compiler and the JVM search the current
directory and the JAR file containing the Java platform classes so that these directories
are automatically in the class path.
Set CLASSPATH System Variable
To display the current CLASSPATH variable, use the following commands in Windows and
UNIX (Bourne shell):


In Windows -> C:\> set CLASSPATH
In UNIX -> % echo $CLASSPATH
To delete the current contents of the CLASSPATH variable, use:


In Windows -> C:\> set CLASSPATH=
In UNIX -> % unset CLASSPATH; export CLASSPATH
To set the CLASSPATH variable:


In Windows -> set CLASSPATH=C:\users\jack\java\classes
In UNIX -> % CLASSPATH=/home/jack/java/classes; export CLASSPATH
339Java
Java – Advanced
34028.
Java – Data Structures
Java
The data structures provided by the Java utility package are very powerful and perform a
wide range of functions. These data structures consist of the following interface and
classes:
 Enumeration
 BitSet
 Vector
 Stack
 Dictionary
 Hashtable
 Properties
All these classes are now legacy and Java-2 has introduced a new framework called
Collections Framework, which is discussed in the next chapter.
The Enumeration
The Enumeration interface isn't itself a data structure, but it is very important within the
context of other data structures. The Enumeration interface defines a means to retrieve
successive elements from a data structure.
For example, Enumeration defines a method called nextElement that is used to get the
next element in a data structure that contains multiple elements.
To have more detail about this interface, check The Enumeration.
The Enumeration Interface
The Enumeration interface defines the methods by which you can enumerate (obtain one
at a time) the elements in a collection of objects.
This legacy interface has been superceded by Iterator. Although not deprecated,
Enumeration is considered obsolete for new code. However, it is used by several methods
defined by the legacy classes such as Vector and Properties, is used by several other API
classes, and is currently in widespread use in application code.
341Java
The methods declared by Enumeration are summarized in the following table:
Sr.
No.
Methods with Description
boolean hasMoreElements( )
1
When implemented, it must return true while there are still more elements to
extract, and false when all the elements have been enumerated.
Object nextElement( )
2
This returns the next object in the enumeration as a generic Object reference.
Example
Following is an example showing usage of Enumeration.
import java.util.Vector;
import java.util.Enumeration;
public class EnumerationTester {
public static void main(String args[]) {
Enumeration days;
Vector dayNames = new Vector();
dayNames.add("Sunday");
dayNames.add("Monday");
dayNames.add("Tuesday");
dayNames.add("Wednesday");
dayNames.add("Thursday");
dayNames.add("Friday");
dayNames.add("Saturday");
days = dayNames.elements();
while (days.hasMoreElements()){
System.out.println(days.nextElement());
}
}
}
342Java
This will produce the following result:
Sunday
onday
Tuesday
Wednesday
Thursday
Friday
Saturday
The BitSet
The BitSet class implements a group of bits or flags that can be set and cleared individually.
This class is very useful in cases where you need to keep up with a set of Boolean values;
you just assign a bit to each value and set or clear it as appropriate.
For more details about this class, check The BitSet.
The BitSet Class
The BitSet class creates a special type of array that holds bit values. The BitSet array can
increase in size as needed. This makes it similar to a vector of bits. This is a legacy class
but it has been completely re-engineered in Java 2, version 1.4.
The BitSet defines the following two constructors.
Sr. No.
Constructor and Description
BitSet( )
1
This constructor creates a default object
BitSet(int size)
2
This constructor allows you to specify its initial size, i.e., the number of bits
that it can hold. All bits are initialized to zero
343Java
BitSet implements the Cloneable interface and defines the methods listed in the following
table:
Sr.
No.
1
Methods with Description
void and(BitSet bitSet)
ANDs the contents of the invoking BitSet object with those specified by bitSet.
The result is placed into the invoking object.
2
3
4
5
6
7
void andNot(BitSet bitSet)
For each 1 bit in bitSet, the corresponding bit in the invoking BitSet is cleared.
int cardinality( )
Returns the number of set bits in the invoking object.
void clear( )
Zeros all bits.
void clear(int index)
Zeros the bit specified by index.
void clear(int startIndex, int endIndex)
Zeros the bits from startIndex to endIndex.
Object clone( )
Duplicates the invoking BitSet object.
boolean equals(Object bitSet)
8
9
Returns true if the invoking bit set is equivalent to the one passed in bitSet.
Otherwise, the method returns false.
void flip(int index)
Reverses the bit specified by the index.
344Java
10
11
void flip(int startIndex, int endIndex)
Reverses the bits from startIndex to endIndex.
boolean get(int index)
Returns the current state of the bit at the specified index.
BitSet get(int startIndex, int endIndex)
12
13
Returns a BitSet that consists of the bits from startIndex to endIndex. The
invoking object is not changed.
int hashCode( )
Returns the hash code for the invoking object.
boolean intersects(BitSet bitSet)
14
15
Returns true if at least one pair of corresponding bits within the invoking object
and bitSet are 1.
boolean isEmpty( )
Returns true if all bits in the invoking object are zero.
int length( )
16
Returns the number of bits required to hold the contents of the invoking BitSet.
This value is determined by the location of the last 1 bit.
int nextClearBit(int startIndex)
17
Returns the index of the next cleared bit, (that is, the next zero bit), starting
from the index specified by startIndex.
int nextSetBit(int startIndex)
18
Returns the index of the next set bit (that is, the next 1 bit), starting from the
index specified by startIndex. If no bit is set, -1 is returned.
void or(BitSet bitSet)
19
ORs the contents of the invoking BitSet object with that specified by bitSet. The
result is placed into the invoking object.
345Java
20
void set(int index)
Sets the bit specified by index.
void set(int index, boolean v)
21
22
Sets the bit specified by index to the value passed in v. True sets the bit, false
clears the bit.
void set(int startIndex, int endIndex)
Sets the bits from startIndex to endIndex.
void set(int startIndex, int endIndex, boolean v)
23
24
25
Sets the bits from startIndex to endIndex, to the value passed in v. true sets
the bits, false clears the bits.
int size( )
Returns the number of bits in the invoking BitSet object.
String toString( )
Returns the string equivalent of the invoking BitSet object.
void xor(BitSet bitSet)
26
XORs the contents of the invoking BitSet object with that specified by bitSet.
The result is placed into the invoking object.
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.BitSet;
public class BitSetDemo {
public static void main(String args[]) {
BitSet bits1 = new BitSet(16);
BitSet bits2 = new BitSet(16);
346Java
// set some bits
for(int i=0; i<16; i++) {
if((i%2) == 0) bits1.set(i);
if((i%5) != 0) bits2.set(i);
}
System.out.println("Initial pattern in bits1: ");
System.out.println(bits1);
System.out.println("\nInitial pattern in bits2: ");
System.out.println(bits2);
// AND bits
bits2.and(bits1);
System.out.println("\nbits2 AND bits1: ");
System.out.println(bits2);
// OR bits
bits2.or(bits1);
System.out.println("\nbits2 OR bits1: ");
System.out.println(bits2);
// XOR bits
bits2.xor(bits1);
System.out.println("\nbits2 XOR bits1: ");
System.out.println(bits2);
}
}
This will produce the following result:
Initial pattern in bits1:
{0, 2, 4, 6, 8, 10, 12, 14}
Initial pattern in bits2:
{1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}
347Java
bits2 AND bits1:
{2, 4, 6, 8, 12, 14}
bits2 OR bits1:
{0, 2, 4, 6, 8, 10, 12, 14}
bits2 XOR bits1:
{}
The Vector
The Vector class is similar to a traditional Java array, except that it can grow as necessary
to accommodate new elements.
Like an array, elements of a Vector object can be accessed via an index into the vector.
The nice thing about using the Vector class is that you don't have to worry about setting
it to a specific size upon creation; it shrinks and grows automatically when necessary.
For more details about this class, check The Vector.
The Vector Class
Vector implements a dynamic array. It is similar to ArrayList, but with two differences:
 Vector is synchronized.
 Vector contains many legacy methods that are not part of the collections
framework.
Vector proves to be very useful if you don't know the size of the array in advance or you
just need one that can change sizes over the lifetime of a program.
Following is the list of constructors provided by the vector class.
Sr.
No.
1
Constructor and Description
Vector( )
This constructor creates a default vector, which has an initial size of 10
2
Vector(int size)
348Java
This constructor accepts an argument that equals to the required size, and
creates a vector whose initial capacity is specified by size
Vector(int size, int incr)
3
4
This constructor creates a vector whose initial capacity is specified by size
and whose increment is specified by incr. The increment specifies the number
of elements to allocate each time that a vector is resized upward
Vector(Collection c)
This constructor creates a vector that contains the elements of collection c
Apart from the methods inherited from its parent classes, Vector defines the following
methods:
Sr. No.
1
Methods with Description
void add(int index, Object element)
Inserts the specified element at the specified position in this Vector.
2
boolean add(Object o)
Appends the specified element to the end of this Vector.
boolean addAll(Collection c)
3
Appends all of the elements in the specified Collection to the end of this
Vector, in the order that they are returned by the specified Collection's
Iterator.
boolean addAll(int index, Collection c)
4
Inserts all of the elements in in the specified Collection into this Vector at the
specified position.
void addElement(Object obj)
5
Adds the specified component to the end of this vector, increasing its size by
one.
349Java
6
7
8
9
int capacity()
Returns the current capacity of this vector.
void clear()
Removes all of the elements from this vector.
Object clone()
Returns a clone of this vector.
boolean contains(Object elem)
Tests if the specified object is a component in this vector.
boolean containsAll(Collection c)
10
11
12
13
Returns true if this vector contains all of the elements in the specified
Collection.
void copyInto(Object[] anArray)
Copies the components of this vector into the specified array.
Object elementAt(int index)
Returns the component at the specified index.
Enumeration elements()
Returns an enumeration of the components of this vector.
void ensureCapacity(int minCapacity)
14
15
16
Increases the capacity of this vector, if necessary, to ensure that it can hold
at least the number of components specified by the minimum capacity
argument.
boolean equals(Object o)
Compares the specified Object with this vector for equality.
Object firstElement()
Returns the first component (the item at index 0) of this vector.
350Java
17
18
Object get(int index)
Returns the element at the specified position in this vector.
int hashCode()
Returns the hash code value for this vector.
int indexOf(Object elem)
19
Searches for the first occurence of the given argument, testing for equality
using the equals method.
int indexOf(Object elem, int index)
20
Searches for the first occurence of the given argument, beginning the search
at index, and testing for equality using the equals method.
void insertElementAt(Object obj, int index)
21
Inserts the specified object as a component in this vector at the specified
index.
22
23
24
boolean isEmpty()
Tests if this vector has no components.
Object lastElement()
Returns the last component of the vector.
int lastIndexOf(Object elem)
Returns the index of the last occurrence of the specified object in this vector.
int lastIndexOf(Object elem, int index)
25
26
Searches backwards for the specified object, starting from the specified
index, and returns an index to it.
Object remove(int index)
Removes the element at the specified position in this vector.
351Java
boolean remove(Object o)
27
Removes the first occurrence of the specified element in this vector, If the
vector does not contain the element, it is unchanged.
boolean removeAll(Collection c)
28
29
Removes from this vector all of its elements that are contained in the
specified Collection.
void removeAllElements()
Removes all components from this vector and sets its size to zero.
boolean removeElement(Object obj)
30
31
Removes the first (lowest-indexed) occurrence of the argument from this
vector.
void removeElementAt(int index)
removeElementAt(int index)
protected void removeRange(int fromIndex, int toIndex)
32
Removes from this List all of the elements whose index is between
fromIndex, inclusive and toIndex, exclusive.
boolean retainAll(Collection c)
33
Retains only the elements in this vector that are contained in the specified
Collection.
Object set(int index, Object element)
34
Replaces the element at the specified position in this vector with the specified
element.
void setElementAt(Object obj, int index)
35
Sets the component at the specified index of this vector to be the specified
object.
352Java
void setSize(int newSize)
36
Sets the size of this vector.
int size()
37
Returns the number of components in this vector.
List subList(int fromIndex, int toIndex)
38
Returns a view of the portion of this List between fromIndex, inclusive, and
toIndex, exclusive.
Object[] toArray()
39
Returns an array containing all of the elements in this vector in the correct
order.
Object[] toArray(Object[] a)
40
Returns an array containing all of the elements in this vector in the correct
order; the runtime type of the returned array is that of the specified array.
String toString()
41
Returns a string representation of this vector, containing the String
representation of each element.
void trimToSize()
42
Trims the capacity of this vector to be the vector's current size.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class VectorDemo {
public static void main(String args[]) {
// initial size is 3, increment is 2
Vector v = new Vector(3, 2);
System.out.println("Initial size: " + v.size());
353Java
System.out.println("Initial capacity: " +
v.capacity());
v.addElement(new Integer(1));
v.addElement(new Integer(2));
v.addElement(new Integer(3));
v.addElement(new Integer(4));
System.out.println("Capacity after four additions: " +
v.capacity());
v.addElement(new Double(5.45));
System.out.println("Current capacity: " +
v.capacity());
v.addElement(new Double(6.08));
v.addElement(new Integer(7));
System.out.println("Current capacity: " +
v.capacity());
v.addElement(new Float(9.4));
v.addElement(new Integer(10));
System.out.println("Current capacity: " +
v.capacity());
v.addElement(new Integer(11));
v.addElement(new Integer(12));
System.out.println("First element: " +
(Integer)v.firstElement());
System.out.println("Last element: " +
(Integer)v.lastElement());
if(v.contains(new Integer(3)))
System.out.println("Vector contains 3.");
// enumerate the elements in the vector.
Enumeration vEnum = v.elements();
System.out.println("\nElements in vector:");
while(vEnum.hasMoreElements())
System.out.print(vEnum.nextElement() + " ");
System.out.println();
}
}
354Java
This will produce the following result:
Initial size: 0
Initial capacity: 3
Capacity after four additions: 5
Current capacity: 5
Current capacity: 7
Current capacity: 9
First element: 1
Last element: 12
Vector contains 3.
Elements in vector:
1 2 3 4 5.45 6.08 7 9.4 10 11 12
The Stack
The Stack class implements a last-in-first-out (LIFO) stack of elements.
You can think of a stack literally as a vertical stack of objects; when you add a new
element, it gets stacked on top of the others.
When you pull an element off the stack, it comes off the top. In other words, the last
element you added to the stack is the first one to come back off.
For more details about this class, check The Stack.
The Stack Class
Stack is a subclass of Vector that implements a standard last-in, first-out stack.
Stack only defines the default constructor, which creates an empty stack. Stack includes
all the methods defined by Vector, and adds several of its own.
Stack( )
355Java
Apart from the methods inherited from its parent class Vector, Stack defines the following
methods:
Sr.
No.
Methods with Description
boolean empty()
1
2
3
4
Tests if this stack is empty. Returns true if the stack is empty, and returns
false if the stack contains elements.
Object peek( )
Returns the element on the top of the stack, but does not remove it.
Object pop( )
Returns the element on the top of the stack, removing it in the process.
Object push(Object element)
Pushes the element onto the stack. Element is also returned.
int search(Object element)
5
Searches for element in the stack. If found, its offset from the top of the stack
is returned. Otherwise, .1 is returned.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class StackDemo {
static void showpush(Stack st, int a) {
st.push(new Integer(a));
System.out.println("push(" + a + ")");
System.out.println("stack: " + st);
}
356Java
static void showpop(Stack st) {
System.out.print("pop -> ");
Integer a = (Integer) st.pop();
System.out.println(a);
System.out.println("stack: " + st);
}
public static void main(String args[]) {
Stack st = new Stack();
System.out.println("stack: " + st);
showpush(st, 42);
showpush(st, 66);
showpush(st, 99);
showpop(st);
showpop(st);
showpop(st);
try {
showpop(st);
} catch (EmptyStackException e) {
System.out.println("empty stack");
}
}
}
This will produce the following result:
stack: [ ]
push(42)
stack: [42]
push(66)
stack: [42, 66]
push(99)
stack: [42, 66, 99]
pop -> 99
357Java
stack: [42, 66]
pop -> 66
stack: [42]
pop -> 42
stack: [ ]
pop -> empty stack
The Dictionary
The Dictionary class is an abstract class that defines a data structure for mapping keys to
values.
This is useful in cases where you want to be able to access data via a particular key rather
than an integer index.
Since the Dictionary class is abstract, it provides only the framework for a key-mapped
data structure rather than a specific implementation.
For more details about this class, check The Dictionary.
The Dictionary Class
Dictionary is an abstract class that represents a key/value storage repository and operates
much like Map.
Given a key and value, you can store the value in a Dictionary object. Once the value is
stored, you can retrieve it by using its key. Thus, like a map, a dictionary can be thought
of as a list of key/value pairs.
The abstract methods defined by Dictionary are listed below:
Sr.
No.
1
Methods with Description
Enumeration elements( )
Returns an enumeration of the values contained in the dictionary.
Object get(Object key)
2
Returns the object that contains the value associated with the key. If the key
is not in the dictionary, a null object is returned.
358Java
boolean isEmpty( )
3
4
Returns true if the dictionary is empty, and returns false if it contains at least
one key.
Enumeration keys( )
Returns an enumeration of the keys contained in the dictionary.
Object put(Object key, Object value)
5 Inserts a key and its value into the dictionary. Returns null if the key is not
already in the dictionary; returns the previous value associated with the key if
the key is already in the dictionary.
6 Object remove(Object key)
Removes the key and its value. Returns the value associated with the key. If
the key is not in the dictionary, a null is returned.
7
int size( )
Returns the number of entries in the dictionary.
The Dictionary class is obsolete. You should implement the Map interface to obtain
key/value storage functionality.
The Map Interface
The Map interface maps unique keys to values. A key is an object that you use to retrieve
a value at a later date.
 Given a key and a value, you can store the value in a Map object. After the value
is stored, you can retrieve it by using its key.
 Several methods throw a NoSuchElementException when no items exist in the
invoking map.
 A ClassCastException is thrown when an object is incompatible with the elements
in a map.
 A NullPointerException is thrown if an attempt is made to use a null object and null
is not allowed in the map.
 An UnsupportedOperationException is thrown when an attempt is made to change
an unmodifiable map.
359Java
Sr.
No.
1
Methods with Description
void clear( )
Removes all key/value pairs from the invoking map.
2
3
boolean containsKey(Object k)
Returns true if the invoking map contains k as a key. Otherwise, returns false.
boolean containsValue(Object v)
Returns true if the map contains v as a value. Otherwise, returns false.
Set entrySet( )
4
Returns a Set that contains the entries in the map. The set contains objects of
type Map.Entry. This method provides a set-view of the invoking map.
boolean equals(Object obj)
5
6
7
8
Returns true if obj is a Map and contains the same entries. Otherwise, returns
false.
Object get(Object k)
Returns the value associated with the key k.
int hashCode( )
Returns the hash code for the invoking map.
boolean isEmpty( )
Returns true if the invoking map is empty. Otherwise, returns false.
Set keySet( )
9
Returns a Set that contains the keys in the invoking map. This method provides
a set-view of the keys in the invoking map.
360Java
Object put(Object k, Object v)
10
11
12
13
Puts an entry in the invoking map, overwriting any previous value associated
with the key. The key and value are k and v, respectively. Returns null if the
key did not already exist. Otherwise, the previous value linked to the key is
returned.
void putAll(Map m)
Puts all the entries from m into this map.
Object remove(Object k)
Removes the entry whose key equals k.
int size( )
Returns the number of key/value pairs in the map.
Collection values( )
14
Returns a collection containing the values in the map. This method provides a
collection-view of the values in the map.
Example
Map has its implementation in various classes like HashMap. Following is an example to
explain map functionality:
import java.util.*;
public class CollectionsDemo {
public static void main(String[] args) {
Map m1 = new HashMap();
m1.put("Zara", "8");
m1.put("Mahnaz", "31");
m1.put("Ayan", "12");
m1.put("Daisy", "14");
System.out.println();
System.out.println(" Map Elements");
System.out.print("\t" + m1);
}
}
361Java
This will produce the following result:
ap Elements
{Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
The Hashtable
The Hashtable class provides a means of organizing data based on some user-defined key
structure.
For example, in an address list hash table you could store and sort data based on a key
such as ZIP code rather than on a person's name.
The specific meaning of keys with regard to hash tables is totally dependent on the usage
of the hash table and the data it contains.
For more detail about this class, check The Hashtable.
The Hashtable Class
Hashtable was part of the original java.util and is a concrete implementation of a
Dictionary.
However, Java 2 re-engineered Hashtable so that it also implements the Map interface.
Thus, Hashtable is now integrated into the collections framework. It is similar to HashMap,
but is synchronized.
Like HashMap, Hashtable stores key/value pairs in a hash table. When using a Hashtable,
you specify an object that is used as a key, and the value that you want linked to that
key. The key is then hashed, and the resulting hash code is used as the index at which
the value is stored within the table.
Following is the list of constructors provided by the HashTable class.
Sr.
No.
1
Constructor and Description
Hashtable( )
This is the default constructor of the hash table it instantiates the Hashtable
class.
Hashtable(int size)
2
This constructor accepts an integer parameter and creates a hash table that
has an initial size specified by integer value size.
362Java
Hashtable(int size, float fillRatio)
3
4
This creates a hash table that has an initial size specified by size and a fill ratio
specified by fillRatio. This ratio must be between 0.0 and 1.0, and it determines
how full the hash table can be before it is resized upward.
Hashtable(Map<? extends K, ? extends V> t)
This constructs a Hashtable with the given mappings.
Apart from the methods defined by Map interface, Hashtable defines the following
methods:
Sr.
No.
1
Methods with Description
void clear( )
Resets and empties the hash table.
2
Object clone( )
Returns a duplicate of the invoking object.
boolean contains(Object value)
3
Returns true if some value equal to the value exists within the hash table.
Returns false if the value isn't found.
boolean containsKey(Object key)
4
Returns true if some key equal to the key exists within the hash table. Returns
false if the key isn't found.
boolean containsValue(Object value)
5
6
Returns true if some value equal to the value exists within the hash table.
Returns false if the value isn't found.
Enumeration elements( )
Returns an enumeration of the values contained in the hash table.
363Java
Object get(Object key)
7
Returns the object that contains the value associated with the key. If the key
is not in the hash table, a null object is returned.
boolean isEmpty( )
8
9
Returns true if the hash table is empty; returns false if it contains at least one
key.
Enumeration keys( )
Returns an enumeration of the keys contained in the hash table.
Object put(Object key, Object value)
10
11
Inserts a key and a value into the hash table. Returns null if the key isn't
already in the hash table; returns the previous value associated with the key
if the key is already in the hash table.
void rehash( )
Increases the size of the hash table and rehashes all of its keys.
Object remove(Object key)
12
13
14
Removes the key and its value. Returns the value associated with the key. If
the key is not in the hash table, a null object is returned.
int size( )
Returns the number of entries in the hash table.
String toString( )
Returns the string equivalent of a hash table.
364Java
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.*;
public class HashTableDemo {
public static void main(String args[]) {
// Create a hash map
Hashtable balance = new Hashtable();
Enumeration names;
String str;
double bal;
balance.put("Zara", new Double(3434.34));
balance.put("Mahnaz", new Double(123.22));
balance.put("Ayan", new Double(1378.00));
balance.put("Daisy", new Double(99.22));
balance.put("Qadir", new Double(-19.08));
// Show all balances in hash table.
names = balance.keys();
while(names.hasMoreElements()) {
str = (String) names.nextElement();
System.out.println(str + ": " +
balance.get(str));
}
System.out.println();
// Deposit 1,000 into Zara's account
bal = ((Double)balance.get("Zara")).doubleValue();
balance.put("Zara", new Double(bal+1000));
System.out.println("Zara's new balance: " +
balance.get("Zara"));
}
}
365Java
This will produce the following result:
Qadir: -19.08
Zara: 3434.34
ahnaz: 123.22
Daisy: 99.22
Ayan: 1378.0
Zara's new balance: 4434.34
The Properties
Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key
is a String and the value is also a String.
The Properties class is used by many other Java classes. For example, it is the type of
object returned by System.getProperties( ) when obtaining environmental values.
For more detail about this class, check The Properties.
The Properties Class
Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key
is a String and the value is also a String.
The Properties class is used by many other Java classes. For example, it is the type of
object returned by System.getProperties( ) when obtaining environmental values.
Properties define the following instance variable. This variable holds a default property list
associated with a Properties object.
Properties defaults;
Following is the list of constructors provided by the properties class.
Sr. No.
1
Constructors and Description
Properties( )
This constructor creates a Properties object that has no default values.
Properties(Properties propDefault)
2
Creates an object that uses propDefault for its default values. In both cases,
the property list is empty.
366Java
Apart from the methods defined by Hashtable, Properties define the following methods:
Sr.
No.
Methods with Description
String getProperty(String key)
1
Returns the value associated with the key. A null object is returned if the key
is neither in the list nor in the default property list.
String getProperty(String key, String defaultProperty)
2
3
4
5
Returns the value associated with the key; defaultProperty is returned if the
key is neither in the list nor in the default property list.
void list(PrintStream streamOut)
Sends the property list to the output stream linked to streamOut.
void list(PrintWriter streamOut)
Sends the property list to the output stream linked to streamOut.
void load(InputStream streamIn) throws IOException
Inputs a property list from the input stream linked to streamIn.
Enumeration propertyNames( )
6
Returns an enumeration of the keys. This includes those keys found in the
default property list, too.
Object setProperty(String key, String value)
7
Associates value with the key. Returns the previous value associated with the
key, or returns null if no such association exists.
void store(OutputStream streamOut, String description)
8
After writing the string specified by description, the property list is written to
the output stream linked to streamOut.
367Java
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.*;
public class PropDemo {
public static void main(String args[]) {
Properties capitals = new Properties();
Set states;
String str;
capitals.put("Illinois", "Springfield");
capitals.put("Missouri", "Jefferson City");
capitals.put("Washington", "Olympia");
capitals.put("California", "Sacramento");
capitals.put("Indiana", "Indianapolis");
// Show all states and capitals in hashtable.
states = capitals.keySet(); // get set-view of keys
Iterator itr = states.iterator();
while(itr.hasNext()) {
str = (String) itr.next();
System.out.println("The capital of " +
str + " is " + capitals.getProperty(str) + ".");
}
System.out.println();
// look for state not in list -- specify default
str = capitals.getProperty("Florida", "Not Found");
System.out.println("The capital of Florida is "
+ str + ".");
}
}
368Java
This will produce the following result:
The capital of Missouri is Jefferson City.
The capital of Illinois is Springfield.
The capital of Indiana is Indianapolis.
The capital of California is Sacramento.
The capital of Washington is Olympia.
The capital of Florida is Not Found.
36929.
Java – Collections Framework
Java
Prior to Java 2, Java provided ad hoc classes such as Dictionary, Vector, Stack,
and Properties to store and manipulate groups of objects. Although these classes were
quite useful, they lacked a central, unifying theme. Thus, the way that you used Vector
was different from the way that you used Properties.
The collections framework was designed to meet several goals, such as:
 The framework had to be high-performance. The implementations for the
fundamental collections (dynamic arrays, linked lists, trees, and hashtables) were
to be highly efficient.
 The framework had to allow different types of collections to work in a similar
manner and with a high degree of interoperability.
 The framework had to extend and/or adapt a collection easily.
Towards this end, the entire collections framework is designed around a set of standard
interfaces.
Several
standard
implementations
such
as LinkedList,
HashSet, and TreeSet, of these interfaces are provided that you may use as-is and you
may also implement your own collection, if you choose.
A collections framework is a unified architecture for representing and manipulating
collections. All collections frameworks contain the following:
 Interfaces: These are abstract data types that represent collections. Interfaces
allow collections to be manipulated independently of the details of their
representation. In object-oriented languages, interfaces generally form a
hierarchy.
 Implementations, i.e., Classes: These are the concrete implementations of the
collection interfaces. In essence, they are reusable data structures.
 Algorithms: These are the methods that perform useful computations, such as
searching and sorting, on objects that implement collection interfaces. The
algorithms are said to be polymorphic: that is, the same method can be used on
many different implementations of the appropriate collection interface.
In addition to collections, the framework defines several map interfaces and classes. Maps
store key/value pairs. Although maps are not collections in the proper use of the term, but
they are fully integrated with collections.
370Java
The Collection Interfaces
The collections framework defines several interfaces. This section provides an overview of
each interface:
Sr.
No.
Interfaces with Description
The Collection Interface
1
This enables you to work with groups of objects; it is at the top of the collections
hierarchy.
The List Interface
2
This extends Collection and an instance of List stores an ordered collection of
elements.
The Set
3
This extends Collection to handle sets, which must contain unique elements.
The SortedSet
4
This extends Set to handle sorted sets.
The Map
5
This maps unique keys to values.
The Map.Entry
6
This describes an element (a key/value pair) in a map. This is an inner class of
Map.
The SortedMap
7
This extends Map so that the keys are maintained in an ascending order.
371Java
The Enumeration
8
This is legacy interface defines the methods by which you can enumerate
(obtain one at a time) the elements in a collection of objects. This legacy
interface has been superceded by Iterator.
The Collection Interface
The Collection interface is the foundation upon which the collections framework is built. It
declares the core methods that all collections will have. These methods are summarized
in the following table.
Because all collections implement Collection, familiarity with its methods is necessary for
a clear understanding of the framework. Several of these methods can throw
an UnsupportedOperationException.
Sr.
No.
Methods with Description
boolean add(Object obj)
1
Adds obj to the invoking collection. Returns true if obj was added to the
collection. Returns false if obj is already a member of the collection, or if the
collection does not allow duplicates.
boolean addAll(Collection c)
2
Adds all the elements of c to the invoking collection. Returns true if the operation
succeeds (i.e., the elements were added). Otherwise, returns false.
void clear( )
3
Removes all elements from the invoking collection.
boolean contains(Object obj)
4
Returns true if obj is an element of the invoking collection. Otherwise, returns
false.
boolean containsAll(Collection c)
5
Returns true if the invoking collection contains all elements of c. Otherwise,
returns false.
372Java
boolean equals(Object obj)
6
Returns true if the invoking collection and obj are equal. Otherwise, returns
false.
int hashCode( )
7
Returns the hash code for the invoking collection.
boolean isEmpty( )
8
Returns true if the invoking collection is empty. Otherwise, returns false.
Iterator iterator( )
9
Returns an iterator for the invoking collection.
boolean remove(Object obj)
10
Removes one instance of obj from the invoking collection. Returns true if the
element was removed. Otherwise, returns false.
boolean removeAll(Collection c)
11
Removes all elements of c from the invoking collection. Returns true if the
collection changed (i.e., elements were removed). Otherwise, returns false.
boolean retainAll(Collection c)
12
Removes all elements from the invoking collection except those in c. Returns
true if the collection changed (i.e., elements were removed). Otherwise,
returns false.
int size( )
13
Returns the number of elements held in the invoking collection.
Object[ ] toArray( )
14
Returns an array that contains all the elements stored in the invoking
collection. The array elements are copies of the collection elements.
Object[ ] toArray(Object array[ ])
15
Returns an array containing only those collection elements whose type
matches that of array.
373Java
Example
Following is an example to explain few methods from various class implementations of the
above collection methods:
import java.util.*;
public class CollectionsDemo {
public static void main(String[] args) {
//ArrayList
List a1 = new ArrayList();
a1.add("Zara");
a1.add("Mahnaz");
a1.add("Ayan");
System.out.println(" ArrayList Elements");
System.out.print("\t" + a1);
//LinkedList
List l1 = new LinkedList();
l1.add("Zara");
l1.add("Mahnaz");
l1.add("Ayan");
System.out.println();
System.out.println(" LinkedList Elements");
System.out.print("\t" + l1);
//HashSet
Set s1 = new HashSet();
s1.add("Zara");
s1.add("Mahnaz");
s1.add("Ayan");
System.out.println();
System.out.println(" Set Elements");
System.out.print("\t" + s1);
374Java
//HashMap
Map m1 = new HashMap();
m1.put("Zara", "8");
m1.put("Mahnaz", "31");
m1.put("Ayan", "12");
m1.put("Daisy", "14");
System.out.println();
System.out.println(" Map Elements");
System.out.print("\t" + m1);
}
}
This will produce the following result:
ArrayList Elements
[Zara, Mahnaz, Ayan]
LinkedList Elements
[Zara, Mahnaz, Ayan]
Set Elements
[Zara, Mahnaz, Ayan]
Map Elements
{Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
The List Interface
The List interface extends Collection and declares the behavior of a collection that stores
a sequence of elements.
 Elements can be inserted or accessed by their position in the list, using a zero-
based index.
 A list may contain duplicate elements.
 In addition to the methods defined by Collection, List defines some of its own,
which are summarized in the following table.
 Several of the list methods will throw an UnsupportedOperationException if the
collection cannot be modified, and a ClassCastException is generated when one
object is incompatible with another.
375Java
Sr. No.
Methods with Description
void add(int index, Object obj)
1
Inserts obj into the invoking list at the index passed in the index. Any pre-
existing elements at or beyond the point of insertion are shifted up. Thus,
no elements are overwritten.
boolean addAll(int index, Collection c)
2
Inserts all elements of c into the invoking list at the index passed in the
index. Any pre-existing elements at or beyond the point of insertion are
shifted up. Thus, no elements are overwritten. Returns true if the invoking
list changes and returns false otherwise.
Object get(int index)
3
Returns the object stored at the specified index within the invoking
collection.
int indexOf(Object obj)
4
Returns the index of the first instance of obj in the invoking list. If obj is
not an element of the list, .1 is returned.
int lastIndexOf(Object obj)
5
Returns the index of the last instance of obj in the invoking list. If obj is
not an element of the list, .1 is returned.
ListIterator listIterator( )
6
Returns an iterator to the start of the invoking list.
ListIterator listIterator(int index)
7
Returns an iterator to the invoking list that begins at the specified index.
Object remove(int index)
8
Removes the element at position index from the invoking list and returns
the deleted element. The resulting list is compacted. That is, the indexes
of subsequent elements are decremented by one.
Object set(int index, Object obj)
9
Assigns obj to the location specified by index within the invoking list.
List subList(int start, int end)
10
Returns a list that includes elements from start to end.1 in the invoking
list. Elements in the returned list are also referenced by the invoking object.
376Java
Example
The above interface has been implemented in various classes like ArrayList or LinkedList,
etc. Following is the example to explain few methods from various class implementation
of the above collection methods:
import java.util.*;
public class CollectionsDemo {
public static void main(String[] args) {
List a1 = new ArrayList();
a1.add("Zara");
a1.add("Mahnaz");
a1.add("Ayan");
System.out.println(" ArrayList Elements");
System.out.print("\t" + a1);
List l1 = new LinkedList();
l1.add("Zara");
l1.add("Mahnaz");
l1.add("Ayan");
System.out.println();
System.out.println(" LinkedList Elements");
System.out.print("\t" + l1);
}
}
This will produce the following result:
ArrayList Elements
[Zara, Mahnaz, Ayan]
LinkedList Elements
[Zara, Mahnaz, Ayan]
377Java
The Set Interface
A Set is a Collection that cannot contain duplicate elements. It models the mathematical
set abstraction.
The Set interface contains only methods inherited from Collection and adds the restriction
that duplicate elements are prohibited.
Set also adds a stronger contract on the behavior of the equals and hashCode operations,
allowing Set instances to be compared meaningfully even if their implementation types
differ.
The methods declared by Set are summarized in the following table:
Sr.
No.
Methods with Description
add( )
1
Adds an object to the collection.
clear( )
2
Removes all objects from the collection.
contains( )
3
Returns true if a specified object is an element within the collection.
isEmpty( )
4
Returns true if the collection has no elements.
iterator( )
5
Returns an Iterator object for the collection, which may be used to retrieve an
object.
remove( )
6
Removes a specified object from the collection.
size( )
7
Returns the number of elements in the collection.
378Java
Example
Set has its implementation in various classes like HashSet, TreeSet, LinkedHashSet.
Following is an example to explain Set functionality:
import java.util.*;
public class SetDemo {
public static void main(String args[]) {
int count[] = {34, 22,10,60,30,22};
Set<Integer> set = new HashSet<Integer>();
try{
for(int i = 0; i<5; i++){
set.add(count[i]);
}
System.out.println(set);
TreeSet sortedSet = new TreeSet<Integer>(set);
System.out.println("The sorted list is:");
System.out.println(sortedSet);
System.out.println("The First element of the set is: "+
(Integer)sortedSet.first());
System.out.println("The last element of the set is: "+
(Integer)sortedSet.last());
}
catch(Exception e){}
}
}
This will produce the following result:
[amrood]$ java SetDemo
[34, 30, 60, 10, 22]
The sorted list is:
[10, 22, 30, 34, 60]
The First element of the set is: 10
The last element of the set is: 60
379Java
The SortedSet Interface
The SortedSet interface extends Set and declares the behavior of a set sorted in an
ascending order. In addition to those methods defined by Set, the SortedSet interface
declares the methods summarized in the following table:
Several methods throw a NoSuchElementException when no items are contained in the
invoking set. A ClassCastException is thrown when an object is incompatible with the
elements in a set.
A NullPointerException is thrown if an attempt is made to use a null object and null is not
allowed in the set.
Sr.
No.
Methods with Description
Comparator comparator( )
1
Returns the invoking sorted set's comparator. If the natural ordering is used for
this set, null is returned.
Object first( )
2
Returns the first element in the invoking sorted set.
SortedSet headSet(Object end)
3
Returns a SortedSet containing those elements less than end that are contained
in the invoking sorted set. Elements in the returned sorted set are also
referenced by the invoking sorted set.
Object last( )
4
Returns the last element in the invoking sorted set.
SortedSet subSet(Object start, Object end)
5
Returns a SortedSet that includes those elements between start and end.1.
Elements in the returned collection are also referenced by the invoking object.
SortedSet tailSet(Object start)
6
Returns a SortedSet that contains those elements greater than or equal to start
that are contained in the sorted set. Elements in the returned set are also
referenced by the invoking object.
380Java
Example
SortedSet have its implementation in various classes like TreeSet. Following is an example
of a TreeSet class:
import java.util.*;
public class SortedSetTest {
public static void main(String[] args) {
// Create the sorted set
SortedSet set = new TreeSet();
// Add elements to the set
set.add("b");
set.add("c");
set.add("a");
// Iterating over the elements in the set
Iterator it = set.iterator();
while (it.hasNext()) {
// Get element
Object element = it.next();
System.out.println(element.toString());
}
}
}
This will produce the following result:
a
b
c
381Java
The Map Interface
The Map interface maps unique keys to values. A key is an object that you use to retrieve
a value at a later date.
 Given a key and a value, you can store the value in a Map object. After the value
is stored, you can retrieve it by using its key.
 Several methods throw a NoSuchElementException when no items exist in the
invoking map.
 A ClassCastException is thrown when an object is incompatible with the elements
in a map.
 A NullPointerException is thrown if an attempt is made to use a null object and null
is not allowed in the map.
 An UnsupportedOperationException is thrown when an attempt is made to change
an unmodifiable map.
Sr.
No.
Methods with Description
void clear( )
1
Removes all key/value pairs from the invoking map.
boolean containsKey(Object k)
2
Returns true if the invoking map contains k as a key. Otherwise, returns false.
boolean containsValue(Object v)
3
Returns true if the map contains v as a value. Otherwise, returns false.
Set entrySet( )
4
Returns a Set that contains the entries in the map. The set contains objects of
type Map.Entry. This method provides a set-view of the invoking map.
boolean equals(Object obj)
5
Returns true if obj is a Map and contains the same entries. Otherwise, returns
false.
Object get(Object k)
6
Returns the value associated with the key k.
382Java
int hashCode( )
7
Returns the hash code for the invoking map.
boolean isEmpty( )
8
Returns true if the invoking map is empty. Otherwise, returns false.
Set keySet( )
9
Returns a Set that contains the keys in the invoking map. This method provides
a set-view of the keys in the invoking map.
Object put(Object k, Object v)
10
Puts an entry in the invoking map, overwriting any previous value associated
with the key. The key and value are k and v, respectively. Returns null if the
key did not already exist. Otherwise, the previous value linked to the key is
returned.
void putAll(Map m)
11
Puts all the entries from m into this map.
Object remove(Object k)
12
Removes the entry whose key equals k.
int size( )
13
Returns the number of key/value pairs in the map.
Collection values( )
14
Returns a collection containing the values in the map. This method provides a
collection-view of the values in the map.
Example
Map has its implementation in various classes like HashMap. Following is an example to
explain map functionality:
import java.util.*;
public class CollectionsDemo {
public static void main(String[] args) {
Map m1 = new HashMap();
m1.put("Zara", "8");
m1.put("Mahnaz", "31");
m1.put("Ayan", "12");
383Java
m1.put("Daisy", "14");
System.out.println();
System.out.println(" Map Elements");
System.out.print("\t" + m1);
}
}
This will produce the following result:
ap Elements
{Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
The Map.Entry Interface
The Map.Entry interface enables you to work with a map entry.
The entrySet( ) method declared by the Map interface returns a Set containing the map
entries. Each of these set elements is a Map.Entry object.
Following table summarizes the methods declared by this interface:
Sr.
No.
Methods with Description
boolean equals(Object obj)
1
Returns true if obj is a Map.Entry whose key and value are equal to that of the
invoking object.
Object getKey( )
2
Returns the key for this map entry.
Object getValue( )
3
Returns the value for this map entry.
int hashCode( )
4
Returns the hash code for this map entry.
Object setValue(Object v)
5
Sets the value for this map entry to v. A ClassCastException is thrown if v is not
the correct type for the map. A NullPointerException is thrown if v is null and the
map does not permit null keys. An UnsupportedOperationException is thrown if
the map cannot be changed.
384Java
Example
Following is an example showing how Map.Entry can be used:
import java.util.*;
public class HashMapDemo {
public static void main(String args[]) {
// Create a hash map
HashMap hm = new HashMap();
// Put elements to the map
hm.put("Zara", new Double(3434.34));
hm.put("Mahnaz", new Double(123.22));
hm.put("Ayan", new Double(1378.00));
hm.put("Daisy", new Double(99.22));
hm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = hm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)hm.get("Zara")).doubleValue();
hm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
hm.get("Zara"));
}
}
385Java
This will produce the following result:
Daisy 99.22
Qadir: -19.08
Zara: 3434.34
Ayan: 1378.0
ahnaz: 123.22
Zara's new balance: 4434.34
The SortedMap Interface
The SortedMap interface extends Map. It ensures that the entries are maintained in an
ascending key order.
Several methods throw a NoSuchElementException when no items are in the invoking
map. A ClassCastException is thrown when an object is incompatible with the elements in
a map. A NullPointerException is thrown if an attempt is made to use a null object when
null is not allowed in the map.
The methods declared by SortedMap are summarized in the following table:
Sr.
No.
Methods with Description
Comparator comparator( )
1
Returns the invoking sorted map's comparator. If the natural ordering is used
for the invoking map, null is returned.
Object firstKey( )
2
Returns the first key in the invoking map.
SortedMap headMap(Object end)
3
Returns a sorted map for those map entries with keys that are less than end.
Object lastKey( )
4
Returns the last key in the invoking map.
SortedMap subMap(Object start, Object end)
5
Returns a map containing those entries with keys that are greater than or equal
to start and less than end.
SortedMap tailMap(Object start)
6
Returns a map containing those entries with keys that are greater than or equal
to start.
386Java
Example
SortedMap has its implementation in various classes like TreeMap. Following is the
example to explain SortedMap functionlaity:
import java.util.*;
public class TreeMapDemo {
public static void main(String args[]) {
// Create a hash map
TreeMap tm = new TreeMap();
// Put elements to the map
tm.put("Zara", new Double(3434.34));
tm.put("Mahnaz", new Double(123.22));
tm.put("Ayan", new Double(1378.00));
tm.put("Daisy", new Double(99.22));
tm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = tm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)tm.get("Zara")).doubleValue();
tm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
tm.get("Zara"));
}
}
387Java
This will produce the following result:
Ayan: 1378.0
Daisy 99.22
ahnaz: 123.22
Qadir: -19.08
Zara: 3434.34
Zara.s current balance: 4434.34
The Enumeration Interface
The Enumeration interface defines the methods by which you can enumerate (obtain one
at a time) the elements in a collection of objects.
This legacy interface has been superceded by Iterator. Although not deprecated,
Enumeration is considered obsolete for new code. However, it is used by several methods
defined by the legacy classes such as Vector and Properties, is used by several other API
classes, and is currently in widespread use in application code.
The methods declared by Enumeration are summarized in the following table:
Sr.
No.
Methods with Description
boolean hasMoreElements( )
1
When implemented, it must return true while there are still more elements to
extract, and false when all the elements have been enumerated.
Object nextElement( )
2
This returns the next object in the enumeration as a generic Object reference.
Example
Following is an example showing usage of Enumeration.
import java.util.Vector;
import java.util.Enumeration;
public class EnumerationTester {
public static void main(String args[]) {
Enumeration days;
388Java
Vector dayNames = new Vector();
dayNames.add("Sunday");
dayNames.add("Monday");
dayNames.add("Tuesday");
dayNames.add("Wednesday");
dayNames.add("Thursday");
dayNames.add("Friday");
dayNames.add("Saturday");
days = dayNames.elements();
while (days.hasMoreElements()){
System.out.println(days.nextElement());
}
}
}
This will produce the following result:
Sunday
onday
Tuesday
Wednesday
Thursday
Friday
Saturday
The Collection Classes
Java provides a set of standard collection classes that implement Collection interfaces.
Some of the classes provide full implementations that can be used as-is and others are
abstract class, providing skeletal implementations that are used as starting points for
creating concrete collections.
389Java
The standard collection classes are summarized in the following table:
Sr. No.
Classes with Description
AbstractCollection
1
Implements most of the Collection interface.
AbstractList
2
Extends AbstractCollection and implements most of the List interface.
AbstractSequentialList
3
Extends AbstractList for use by a collection that uses sequential rather than
random access of its elements.
LinkedList
4
Implements a linked list by extending AbstractSequentialList.
ArrayList
5
Implements a dynamic array by extending AbstractList.
AbstractSet
6
Extends AbstractCollection and implements most of the Set interface.
HashSet
7
Extends AbstractSet for use with a hash table.
LinkedHashSet
8
Extends HashSet to allow insertion-order iterations.
TreeSet
9
Implements a set stored in a tree. Extends AbstractSet.
390Java
AbstractMap
10
Implements most of the Map interface.
HashMap
11
Extends AbstractMap to use a hash table.
TreeMap
12
Extends AbstractMap to use a tree.
WeakHashMap
13
Extends AbstractMap to use a hash table with weak keys.
LinkedHashMap
14
Extends HashMap to allow insertion-order iterations.
IdentityHashMap
15
Extends AbstractMap
documents.
and
uses
reference
equality
when
comparing
The AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList and AbstractMap
classes provide skeletal implementations of the core collection interfaces, to minimize the
effort required to implement them.
The LinkedList Class
The LinkedList class extends AbstractSequentialList and implements the List interface. It
provides a linked-list data structure.
Following are the constructors supported by the LinkedList class.
Sr.
No.
Constructors and Description
LinkedList( )
1
This constructor builds an empty linked list.
LnkedList(Collection c)
2
This constructor builds a linked list that is initialized with the elements of the
collection c.
391Java
Apart from the methods inherited from its parent classes, LinkedList defines the following
methods:
Sr.
No.
Methods with Description
void add(int index, Object element)
1
Inserts the specified element at the specified position index in this list. Throws
IndexOutOfBoundsException if the specified index is out of range (index < 0
|| index > size()).
boolean add(Object o)
2
Appends the specified element to the end of this list.
boolean addAll(Collection c)
3
Appends all of the elements in the specified collection to the end of this list, in
the order that they are returned by the specified collection's iterator. Throws
NullPointerException if the specified collection is null.
boolean addAll(int index, Collection c)
4
Inserts all of the elements in the specified collection into this list, starting at
the specified position. Throws NullPointerException if the specified collection is
null.
void addFirst(Object o)
5
Inserts the given element at the beginning of this list.
void addLast(Object o)
6
Appends the given element to the end of this list.
void clear()
7
Removes all of the elements from this list.
Object clone()
8
Returns a shallow copy of this LinkedList.
boolean contains(Object o)
9
Returns true if this list contains the specified element. More formally, returns
true if and only if this list contains at least one element e such that (o==null
? e==null : o.equals(e)).
392Java
Object get(int index)
10
Returns the element at the specified position in this list. Throws
IndexOutOfBoundsException if the specified index is out of range (index < 0
|| index >= size()).
Object getFirst()
11
Returns the first element in this list. Throws NoSuchElementException if this
list is empty.
Object getLast()
12
Returns the last element in this list. Throws NoSuchElementException if this
list is empty.
int indexOf(Object o)
13
Returns the index in this list of the first occurrence of the specified element,
or -1 if the list does not contain this element.
int lastIndexOf(Object o)
14
Returns the index in this list of the last occurrence of the specified element, or
-1 if the list does not contain this element.
ListIterator listIterator(int index)
15
Returns a list-iterator of the elements in this list (in proper sequence), starting
at the specified position in the list. Throws IndexOutOfBoundsException if the
specified index is out of range (index < 0 || index >= size()).
Object remove(int index)
16
Removes the element at the specified position in this list. Throws
NoSuchElementException if this list is empty.
boolean remove(Object o)
17
Removes the first occurrence of the specified element in this list. Throws
NoSuchElementException
if
this
list
is
empty.
Throws
IndexOutOfBoundsException if the specified index is out of range (index < 0
|| index >= size()).
Object removeFirst()
18
Removes and returns the first element
NoSuchElementException if this list is empty.
from this list. Throws
from this list. Throws
Object removeLast()
19
Removes and returns the last element
NoSuchElementException if this list is empty.
393Java
Object set(int index, Object element)
20
Replaces the element at the specified position in this list with the specified
element. Throws IndexOutOfBoundsException if the specified index is out of
range (index < 0 || index >= size()).
int size()
21
Returns the number of elements in this list.
Object[] toArray()
22
Returns an array containing all of the elements in this list in the correct order.
Throws NullPointerException if the specified array is null.
Object[] toArray(Object[] a)
23
Returns an array containing all of the elements in this list in the correct order;
the runtime type of the returned array is that of the specified array.
Example
The following program illustrates several of the methods supported by LinkedList:
import java.util.*;
public class LinkedListDemo {
public static void main(String args[]) {
// create a linked list
LinkedList ll = new LinkedList();
// add elements to the linked list
ll.add("F");
ll.add("B");
ll.add("D");
ll.add("E");
ll.add("C");
ll.addLast("Z");
ll.addFirst("A");
ll.add(1, "A2");
System.out.println("Original contents of ll: " + ll);
394Java
// remove elements from the linked list
ll.remove("F");
ll.remove(2);
System.out.println("Contents of ll after deletion: "
+ ll);
// remove first and last elements
ll.removeFirst();
ll.removeLast();
System.out.println("ll after deleting first and last: "
+ ll);
// get and set a value
Object val = ll.get(2);
ll.set(2, (String) val + " Changed");
System.out.println("ll after change: " + ll);
}
}
This will produce the following result:
Original contents of ll: [A, A2, F, B, D, E, C, Z]
Contents of ll after deletion: [A, A2, D, E, C, Z]
ll after deleting first and last: [A2, D, E, C]
ll after change: [A2, D, E Changed, C]
The ArrayList Class
The ArrayList class extends AbstractList and implements the List interface. ArrayList
supports dynamic arrays that can grow as needed.
Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or
shrink, which means that you must know in advance how many elements an array will
hold.
Array lists are created with an initial size. When this size is exceeded, the collection is
automatically enlarged. When objects are removed, the array may be shrunk.
395Java
Following is the list of the constructors provided by the ArrayList class.
Sr.
No.
Constructors and Description
ArrayList( )
1
This constructor builds an empty array list.
ArrayList(Collection c)
2
This constructor builds an array list that is initialized with the elements of the
collection c.
ArrayList(int capacity)
3
This constructor builds an array list that has the specified initial capacity. The
capacity is the size of the underlying array that is used to store the elements.
The capacity grows automatically as elements are added to an array list.
Apart from the methods inherited from its parent classes, ArrayList defines the following
methods:
Sr.
No.
Methods with Description
void add(int index, Object element)
1
Inserts the specified element at the specified position index in this list. Throws
IndexOutOfBoundsException if the specified index is out of range (index < 0 ||
index > size()).
boolean add(Object o)
2
Appends the specified element to the end of this list.
boolean addAll(Collection c)
3
Appends all of the elements in the specified collection to the end of this list, in
the order that they are returned by the specified collection's iterator. Throws
NullPointerException, if the specified collection is null.
boolean addAll(int index, Collection c)
4
Inserts all of the elements in the specified collection into this list, starting at the
specified position. Throws NullPointerException if the specified collection is null.
void clear()
5
Removes all of the elements from this list.
396Java
Object clone()
6
Returns a shallow copy of this ArrayList.
boolean contains(Object o)
7
Returns true if this list contains the specified element. More formally, returns
true if and only if this list contains at least one element e such that (o==null ?
e==null : o.equals(e)).
void ensureCapacity(int minCapacity)
8
Increases the capacity of this ArrayList instance, if necessary, to ensure that it
can hold at least the number of elements specified by the minimum capacity
argument.
Object get(int index)
9
Returns the element at the specified position in this list. Throws
IndexOutOfBoundsException if the specified index is out of range (index < 0 ||
index >= size()).
int indexOf(Object o)
10
Returns the index in this list of the first occurrence of the specified element, or
-1 if the List does not contain this element.
int lastIndexOf(Object o)
11
Returns the index in this list of the last occurrence of the specified element, or -
1 if the list does not contain this element.
Object remove(int index)
12
Removes the element at the specified position in this list. Throws
IndexOutOfBoundsException if the index is out of range (index < 0 || index >=
size()).
protected void removeRange(int fromIndex, int toIndex)
13
Removes from this List all of the elements whose index is between fromIndex,
inclusive and toIndex, exclusive.
Object set(int index, Object element)
14
Replaces the element at the specified position in this list with the specified
element. Throws IndexOutOfBoundsException if the specified index is out of
range (index < 0 || index >= size()).
int size()
15
Returns the number of elements in this list.
397Java
Object[] toArray()
16
Returns an array containing all of the elements in this list in the correct order.
Throws NullPointerException if the specified array is null.
Object[] toArray(Object[] a)
17
Returns an array containing all of the elements in this list in the correct order;
the runtime type of the returned array is that of the specified array.
void trimToSize()
18
Trims the capacity of this ArrayList instance to be the list's current size.
Example
The following program illustrates several of the methods supported by ArrayList:
import java.util.*;
public class ArrayListDemo {
public static void main(String args[]) {
// create an array list
ArrayList al = new ArrayList();
System.out.println("Initial size of al: " + al.size());
// add elements to the array list
al.add("C");
al.add("A");
al.add("E");
al.add("B");
al.add("D");
al.add("F");
al.add(1, "A2");
System.out.println("Size of al after additions: " + al.size());
398Java
// display the array list
System.out.println("Contents of al: " + al);
// Remove elements from the array list
al.remove("F");
al.remove(2);
System.out.println("Size of al after deletions: " + al.size());
System.out.println("Contents of al: " + al);
}
}
This will produce the following result:
Initial size of al: 0
Size of al after additions: 7
Contents of al: [C, A2, A, E, B, D, F]
Size of al after deletions: 5
Contents of al: [C, A2, E, B, D]
The HashSet Class
HashSet extends AbstractSet and implements the Set interface. It creates a collection that
uses a hash table for storage.
A hash table stores information by using a mechanism called hashing. In hashing, the
informational content of a key is used to determine a unique value, called its hash code.
The hash code is then used as the index at which the data associated with the key is
stored. The transformation of the key into its hash code is performed automatically.
399Java
Following is the list of constructors provided by the HashSet class.
Sr. No.
Constructors and Description
HashSet( )
1
This constructor constructs a default HashSet.
HashSet(Collection c)
2
This constructor initializes the hash set by using the elements of the collection
c.
HashSet(int capacity)
3
This constructor initializes the capacity of the hash set to the given integer
value capacity. The capacity grows automatically as elements are added to
the HashSet.
HashSet(int capacity, float fillRatio)
This constructor initializes both the capacity and the fill ratio (also called load
capacity) of the hash set from its arguments.
4
Here the fill ratio must be between 0.0 and 1.0, and it determines how full
the hash set can be before it is resized upward. Specifically, when the number
of elements is greater than the capacity of the hash set multiplied by its fill
ratio, the hash set is expanded.
Apart from the methods inherited from its parent classes, HashSet defines following
methods:
Sr.
No.
Methods with Description
boolean add(Object o)
1
Adds the specified element to this set if it is not already present.
void clear()
2
Removes all of the elements from this set.
Object clone()
3
Returns a shallow copy of this HashSet instance: the elements themselves are
not cloned.
boolean contains(Object o)
4
Returns true if this set contains the specified element.
400Java
boolean isEmpty()
5
Returns true if this set contains no elements.
Iterator iterator()
6
Returns an iterator over the elements in this set.
boolean remove(Object o)
7
Removes the specified element from this set if it is present.
int size()
8
Returns the number of elements in this set (its cardinality).
Example
The following program illustrates several of the methods supported by HashSet:
import java.util.*;
public class HashSetDemo {
public static void main(String args[]) {
// create a hash set
HashSet hs = new HashSet();
// add elements to the hash set
hs.add("B");
hs.add("A");
hs.add("D");
hs.add("E");
hs.add("C");
hs.add("F");
System.out.println(hs);
}
}
This will produce the following result:
[A, B, C, D, E, F]
401Java
The LinkedHashSet Class
This class extends HashSet, but adds no members of its own.
LinkedHashSet maintains a linked list of the entries in the set, in the order in which they
were inserted. This allows insertion-order iteration over the set.
That is, when cycling through a LinkedHashSet using an iterator, the elements will be
returned in the order in which they were inserted.
The hash code is then used as the index at which the data associated with the key is
stored. The transformation of the key into its hash code is performed automatically.
Following is the list of constructors supported by the LinkedHashSet.
Sr.
No.
Constructors and Description
HashSet( )
1
This constructor constructs a default HashSet.
HashSet(Collection c)
2
This constructor initializes the hash set by using the elements of the collection
c.
LinkedHashSet(int capacity)
3
This constructor initializes the capacity of the linkedhashset to the given integer
value capacity. The capacity grows automatically as elements are added to the
HashSet.
LinkedHashSet(int capacity, float fillRatio)
4
This constructor initializes both the capacity and the fill ratio (also called load
capacity) of the hash set from its arguments.
Example
The following program illustrates several of the methods supported by LinkedHashSet:
import java.util.*;
public class HashSetDemo {
public static void main(String args[]) {
// create a hash set
402Java
LinkedHashSet hs = new LinkedHashSet();
// add elements to the hash set
hs.add("B");
hs.add("A");
hs.add("D");
hs.add("E");
hs.add("C");
hs.add("F");
System.out.println(hs);
} }
This will produce the following result:
[B, A, D, E, C
The TreeSet Class
TreeSet provides an implementation of the Set interface that uses a tree for storage.
Objects are stored in a sorted and ascending order.
Access and retrieval times are quite fast, which makes TreeSet an excellent choice when
storing large amounts of sorted information that must be found quickly.
Following is the list of the constructors supported by the TreeSet class.
Sr.
No.
Constructors with Description
TreeSet( )
1
This constructor constructs an empty tree set that will be sorted in an ascending
order according to the natural order of its elements.
TreeSet(Collection c)
2
This constructor builds a tree set that contains the elements of the collection c.
TreeSet(Comparator comp)
3
This constructor constructs an empty tree set that will be sorted according to
the given comparator.
403Java
TreeSet(SortedSet ss)
4
This constructor builds a TreeSet that contains the elements of the given
SortedSet.
Apart from the methods inherited from its parent classes, TreeSet defines the following
methods:
Sr. No.
Methods with Description
void add(Object o)
1
Adds the specified element to this set if it is not already present.
boolean addAll(Collection c)
2
Adds all of the elements in the specified collection to this set.
void clear()
3
Removes all of the elements from this set.
Object clone()
4
Returns a shallow copy of this TreeSet instance.
Comparator comparator()
5
Returns the comparator used to order this sorted set, or null if this tree set
uses its elements natural ordering.
boolean contains(Object o)
6
Returns true if this set contains the specified element.
Object first()
7
Returns the first (lowest) element currently in this sorted set.
SortedSet headSet(Object toElement)
8
Returns a view of the portion of this set whose elements are strictly less than
toElement.
boolean isEmpty()
9
Returns true if this set contains no elements.
Iterator iterator()
10
Returns an iterator over the elements in this set.
404Java
Object last()
11
Returns the last (highest) element currently in this sorted set.
boolean remove(Object o)
12
Removes the specified element from this set if it is present.
int size()
13
Returns the number of elements in this set (its cardinality).
SortedSet subSet(Object fromElement, Object toElement)
14
Returns a view of the portion of this set whose elements range from
fromElement, inclusive, to toElement, exclusive.
SortedSet tailSet(Object fromElement)
15
Returns a view of the portion of this set whose elements are greater than or
equal to fromElement.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class TreeSetDemo {
public static void main(String args[]) {
// Create a tree set
TreeSet ts = new TreeSet();
// Add elements to the tree set
ts.add("C");
ts.add("A");
ts.add("B");
ts.add("E");
ts.add("F");
ts.add("D");
System.out.println(ts);
}
}
405Java
This will produce the following result:
[A, B, C, D, E, F]
The HashMap Class
The HashMap class uses a hashtable to implement the Map interface. This allows the
execution time of basic operations, such as get( ) and put( ), to remain constant even for
large sets.
Following is the list of constructors supported by the HashMap class.
Sr.
No.
Constructors and Description
HashMap( )
1
This constructor constructs a default HashMap.
HashMap(Map m)
2
This constructor initializes the hash map by using the elements of the given
Map object m.
HashMap(int capacity)
3
This constructor initializes the capacity of the hash map to the given integer
value, capacity.
HashMap(int capacity, float fillRatio)
4
This constructor initializes both the capacity and fill ratio of the hash map by
using its arguments.
Apart from the methods inherited from its parent classes, HashMap defines the following
methods:
Sr. No.
Methods with Description
void clear()
1
Removes all mappings from this map.
Object clone()
2
Returns a shallow copy of this HashMap instance: the keys and values
themselves are not cloned.
406Java
boolean containsKey(Object key)
3
Returns true if this map contains a mapping for the specified key.
boolean containsValue(Object value)
4
Returns true if this map maps one or more keys to the specified value.
Set entrySet()
5
Returns a collection view of the mappings contained in this map.
Object get(Object key)
6
Returns the value to which the specified key is mapped in this identity hash
map, or null if the map contains no mapping for this key.
boolean isEmpty()
7
Returns true if this map contains no key-value mappings.
Set keySet()
8
Returns a set view of the keys contained in this map.
Object put(Object key, Object value)
9
Associates the specified value with the specified key in this map.
putAll(Map m)
10
Copies all of the mappings from the specified map to this map. These
mappings will replace any mappings that this map had for any of the keys
currently in the specified map.
Object remove(Object key)
11
Removes the mapping for this key from this map if present.
int size()
12
Returns the number of key-value mappings in this map.
Collection values()
13
Returns a collection view of the values contained in this map.
407Java
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class HashMapDemo {
public static void main(String args[]) {
// Create a hash map
HashMap hm = new HashMap();
// Put elements to the map
hm.put("Zara", new Double(3434.34));
hm.put("Mahnaz", new Double(123.22));
hm.put("Ayan", new Double(1378.00));
hm.put("Daisy", new Double(99.22));
hm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = hm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)hm.get("Zara")).doubleValue();
hm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
hm.get("Zara"));
}
}
408Java
This will produce the following result:
Zara: 3434.34
ahnaz: 123.22
Daisy: 99.22
Ayan: 1378.0
Qadir: -19.08
Zara's new balance: 4434.34
The TreeMap Class
The TreeMap class implements the Map interface by using a tree. A TreeMap provides an
efficient means of storing key/value pairs in sorted order, and allows rapid retrieval.
You should note that, unlike a hash map, a tree map guarantees that its elements will be
sorted in an ascending key order.
Following is the list of the constructors supported by the TreeMap class.
Sr.
No.
Constructors and Description
TreeMap( )
1
This constructor constructs an empty tree map that will be sorted using the
natural order of its keys.
TreeMap(Comparator comp)
2
This constructor constructs an empty tree-based map that will be sorted using
the Comparator comp.
TreeMap(Map m)
3
This constructor initializes a tree map with the entries from m, which will be
sorted using the natural order of the keys.
TreeMap(SortedMap sm)
4
This constructor initializes a tree map with the entries from the SortedMap sm,
which will be sorted in the same order as sm.
409Java
Apart from the methods inherited from its parent classes, TreeMap defines the following
methods:
Sr. No.
Methods with Description
void clear()
1
Removes all mappings from this TreeMap.
Object clone()
2
Returns a shallow copy of this TreeMap instance.
Comparator comparator()
3
Returns the comparator used to order this map, or null if this map uses its
keys' natural order.
boolean containsKey(Object key)
4
Returns true if this map contains a mapping for the specified key.
boolean containsValue(Object value)
5
Returns true if this map maps one or more keys to the specified value.
Set entrySet()
6
Returns a set view of the mappings contained in this map.
Object firstKey()
7
Returns the first (lowest) key currently in this sorted map.
Object get(Object key)
8
Returns the value to which this map maps the specified key.
SortedMap headMap(Object toKey)
9
Returns a view of the portion of this map whose keys are strictly less than
toKey.
Set keySet()
10
Returns a Set view of the keys contained in this map.
Object lastKey()
11
Returns the last (highest) key currently in this sorted map.
Object put(Object key, Object value)
12
Associates the specified value with the specified key in this map.
void putAll(Map map)
13
Copies all of the mappings from the specified map to this map.
410Java
Object remove(Object key)
14
Removes the mapping for this key from this TreeMap if present.
int size()
15
Returns the number of key-value mappings in this map.
SortedMap subMap(Object fromKey, Object toKey)
16
Returns a view of the portion of this map whose keys range from fromKey,
inclusive, to toKey, exclusive.
SortedMap tailMap(Object fromKey)
17
Returns a view of the portion of this map whose keys are greater than or
equal to fromKey.
Collection values()
18
Returns a collection view of the values contained in this map.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class TreeMapDemo {
public static void main(String args[]) {
// Create a hash map
TreeMap tm = new TreeMap();
// Put elements to the map
tm.put("Zara", new Double(3434.34));
tm.put("Mahnaz", new Double(123.22));
tm.put("Ayan", new Double(1378.00));
tm.put("Daisy", new Double(99.22));
tm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = tm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
411Java
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)tm.get("Zara")).doubleValue();
tm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
tm.get("Zara"));
} }
This will produce the following result:
Ayan: 1378.0
Daisy 99.22
ahnaz: 123.22
Qadir: -19.08
Zara: 3434.34
Zara's current balance: 4434.34
The WeakHashMap Class
WeakHashMap is an implementation of the Map interface that stores only weak references
to its keys. Storing only weak references allows a key-value pair to be garbage-collected
when its key is no longer referenced outside of the WeakHashMap.
This class provides the easiest way to harness the power of weak references. It is useful
for implementing "registry-like" data structures, where the utility of an entry vanishes
when its key is no longer reachable by any thread.
The WeakHashMap functions identically to the HashMap with one very important
exception: if the Java memory manager no longer has a strong reference to the object
specified as a key, then the entry in the map will be removed.
Weak Reference: If the only references to an object are weak references, the garbage
collector can reclaim the object's memory at any time.it doesn't have to wait until the
system runs out of memory. Usually, it will be freed the next time the garbage collector
runs.
412Java
Following is the list of constructors supported by the WeakHashMap class.
Sr. No.
Constructors and Description
WeakHashMap()
1
This constructor constructs a new, empty WeakHashMap with the default
initial capacity (16) and the default load factor (0.75).
WeakHashMap(int initialCapacity)
2
This constructor constructs a new, empty WeakHashMap with the given initial
capacity and the default load factor, which is 0.75.
WeakHashMap(int initialCapacity, float loadFactor)
3
This constructor constructs a new, empty WeakHashMap with the given initial
capacity and the given load factor.
WeakHashMap(Map t)
4
This constructor constructs a new WeakHashMap with the same mappings as
the specified Map.
Apart from the methods inherited from its parent classes, TreeMap defines the following
methods:
Sr. No.
Methods with Description
void clear()
1
Removes all mappings from this map.
boolean containsKey(Object key)
2
Returns true if this map contains a mapping for the specified key.
boolean containsValue(Object value)
3
Returns true if this map maps one or more keys to the specified value.
Set entrySet()
4
Returns a collection view of the mappings contained in this map.
Object get(Object key)
5
Returns the value to which the specified key is mapped in this weak hash
map, or null if the map contains no mapping for this key.
boolean isEmpty()
6
Returns true if this map contains no key-value mappings.
413Java
Set keySet()
7
Returns a set view of the keys contained in this map.
Object put(Object key, Object value)
8
Associates the specified value with the specified key in this map.
void putAll(Map m)
Copies all of the mappings from the specified map to this map. These
mappings will replace any mappings that this map had for any of the keys
currently in the specified map.
9
Object remove(Object key)
10
Removes the mapping for this key from this map if present.
int size()
11
Returns the number of key-value mappings in this map.
Collection values()
12
Returns a collection view of the values contained in this map.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class WeakHashMap_Demo {
private static Map map;
public static void main (String args[]) {
map = new WeakHashMap();
map.put(new String("Maine"), "Augusta");
Runnable runner = new Runnable() {
public void run() {
while (map.containsKey("Maine")) {
try {
Thread.sleep(500);
} catch (InterruptedException ignored) {
}
System.out.println("Thread waiting");
System.gc();
}
}
414Java
};
Thread t = new Thread(runner);
t.start();
System.out.println("Main waiting");
try {
t.join();
} catch (InterruptedException ignored) {
}
}
}
This will produce the following result:
ain waiting
Thread waiting
If you do not include the call to System.gc(), the system may never run the garbage
collector as not much memory is used by the program. For a more active program, the
call would be unnecessary.
The LinkedHashMap Class
This class extends HashMap and maintains a linked list of the entries in the map, in the
order in which they were inserted. This allows insertion-order iteration over the map. That
is, when iterating a LinkedHashMap, the elements will be returned in the order in which
they were inserted.
You can also create a LinkedHashMap that returns its elements in the order in which they
were last accessed.
Following is the list of constructors supported by the LinkedHashMap class.
Sr.
No.
Constructors and Description
LinkedHashMap( )
1
This constructor constructs a default LinkedHashMap.
LinkedHashMap(Map m)
2
This constructor initializes the LinkedHashMap with the elements from the
given Map class m.
415Java
LinkedHashMap(int capacity)
3
This constructor initializes a LinkedHashMap with the given capacity.
LinkedHashMap(int capacity, float fillRatio)
4
This constructor initializes both the capacity and the fill ratio. The meaning of
capacity and fill ratio are the same as for HashMap.
LinkedHashMap(int capacity, float fillRatio, boolean Order)
This constructor allows you to specify whether the elements will be stored in
the linked list by insertion order, or by order of last access. If Order is true,
then access order is used. If Order is false, then insertion order is used.
5
Apart from the methods inherited from its parent classes, LinkedHashMap defines the
following methods:
Sr. No.
Methods with Description
void clear()
1
Removes all mappings from this map.
boolean containsKey(Object key)
2
Returns true if this map maps one or more keys to the specified value.
Object get(Object key)
3
Returns the value to which this map maps the specified key.
protected boolean removeEldestEntry(Map.Entry eldest)
4
Returns true if this map should remove its eldest entry.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class LinkedHashMapDemo {
public static void main(String args[]) {
// Create a hash map
LinkedHashMap lhm = new LinkedHashMap();
416Java
// Put elements to the map
lhm.put("Zara", new Double(3434.34));
lhm.put("Mahnaz", new Double(123.22));
lhm.put("Ayan", new Double(1378.00));
lhm.put("Daisy", new Double(99.22));
lhm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = lhm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)lhm.get("Zara")).doubleValue();
lhm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
lhm.get("Zara"));
}
}
417Java
This will produce the following result:
Zara: 3434.34
ahnaz: 123.22
Ayan: 1378.0
Daisy: 99.22
Qadir: -19.08
Zara's new balance: 4434.34
The IdentityHashMap Class
This class implements AbstractMap. It is similar to HashMap except that it uses reference
equality when comparing the elements.
This class is not a general-purpose Map implementation. While this class implements the
Map interface, it intentionally violates Map's general contract, which mandates the use of
the equals method when comparing objects.
This class is designed for use only in rare cases wherein reference-equality semantics are
required. This class provides constant-time performance for the basic operations (get and
put), assuming the system identity hash function (System.identityHashCode(Object))
disperses elements properly among the buckets.
This class has one tuning parameter (which affects performance but not semantics):
expected maximum size. This parameter is the maximum number of key-value mappings
that the map is expected to hold.
Following is the list of the constructors supported by the IdentityHashMap.
Sr.
No.
Constructors and Description
IdentityHashMap()
1
This constructor constructs a new, empty identity hash map with a default
expected maximum size (21).
IdentityHashMap(int expectedMaxSize)
2
This constructor constructs a new, empty IdentityHashMap with the specified
expected maximum size.
IdentityHashMap(Map m)
3
This constructor constructs a new identity hash map containing the keys-value
mappings in the specified map.
418Java
Apart from the methods inherited from its parent classes, IdentityHashMap defines the
following methods:
Sr.
No.
Methods with Description
void clear()
1
Removes all mappings from this map.
Object clone()
2
Returns a shallow copy of this identity hash map: the keys and values
themselves are not cloned.
boolean containsKey(Object key)
3
Tests whether the specified object reference is a key in this identity hash map.
boolean containsValue(Object value)
4
Tests whether the specified object reference is a value in this identity hash
map.
Set entrySet()
5
Returns a set view of the mappings contained in this map.
boolean equals(Object o)
6
Compares the specified object with this map for equality.
Object get(Object key)
7
Returns the value to which the specified key is mapped in this identity hash
map, or null if the map contains no mapping for this key.
int hashCode()
8
Returns the hash code value for this map.
boolean isEmpty()
9
Returns true if this identity hash map contains no key-value mappings.
Set keySet()
10
Returns an identity-based set view of the keys contained in this map.
Object put(Object key, Object value)
11
Associates the specified value with the specified key in this identity hash map.
419Java
void putAll(Map t)
12
Copies all of the mappings from the specified map to this map. These mappings
will replace any mappings that this map had for any of the keys currently in
the specified map.
Object remove(Object key)
13
Removes the mapping for this key from this map if present.
int size()
14
Returns the number of key-value mappings in this identity hash map.
Collection values()
15
Returns a collection view of the values contained in this map.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class IdentityHashMapDemo {
public static void main(String args[]) {
// Create a hash map
IdentityHashMap ihm = new IdentityHashMap();
// Put elements to the map
ihm.put("Zara", new Double(3434.34));
ihm.put("Mahnaz", new Double(123.22));
ihm.put("Ayan", new Double(1378.00));
ihm.put("Daisy", new Double(99.22));
ihm.put("Qadir", new Double(-19.08));
// Get a set of the entries
Set set = ihm.entrySet();
// Get an iterator
Iterator i = set.iterator();
// Display elements
while(i.hasNext()) {
Map.Entry me = (Map.Entry)i.next();
System.out.print(me.getKey() + ": ");
System.out.println(me.getValue());
420Java
}
System.out.println();
// Deposit 1000 into Zara's account
double balance = ((Double)ihm.get("Zara")).doubleValue();
ihm.put("Zara", new Double(balance + 1000));
System.out.println("Zara's new balance: " +
ihm.get("Zara"));
}
}
This will produce the following result:
Ayan: 1378.0
Zara: 3434.34
Qadir: -19.08
ahnaz: 123.22
Daisy: 99.22
Zara's new balance: 4434.34
The following legacy classes defined by java.util have been discussed in the previous
chapter:
Sr.
No.
Classes with Description
Vector
1
This implements a dynamic array. It is similar to ArrayList, but with some
differences.
Stack
2
Stack is a subclass of Vector that implements a standard last-in, first-out stack.
Dictionary
3
Dictionary is an abstract class that represents a key/value storage repository
and operates much like Map.
421Java
Hashtable
4
Hashtable was part of the original java.util and is a concrete implementation
of a Dictionary.
Properties
5
Properties is a subclass of Hashtable. It is used to maintain lists of values in
which the key is a String and the value is also a String.
BitSet
6
A BitSet class creates a special type of array that holds bit values. This array
can increase in size as needed.
The Vector Class
Vector implements a dynamic array. It is similar to ArrayList, but with two differences:
 Vector is synchronized.
 Vector contains many legacy methods that are not part of the collections
framework.
Vector proves to be very useful if you don't know the size of the array in advance or you
just need one that can change sizes over the lifetime of a program.
Following is the list of constructors provided by the vector class.
Sr.
No.
Constructor and Description
Vector( )
1
This constructor creates a default vector, which has an initial size of 10.
Vector(int size)
2
This constructor accepts an argument that equals the required size, and
creates a vector whose initial capacity is specified by size.
Vector(int size, int incr)
3
This constructor creates a vector whose initial capacity is specified by size and
whose increment is specified by incr. The increment specifies the number of
elements to allocate each time that a vector is resized upward.
422Java
Vector(Collection c)
4
Creates a vector that contains the elements of collection c.
Apart from the methods inherited from its parent classes, Vector defines the following
methods:
Sr. No.
Methods with Description
void add(int index, Object element)
1
Inserts the specified element at the specified position in this Vector.
boolean add(Object o)
2
Appends the specified element to the end of this Vector.
boolean addAll(Collection c)
3
Appends all of the elements in the specified Collection to the end of this
Vector, in the order that they are returned by the specified Collection's
Iterator.
boolean addAll(int index, Collection c)
4
Inserts all of the elements in the specified Collection into this Vector at the
specified position.
void addElement(Object obj)
5
Adds the specified component to the end of this vector, increasing its size by
one.
int capacity()
6
Returns the current capacity of this vector.
void clear()
7
Removes all of the elements from this Vector.
Object clone()
8
Returns a clone of this vector.
boolean contains(Object elem)
9
Tests if the specified object is a component in this vector.
boolean containsAll(Collection c)
10
Returns true if this Vector contains all of the elements in the specified
Collection.
423Java
void copyInto(Object[] anArray)
11
Copies the components of this vector into the specified array.
Object elementAt(int index)
12
Returns the component at the specified index.
Enumeration elements()
13
Returns an enumeration of the components of this vector.
void ensureCapacity(int minCapacity)
14
Increases the capacity of this vector, if necessary, to ensure that it can hold
at least the number of components specified by the minimum capacity
argument.
boolean equals(Object o)
15
Compares the specified Object with this Vector for equality.
Object firstElement()
16
Returns the first component (the item at index 0) of this vector.
Object get(int index)
17
Returns the element at the specified position in this Vector.
int hashCode()
18
Returns the hash code value for this Vector.
int indexOf(Object elem)
19
Searches for the first occurence of the given argument, testing for equality
using the equals method.
int indexOf(Object elem, int index)
20
Searches for the first occurence of the given argument, beginning the search
at index, and testing for equality using the equals method.
void insertElementAt(Object obj, int index)
21
Inserts the specified object as a component in this vector at the specified
index.
boolean isEmpty()
22
Tests if this vector has no components.
Object lastElement()
23
Returns the last component of the vector.
424Java
int lastIndexOf(Object elem)
24
Returns the index of the last occurrence of the specified object in this vector.
int lastIndexOf(Object elem, int index)
25
Searches backwards for the specified object, starting from the specified
index, and returns an index to it.
Object remove(int index)
26
Removes the element at the specified position in this Vector.
boolean remove(Object o)
27
Removes the first occurrence of the specified element in this Vector does not
contain the element, it is unchanged.
boolean removeAll(Collection c)
28
Removes from this Vector all of its elements that are contained in the
specified Collection.
void removeAllElements()
29
Removes all components from this vector and sets its size to zero.
boolean removeElement(Object obj)
30
Removes the first (lowest-indexed) occurrence of the argument from this
vector.
void removeElementAt(int index)
31
removeElementAt(int index)
protected void removeRange(int fromIndex, int toIndex)
32
Removes from this List all of the elements whose index is between
fromIndex, inclusive and toIndex, exclusive.
boolean retainAll(Collection c)
33
Retains only the elements in this Vector that are contained in the specified
Collection.
Object set(int index, Object element)
34
Replaces the element at the specified position in this Vector with the specified
element.
void setElementAt(Object obj, int index)
35
Sets the component at the specified index of this vector to be the specified
object.
425Java
void setSize(int newSize)
36
Sets the size of this vector.
int size()
37
Returns the number of components in this vector.
List subList(int fromIndex, int toIndex)
38
Returns a view of the portion of this List between fromIndex, inclusive, and
toIndex, exclusive.
Object[] toArray()
Returns an array containing all of the elements in this Vector in the correct
39
order.
Object[] toArray(Object[] a)
40
Returns an array containing all of the elements in this Vector in the correct
order; the runtime type of the returned array is that of the specified array.
String toString()
41
Returns a string representation of this Vector, containing the String
representation of each element.
void trimToSize()
42
Trims the capacity of this vector to be the vector's current size.
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class VectorDemo {
public static void main(String args[]) {
// initial size is 3, increment is 2
Vector v = new Vector(3, 2);
System.out.println("Initial size: " + v.size());
System.out.println("Initial capacity: " + v.capacity());
v.addElement(new Integer(1));
v.addElement(new Integer(2));
v.addElement(new Integer(3));
426Java
v.addElement(new Integer(4));
System.out.println("Capacity after four additions: " + v.capacity());
v.addElement(new Double(5.45));
System.out.println("Current capacity: " + v.capacity());
v.addElement(new Double(6.08));
v.addElement(new Integer(7));
System.out.println("Current capacity: " + v.capacity());
v.addElement(new Float(9.4));
v.addElement(new Integer(10));
System.out.println("Current capacity: " + v.capacity());
v.addElement(new Integer(11));
v.addElement(new Integer(12));
System.out.println("First element: " + (Integer)v.firstElement());
System.out.println("Last element: " + (Integer)v.lastElement());
if(v.contains(new Integer(3)))
System.out.println("Vector contains 3.");
// enumerate the elements in the vector.
Enumeration vEnum = v.elements();
System.out.println("\nElements in vector:");
while(vEnum.hasMoreElements())
System.out.print(vEnum.nextElement() + " ");
System.out.println();
}
}
This will produce the following result:
Initial size: 0
Initial capacity: 3
Capacity after four additions: 5
Current capacity: 5
Current capacity: 7
Current capacity: 9
427Java
First element: 1
Last element: 12
Vector contains 3.
Elements in vector:
1 2 3 4 5.45 6.08 7 9.4 10 11 12
The Stack Class
Stack is a subclass of Vector that implements a standard last-in, first-out stack.
Stack only defines the default constructor, which creates an empty stack. Stack includes
all the methods defined by Vector, and adds several of its own.
Stack( )
Apart from the methods inherited from its parent class Vector, Stack defines the following
methods:
Sr. No.
Methods with Description
boolean empty()
1
Tests if this stack is empty. Returns true if the stack is empty, and returns
false if the stack contains elements.
Object peek( )
2
Returns the element on the top of the stack, but does not remove it.
Object pop( )
3
Returns the element on the top of the stack, removing it in the process.
Object push(Object element)
4
Pushes the element onto the stack. The element is also returned.
int search(Object element)
5
Searches for the element in the stack. If found, its offset from the top of the
stack is returned. Otherwise, .1 is returned.
428Java
Example
The following program illustrates several of the methods supported by this collection:
import java.util.*;
public class StackDemo {
static void showpush(Stack st, int a) {
st.push(new Integer(a));
System.out.println("push(" + a + ")");
System.out.println("stack: " + st);
}
static void showpop(Stack st) {
System.out.print("pop -> ");
Integer a = (Integer) st.pop();
System.out.println(a);
System.out.println("stack: " + st);
}
public static void main(String args[]) {
Stack st = new Stack();
System.out.println("stack: " + st);
showpush(st, 42);
showpush(st, 66);
showpush(st, 99);
showpop(st);
showpop(st);
showpop(st);
try {
showpop(st);
} catch (EmptyStackException e) {
System.out.println("empty stack");
}
}
}
429Java
This will produce the following result:
stack: [ ]
push(42)
stack: [42]
push(66)
stack: [42, 66]
push(99)
stack: [42, 66, 99]
pop -> 99
stack: [42, 66]
pop -> 66
stack: [42]
pop -> 42
stack: [ ]
pop -> empty stack
The Dictionary Class
Dictionary is an abstract class that represents a key/value storage repository and operates
much like Map.
Given a key and value, you can store the value in a Dictionary object. Once the value is
stored, you can retrieve it by using its key. Thus, like a map, a dictionary can be thought
of as a list of key/value pairs.
The abstract methods defined by Dictionary are listed below:
Sr.
No.
Methods with Description
Enumeration elements( )
1
Returns an enumeration of the values contained in the dictionary.
Object get(Object key)
2
Returns the object that contains the value associated with the key. If the key
is not in the dictionary, a null object is returned.
boolean isEmpty( )
3
Returns true if the dictionary is empty, and returns false if it contains at least
one key.
430Java
Enumeration keys( )
4
Returns an enumeration of the keys contained in the dictionary.
Object put(Object key, Object value)
5
Inserts a key and its value into the dictionary. Returns null if the key is not
already in the dictionary; returns the previous value associated with the key if
the key is already in the dictionary.
Object remove(Object key)
6
Removes the key and its value. Returns the value associated with the key. If
the key is not in the dictionary, a null is returned.
int size( )
7
Returns the number of entries in the dictionary.
The Dictionary class is obsolete. You should implement the Map interface to obtain
key/value storage functionality.
The Map Interface
The Map interface maps unique keys to values. A key is an object that you use to retrieve
a value at a later date.
 Given a key and a value, you can store the value in a Map object. After the value
is stored, you can retrieve it by using its key.
 Several methods throw a NoSuchElementException when no items exist in the
invoking map.
 A ClassCastException is thrown when an object is incompatible with the elements
in a map.
 A NullPointerException is thrown if an attempt is made to use a null object and null
is not allowed in the map.
 An UnsupportedOperationException is thrown when an attempt is made to change
an unmodifiable map.
431Java
Sr.
No.
Methods with Description
void clear( )
1
Removes all key/value pairs from the invoking map.
boolean containsKey(Object k)
2
Returns true if the invoking map contains k as a key. Otherwise, returns false.
boolean containsValue(Object v)
3
Returns true if the map contains v as a value. Otherwise, returns false.
Set entrySet( )
4
Returns a Set that contains the entries in the map. The set contains objects of
type Map.Entry. This method provides a set-view of the invoking map.
boolean equals(Object obj)
5
Returns true if obj is a Map and contains the same entries. Otherwise, returns
false.
Object get(Object k)
6
Returns the value associated with the key k.
int hashCode( )
7
Returns the hash code for the invoking map.
boolean isEmpty( )
8
Returns true if the invoking map is empty. Otherwise, returns false.
Set keySet( )
9
Returns a Set that contains the keys in the invoking map. This method provides
a set-view of the keys in the invoking map.
Object put(Object k, Object v)
10
Puts an entry in the invoking map, overwriting any previous value associated
with the key. The key and value are k and v, respectively. Returns null if the
key did not already exist. Otherwise, the previous value linked to the key is
returned.
void putAll(Map m)
11
Puts all the entries from m into this map.
Object remove(Object k)
12
Removes the entry whose key equals k.
432Java
int size( )
13
Returns the number of key/value pairs in the map.
Collection values( )
14
Returns a collection containing the values in the map. This method provides a
collection-view of the values in the map.
Example
Map has its implementation in various classes like HashMap. Following is the example to
explain map functionality:
import java.util.*;
public class CollectionsDemo {
public static void main(String[] args) {
Map m1 = new HashMap();
m1.put("Zara", "8");
m1.put("Mahnaz", "31");
m1.put("Ayan", "12");
m1.put("Daisy", "14");
System.out.println();
System.out.println(" Map Elements");
System.out.print("\t" + m1);
}
}
This will produce the following result:
ap Elements
{Mahnaz=31, Ayan=12, Daisy=14, Zara=8}
The Hashtable Class
Hashtable was part of the original java.util and is a concrete implementation of a
Dictionary. However, Java 2 re-engineered Hashtable so that it also implements the Map
interface. Thus, Hashtable is now integrated into the collections framework. It is similar to
HashMap, but is synchronized.
433Java
Like HashMap, Hashtable stores key/value pairs in a hash table. When using a Hashtable,
you specify an object that is used as a key, and the value that you want linked to that
key. The key is then hashed, and the resulting hash code is used as the index at which
the value is stored within the table.
Following is the list of constructors provided by the HashTable class.
Sr.No.
Constructor and Description
Hashtable( )
1
This is the default constructor of the hash table. It instantiates the Hashtable
class.
Hashtable(int size)
2
This constructor accepts an integer parameter and creates a hash table that
has an initial size specified by the integer value size.
Hashtable(int size, float fillRatio)
3
This creates a hash table that has an initial size specified by size and a fill ratio
specified by fillRatio. This ratio must be between 0.0 and 1.0, and it determines
how full the hash table can be before it is resized upward.
Hashtable(Map<? extends K, ? extends V> t)
4
This constructs a Hashtable with the given mappings.
Apart from the methods defined by Map interface, Hashtable defines the following
methods:
Sr.
No.
Methods with Description
void clear( )
1
Resets and empties the hash table.
Object clone( )
2
Returns a duplicate of the invoking object.
boolean contains(Object value)
3
Returns true if some value equal to the value exists within the hash table.
Returns false if the value isn't found.
434Java
boolean containsKey(Object key)
4
Returns true if some key equal to the key exists within the hash table.
Returns false if the key isn't found.
boolean containsValue(Object value)
5
Returns true if some value equal to the value exists within the hash table.
Returns false if the value isn't found.
Enumeration elements( )
6
Returns an enumeration of the values contained in the hash table.
Object get(Object key)
7
Returns the object that contains the value associated with the key. If the
key is not in the hash table, a null object is returned.
boolean isEmpty( )
8
Returns true if the hash table is empty; returns false if it contains at least
one key.
Enumeration keys( )
9
Returns an enumeration of the keys contained in the hash table.
Object put(Object key, Object value)
10
Inserts a key and a value into the hash table. Returns null if the key isn't
already in the hash table; returns the previous value associated with the
key if the key is already in the hash table.
void rehash( )
11
Increases the size of the hash table and rehashes all of its keys.
Object remove(Object key)
12
Removes key and its value. Returns the value associated with the key. If
the key is not in the hash table, a null object is returned.
int size( )
13
Returns the number of entries in the hash table.
String toString( )
14
Returns the string equivalent of a hash table.
435Java
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.*;
public class HashTableDemo {
public static void main(String args[]) {
// Create a hash map
Hashtable balance = new Hashtable();
Enumeration names;
String str;
double bal;
balance.put("Zara", new Double(3434.34));
balance.put("Mahnaz", new Double(123.22));
balance.put("Ayan", new Double(1378.00));
balance.put("Daisy", new Double(99.22));
balance.put("Qadir", new Double(-19.08));
// Show all balances in hash table.
names = balance.keys();
while(names.hasMoreElements()) {
str = (String) names.nextElement();
System.out.println(str + ": " +
balance.get(str));
}
System.out.println();
// Deposit 1,000 into Zara's account
bal = ((Double)balance.get("Zara")).doubleValue();
balance.put("Zara", new Double(bal+1000));
System.out.println("Zara's new balance: " +
balance.get("Zara"));
}
}
436Java
This will produce the following result:
Qadir: -19.08
Zara: 3434.34
ahnaz: 123.22
Daisy: 99.22
Ayan: 1378.0
Zara's new balance: 4434.34
The Properties Class
Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key
is a String and the value is also a String.
The Properties class is used by many other Java classes. For example, it is the type of
object returned by System.getProperties( ) when obtaining the environmental values.
Properties define the following instance variable. This variable holds a default property list
associated with a Properties object.
Properties defaults;
Following is the list of constructors provided by the properties class.
Sr.
No.
Constructors and Description
Properties( )
1
This constructor creates a Properties object that has no default values.
Properties(Properties propDefault)
2
Creates an object that uses propDefault for its default values. In both the
cases, the property list is empty.
437Java
Apart from the methods defined by Hashtable, Properties define the following methods:
Sr. No.
Methods with Description
String getProperty(String key)
1
Returns the value associated with the key. A null object is returned if the key
is neither in the list nor in the default property list.
String getProperty(String key, String defaultProperty)
2
Returns the value associated with the key. defaultProperty is returned if the
key is neither in the list nor in the default property list.
void list(PrintStream streamOut)
3
Sends the property list to the output stream linked to streamOut.
void list(PrintWriter streamOut)
4
Sends the property list to the output stream linked to streamOut.
void load(InputStream streamIn) throws IOException
5
Inputs a property list from the input stream linked to streamIn.
Enumeration propertyNames( )
6
Returns an enumeration of the keys. This includes those keys found in the
default property list, too.
Object setProperty(String key, String value)
7
Associates value with the key. Returns the previous value associated with the
key, or returns null if no such association exists.
void store(OutputStream streamOut, String description)
8
After writing the string specified by the description, the property list is written
to the output stream linked to streamOut.
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.*;
public class PropDemo {
public static void main(String args[]) {
Properties capitals = new Properties();
438Java
Set states;
String str;
capitals.put("Illinois", "Springfield");
capitals.put("Missouri", "Jefferson City");
capitals.put("Washington", "Olympia");
capitals.put("California", "Sacramento");
capitals.put("Indiana", "Indianapolis");
// Show all states and capitals in hashtable.
states = capitals.keySet(); // get set-view of keys
Iterator itr = states.iterator();
while(itr.hasNext()) {
str = (String) itr.next();
System.out.println("The capital of " +
str + " is " + capitals.getProperty(str) + ".");
}
System.out.println();
// look for state not in list -- specify default
str = capitals.getProperty("Florida", "Not Found");
System.out.println("The capital of Florida is "
+ str + ".");
}
}
This will produce the following result:
The capital of Missouri is Jefferson City.
The capital of Illinois is Springfield.
The capital of Indiana is Indianapolis.
The capital of California is Sacramento.
The capital of Washington is Olympia.
The capital of Florida is Not Found.
439Java
The BitSet Class
A BitSet class creates a special type of array that holds bit values. The BitSet array can
increase in size as needed. This makes it similar to a vector of bits. This is a legacy class
but it has been completely re-engineered in Java 2, version 1.4.
The BitSet defines the following two constructors:
Sr. No.
1
Constructor and Description
BitSet( )
This constructor creates a default object.
2
BitSet(int size)
This constructor allows you to specify its initial size, i.e., the number of bits
that it can hold. All bits are initialized to zero.
BitSet implements the Cloneable interface and defines the methods listed in the following
table:
Sr.
No.
Methods with Description
void and(BitSet bitSet)
1
ANDs the contents of the invoking BitSet object with those specified by bitSet.
The result is placed into the invoking object.
void andNot(BitSet bitSet)
2
For each 1 bit in bitSet, the corresponding bit in the invoking BitSet is cleared.
int cardinality( )
3
Returns the number of set bits in the invoking object.
void clear( )
4
Zeros all bits.
void clear(int index)
5
Zeros the bit specified by the index.
void clear(int startIndex, int endIndex)
6
Zeros the bits from startIndex to endIndex.1.
Object clone( )
7
Duplicates the invoking BitSet object.
440Java
boolean equals(Object bitSet)
8
Returns true if the invoking bit set is equivalent to the one passed in bitSet.
Otherwise, the method returns false.
void flip(int index)
9
Reverses the bit specified by index.
void flip(int startIndex, int endIndex)
10
Reverses the bits from startIndex to endIndex.1.
boolean get(int index)
11
Returns the current state of the bit at the specified index.
BitSet get(int startIndex, int endIndex)
12
Returns a BitSet that consists of the bits from startIndex to endIndex.1. The
invoking object is not changed.
int hashCode( )
13
Returns the hash code for the invoking object.
boolean intersects(BitSet bitSet)
14
Returns true if at least one pair of corresponding bits within the invoking object
and bitSet are 1.
boolean isEmpty( )
15
Returns true if all bits in the invoking object are zero.
int length( )
16
Returns the number of bits required to hold the contents of the invoking BitSet.
This value is determined by the location of the last 1 bit.
int nextClearBit(int startIndex)
17
Returns the index of the next cleared bit, (that is, the next zero bit), starting
from the index specified by startIndex.
int nextSetBit(int startIndex)
18
Returns the index of the next set bit (that is, the next 1 bit), starting from the
index specified by startIndex. If no bit is set, .1 is returned.
void or(BitSet bitSet)
19
ORs the contents of the invoking BitSet object with that specified by bitSet.
The result is placed into the invoking object.
441Java
void set(int index)
20
Sets the bit specified by the index.
void set(int index, boolean v)
21
Sets the bit specified by the index to the value passed in v. True sets the bit,
false clears the bit.
void set(int startIndex, int endIndex)
22
Sets the bits from startIndex to endIndex.1.
void set(int startIndex, int endIndex, boolean v)
Sets the bits from startIndex to endIndex.1, to the value passed in v. True
23
sets the bits, false clears the bits.
int size( )
24
Returns the number of bits in the invoking BitSet object.
String toString( )
25
Returns the string equivalent of the invoking BitSet object.
void xor(BitSet bitSet)
26
XORs the contents of the invoking BitSet object with that specified by bitSet.
The result is placed into the invoking object.
Example
The following program illustrates several of the methods supported by this data structure:
import java.util.BitSet;
public class BitSetDemo {
public static void main(String args[]) {
BitSet bits1 = new BitSet(16);
BitSet bits2 = new BitSet(16);
// set some bits
for(int i=0; i<16; i++) {
if((i%2) == 0) bits1.set(i);
if((i%5) != 0) bits2.set(i);
}
442Java
System.out.println("Initial pattern in bits1: ");
System.out.println(bits1);
System.out.println("\nInitial pattern in bits2: ");
System.out.println(bits2);
// AND bits
bits2.and(bits1);
System.out.println("\nbits2 AND bits1: ");
System.out.println(bits2);
// OR bits
bits2.or(bits1);
System.out.println("\nbits2 OR bits1: ");
System.out.println(bits2);
// XOR bits
bits2.xor(bits1);
System.out.println("\nbits2 XOR bits1: ");
System.out.println(bits2);
}
}
This will produce the following result:
Initial pattern in bits1:
{0, 2, 4, 6, 8, 10, 12, 14}
Initial pattern in bits2:
{1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}
bits2 AND bits1:
{2, 4, 6, 8, 12, 14}
bits2 OR bits1:
{0, 2, 4, 6, 8, 10, 12, 14}
bits2 XOR bits1:
{}
443Java
The Collection Algorithms
The collections framework defines several algorithms that can be applied to collections and
maps. These algorithms are defined as static methods within the Collections class.
Several of the methods can throw a ClassCastException, which occurs when an attempt
is made to compare incompatible types, or an UnsupportedOperationException, which
occurs when an attempt is made to modify an unmodifiable collection.
Collections define three static variables: EMPTY_SET, EMPTY_LIST, and EMPTY_MAP. All
are immutable.
Sr. No.
1
Algorithms with Description
The Collection Algorithms
Here is a list of all the algorithm implementation.
The Collection Algorithms
The collections framework defines several algorithms that can be applied to collections and
maps.
These algorithms are defined as static methods within the Collections class. Several of the
methods can throw a ClassCastException, which occurs when an attempt is made to
compare incompatible types, or anUnsupportedOperationException, which occurs
when an attempt is made to modify an unmodifiable collection.
The methods defined in collection framework's algorithm are summarized in the following
table:
Sr.
No.
Methods with Description
static int binarySearch(List list, Object value, Comparator c)
1
Searches for value in the list ordered according to c. Returns the position of
value in list, or -1 if value is not found.
static int binarySearch(List list, Object value)
2
Searches for value in the list. The list must be sorted. Returns the position of
value in list, or -1 if value is not found.
static void copy(List list1, List list2)
3
Copies the elements of list2 to list1.
static Enumeration enumeration(Collection c)
4
Returns an enumeration over c.
444Java
static void fill(List list, Object obj)
5
Assigns obj to each element of the list.
static int indexOfSubList(List list, List subList)
6
Searches list for the first occurrence of subList. Returns the index of the first
match, or .1 if no match is found.
static int lastIndexOfSubList(List list, List subList)
7
Searches list for the last occurrence of subList. Returns the index of the last
match, or .1 if no match is found.
static ArrayList list(Enumeration enum)
8
Returns an ArrayList that contains the elements of enum.
static Object max(Collection c, Comparator comp)
9
Returns the maximum element in c as determined by comp.
static Object max(Collection c)
10
Returns the maximum element in c as determined by natural ordering. The
collection need not be sorted.
static Object min(Collection c, Comparator comp)
11
Returns the minimum element in c as determined by comp. The collection
need not be sorted.
static Object min(Collection c)
12
Returns the minimum element in c as determined by natural ordering.
static List nCopies(int num, Object obj)
13
Returns num copies of obj contained in an immutable list. num must be
greater than or equal to zero.
static boolean replaceAll(List list, Object old, Object new)
14
Replaces all occurrences of old with new in the list. Returns true if at least
one replacement occurred. Returns false, otherwise.
static void reverse(List list)
15
Reverses the sequence in list.
static Comparator reverseOrder( )
16
Returns a reverse comparator
445Java
static void rotate(List list, int n)
17
Rotates list by n places to the right. To rotate left, use a negative value for
n.
static void shuffle(List list, Random r)
18
Shuffles (i.e., randomizes) the elements in the list by using r as a source of
random numbers.
static void shuffle(List list)
19
Shuffles (i.e., randomizes) the elements in list.
static Set singleton(Object obj)
20
Returns obj as an immutable set. This is an easy way to convert a single
object into a a set.
static List singletonList(Object obj)
21
Returns obj as an immutable list. This is an easy way to convert a single
object into a list.
static Map singletonMap(Object k, Object v)
22
Returns the key/value pair k/v as an immutable map. This is an easy way to
convert a single key/value pair into a map.
static void sort(List list, Comparator comp)
23
Sorts the elements of list as determined by comp.
static void sort(List list)
24
Sorts the elements of the list as determined by their natural ordering.
static void swap(List list, int idx1, int idx2)
25
Exchanges the elements in the list at the indices specified by idx1 and idx2.
static Collection synchronizedCollection(Collection c)
26
Returns a thread-safe collection backed by c.
static List synchronizedList(List list)
27
Returns a thread-safe list backed by list.
static Map synchronizedMap(Map m)
28
Returns a thread-safe map backed by m.
static Set synchronizedSet(Set s)
29
Returns a thread-safe set backed by s.
446Java
static SortedMap synchronizedSortedMap(SortedMap sm)
30
Returns a thread-safe sorted set backed by sm.
static SortedSet synchronizedSortedSet(SortedSet ss)
31
Returns a thread-safe set backed by ss.
static Collection unmodifiableCollection(Collection c)
32
Returns an unmodifiable collection backed by c.
static List unmodifiableList(List list)
33
Returns an unmodifiable list backed by the list.
static Map unmodifiableMap(Map m)
34
Returns an unmodifiable map backed by m.
static Set unmodifiableSet(Set s)
35
Returns an unmodifiable set backed by s.
static SortedMap unmodifiableSortedMap(SortedMap sm)
36
Returns an unmodifiable sorted map backed by sm.
static SortedSet unmodifiableSortedSet(SortedSet ss)
37
Returns an unmodifiable sorted set backed by ss.
Example
Following is an example, which demonstrates various algorithms.
import java.util.*;
public class AlgorithmsDemo {
public static void main(String args[]) {
// Create and initialize linked list
LinkedList ll = new LinkedList();
ll.add(new Integer(-8));
ll.add(new Integer(20));
ll.add(new Integer(-20));
ll.add(new Integer(8));
447Java
// Create a reverse order comparator
Comparator r = Collections.reverseOrder();
// Sort list by using the comparator
Collections.sort(ll, r);
// Get iterator
Iterator li = ll.iterator();
System.out.print("List sorted in reverse: ");
while(li.hasNext()){
System.out.print(li.next() + " ");
}
System.out.println();
Collections.shuffle(ll);
// display randomized list
li = ll.iterator();
System.out.print("List shuffled: ");
while(li.hasNext()){
System.out.print(li.next() + " ");
}
System.out.println();
System.out.println("Minimum: " + Collections.min(ll));
System.out.println("Maximum: " + Collections.max(ll));
}
}
This will produce the following result:
List sorted in reverse: 20 8 -8 -20
List shuffled: 20 -20 8 -8
inimum: -20
aximum: 20
448Java
How to Use an Iterator ?
Often, you will want to cycle through the elements in a collection. For example, you might
want to display each element.
The easiest way to do this is to employ an iterator, which is an object that implements
either the Iterator or the ListIterator interface.
Iterator enables you to cycle through a collection, obtaining or removing elements.
ListIterator extends Iterator to allow bidirectional traversal of a list and the modification
of elements.
Sr.
No.
Iterator Methods with Description
Using Java Iterator
1
Here is a list of all the methods with examples provided by Iterator and
ListIterator interfaces.
How to Use Iterator?
Often, you will want to cycle through the elements in a collection. For example, you might
want to display each element. The easiest way to do this is to employ an iterator, which
is an object that implements either the Iterator or the ListIterator interface.
Iterator enables you to cycle through a collection, obtaining or removing elements.
ListIterator extends Iterator to allow bidirectional traversal of a list, and the modification
of elements.
Before you can access a collection through an iterator, you must obtain one. Each of the
collection classes provides an iterator( ) method that returns an iterator to the start of the
collection. By using this iterator object, you can access each element in the collection, one
element at a time.
In general, to use an iterator to cycle through the contents of a collection, follow these
steps:
 Obtain an iterator to the start of the collection by calling the collection's iterator( )
method.
 Set up a loop that makes a call to hasNext( ). Have the loop iterate as long as
hasNext( ) returns true.
 Within the loop, obtain each element by calling next( ).
For collections that implement List, you can also obtain an iterator by calling ListIterator.
449Java
The Methods Declared by Iterator
Sr. No.
Methods with Description
boolean hasNext( )
1
Returns true if there are more elements. Otherwise, returns false.
Object next( )
2
Returns the next element. Throws NoSuchElementException if there is not a
next element.
void remove( )
3
Removes the current element. Throws IllegalStateException if an attempt is
made to call remove( ) that is not preceded by a call to next( ).
The Methods Declared by ListIterator
Sr. No.
Methods with Description
void add(Object obj)
1
Inserts obj into the list in front of the element that will be returned by the
next call to next( ).
boolean hasNext( )
2
Returns true if there is a next element. Otherwise, returns false.
boolean hasPrevious( )
3
Returns true if there is a previous element. Otherwise, returns false.
Object next( )
4
Returns the next element. A NoSuchElementException is thrown if there is not
a next element.
int nextIndex( )
5
Returns the index of the next element. If there is not a next element, returns
the size of the list.
Object previous( )
6
Returns the previous element. A NoSuchElementException is thrown if there
is not a previous element.
450Java
int previousIndex( )
7
Returns the index of the previous element. If there is not a previous element,
returns -1.
void remove( )
8
Removes the current element from the list. An IllegalStateException is thrown
if remove( ) is called before next( ) or previous( ) is invoked.
void set(Object obj)
9
Assigns obj to the current element. This is the element last returned by a call
to either next( ) or previous( ).
Example
Here is an example demonstrating both Iterator and ListIterator. It uses an ArrayList
object, but the general principles apply to any type of collection.
Of course, ListIterator is available only to those collections that implement the List
interface.
import java.util.*;
public class IteratorDemo {
public static void main(String args[]) {
// Create an array list
ArrayList al = new ArrayList();
// add elements to the array list
al.add("C");
al.add("A");
al.add("E");
al.add("B");
al.add("D");
al.add("F");
451Java
// Use iterator to display contents of al
System.out.print("Original contents of al: ");
Iterator itr = al.iterator();
while(itr.hasNext()) {
Object element = itr.next();
System.out.print(element + " ");
}
System.out.println();
// Modify objects being iterated
ListIterator litr = al.listIterator();
while(litr.hasNext()) {
Object element = litr.next();
litr.set(element + "+");
}
System.out.print("Modified contents of al: ");
itr = al.iterator();
while(itr.hasNext()) {
Object element = itr.next();
System.out.print(element + " ");
}
System.out.println();
// Now, display the list backwards
System.out.print("Modified list backwards: ");
while(litr.hasPrevious()) {
Object element = litr.previous();
System.out.print(element + " ");
}
System.out.println();
}
}
452Java
This will produce the following result:
Original contents of al: C A E B D F
odified contents of al: C+ A+ E+ B+ D+ F+
odified list backwards: F+ D+ B+ E+ A+ C+
How to Use a Comparator ?
Both TreeSet and TreeMap store elements in a sorted order. However, it is the comparator
that defines precisely what sorted order means.
This interface lets us sort a given collection any number of different ways. Also this
interface can be used to sort any instances of any class (even classes we cannot modify).
Sr.
No.
Iterator Methods with Description
Using Java Comparator
1
Here is a list of all the methods with examples provided by Comparator
Interface.
How to Use Comparator?
Both TreeSet and TreeMap store elements in sorted order. However, it is the comparator
that defines precisely what sorted order means.
The Comparator interface defines two methods: compare( ) and equals( ). The compare(
) method, shown here, compares two elements for order:
The compare Method
int compare(Object obj1, Object obj2)
obj1 and obj2 are the objects to be compared. This method returns zero if the objects are
equal. It returns a positive value if obj1 is greater than obj2. Otherwise, a negative value
is returned.
By overriding compare( ), you can alter the way that objects are ordered. For example, to
sort in a reverse order, you can create a comparator that reverses the outcome of a
comparison.
The equals Method
The equals( ) method, shown here, tests whether an object equals the invoking
comparator:
boolean equals(Object obj)
453Java
obj is the object to be tested for equality. The method returns true if obj and the invoking
object are both Comparator objects and use the same ordering. Otherwise, it returns false.
Overriding equals( ) is unnecessary, and most simple comparators will not do so.
Example
import java.util.*;
class Dog implements Comparator<Dog>, Comparable<Dog>{
private String name;
private int age;
Dog(){
}
Dog(String n, int a){
name = n;
age = a;
}
public String getDogName(){
return name;
}
public int getDogAge(){
return age;
}
// Overriding the compareTo method
public int compareTo(Dog d){
return (this.name).compareTo(d.name);
}
// Overriding the compare method to sort the age
public int compare(Dog d, Dog d1){
return d.age - d1.age;
}
}
454Java
public class Example{
public static void main(String args[]){
// Takes a list o Dog objects
List<Dog> list = new ArrayList<Dog>();
list.add(new Dog("Shaggy",3));
list.add(new Dog("Lacy",2));
list.add(new Dog("Roger",10));
list.add(new Dog("Tommy",4));
list.add(new Dog("Tammy",1));
Collections.sort(list);// Sorts the array list
for(Dog a: list)//printing the sorted list of names
System.out.print(a.getDogName() + ", ");
// Sorts the array list using comparator
Collections.sort(list, new Dog());
System.out.println(" ");
for(Dog a: list)//printing the sorted list of ages
System.out.print(a.getDogName() +"
: "+
a.getDogAge() + ", ");
}
}
This will produce the following result:
Lacy, Roger, Shaggy, Tammy, Tommy,
Tammy
: 1, Lacy
: 2, Shaggy
: 3, Tommy
: 4, Roger
: 10,
Note: Sorting of the Arrays class is as the same as the Collections.
Summary
The Java collections framework gives the programmer access to prepackaged data
structures as well as to algorithms for manipulating them.
A collection is an object that can hold references to other objects. The collection interfaces
declare the operations that can be performed on each type of collection.
The classes and interfaces of the collections framework are in package java.util.
45530.
Java – Generics
Java
It would be nice if we could write a single sort method that could sort the elements in an
Integer array, a String array, or an array of any type that supports ordering.
Java Generic methods and generic classes enable programmers to specify, with a single
method declaration, a set of related methods, or with a single class declaration, a set of
related types, respectively.
Generics also provide compile-time type safety that allows programmers to catch invalid
types at compile time.
Using Java Generic concept, we might write a generic method for sorting an array of
objects, then invoke the generic method with Integer arrays, Double arrays, String arrays
and so on, to sort the array elements.
Generic Methods
You can write a single generic method declaration that can be called with arguments of
different types. Based on the types of the arguments passed to the generic method, the
compiler handles each method call appropriately. Following are the rules to define Generic
Methods:
 All generic method declarations have a type parameter section delimited by angle
brackets (< and >) that precedes the method's return type ( < E > in the next
example).
 Each type parameter section contains one or more type parameters separated by
commas. A type parameter, also known as a type variable, is an identifier that
specifies a generic type name.
 The type parameters can be used to declare the return type and act as placeholders
for the types of the arguments passed to the generic method, which are known as
actual type arguments.
 A generic method's body is declared like that of any other method. Note that type
parameters can represent only reference types, not primitive types (like int, double
and char).
456Java
Example
Following example illustrates how we can print an array of different type using a single
Generic method:
public class GenericMethodTest
{
// generic method printArray
public static < E > void printArray( E[] inputArray )
{
// Display array elements
for ( E element : inputArray ){
System.out.printf( "%s ", element );
}
System.out.println();
}
public static void main( String args[] )
{
// Create arrays of Integer, Double and Character
Integer[] intArray = { 1, 2, 3, 4, 5 };
Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
System.out.println( "Array integerArray contains:" );
printArray( intArray
); // pass an Integer array
System.out.println( "\nArray doubleArray contains:" );
printArray( doubleArray ); // pass a Double array
System.out.println( "\nArray characterArray contains:" );
printArray( charArray ); // pass a Character array
}
}
457Java
This will produce the following result:
Array integerArray contains:
1 2 3 4 5 6
Array doubleArray contains:
1.1 2.2 3.3 4.4
Array characterArray contains:
H E L L O
Bounded Type Parameters
There may be times when you'll want to restrict the kinds of types that are allowed to be
passed to a type parameter. For example, a method that operates on numbers might only
want to accept instances of Number or its subclasses. This is what bounded type
parameters are for.
To declare a bounded type parameter, list the type parameter's name, followed by the
extends keyword, followed by its upper bound.
Example
Following example illustrates how extends is used in a general sense to mean either
"extends" (as in classes) or "implements" (as in interfaces). This example is Generic
method to return the largest of three Comparable objects:
public class MaximumTest
{
// determines the largest of three Comparable objects
public static <T extends Comparable<T>> T maximum(T x, T y, T z)
{
T max = x; // assume x is initially the largest
if ( y.compareTo( max ) > 0 ){
max = y; // y is the largest so far
}
if ( z.compareTo( max ) > 0 ){
max = z; // z is the largest now
}
458Java
return max; // returns the largest object
}
public static void main( String args[] )
{
System.out.printf( "Max of %d, %d and %d is %d\n\n",
3, 4, 5, maximum( 3, 4, 5 ) );
System.out.printf( "Maxm of %.1f,%.1f and %.1f is %.1f\n\n",
6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
System.out.printf( "Max of %s, %s and %s is %s\n","pear",
"apple", "orange", maximum( "pear", "apple", "orange" ) );
}
}
This will produce the following result:
maximum of 3, 4 and 5 is 5
maximum of 6.6, 8.8 and 7.7 is 8.8
maximum of pear, apple and orange is pear
Generic Classes
A generic class declaration looks like a non-generic class declaration, except that the class
name is followed by a type parameter section.
As with generic methods, the type parameter section of a generic class can have one or
more type parameters separated by commas. These classes are known as parameterized
classes or parameterized types because they accept one or more parameters.
459Java
Example
Following example illustrates how we can define a generic class:
public class Box<T> {
private T t;
public void add(T t) {
this.t = t;
}
public T get() {
return t;
}
public static void main(String[] args) {
Box<Integer> integerBox = new Box<Integer>();
Box<String> stringBox = new Box<String>();
integerBox.add(new Integer(10));
stringBox.add(new String("Hello World"));
System.out.printf("Integer Value :%d\n\n", integerBox.get());
System.out.printf("String Value :%s\n", stringBox.get());
}
}
This will produce the following result:
Integer Value :10
String Value :Hello World
46031.
Java
Java – Serialization
Java provides a mechanism, called object serialization where an object can be represented
as a sequence of bytes that includes the object's data as well as information about the
object's type and the types of data stored in the object.
After a serialized object has been written into a file, it can be read from the file and
deserialized that is, the type information and bytes that represent the object and its data
can be used to recreate the object in memory.
Most impressive is that the entire process is JVM independent, meaning an object can be
serialized on one platform and deserialized on an entirely different platform.
Classes ObjectInputStream and ObjectOutputStream are high-level
contain the methods for serializing and deserializing an object.
streams
that
The ObjectOutputStream class contains many write methods for writing various data
types, but one method in particular stands out:
public final void writeObject(Object x) throws IOException
The above method serializes an Object and sends it to the output stream. Similarly, the
ObjectInputStream class contains the following method for deserializing an object:
public final Object readObject() throws IOException, ClassNotFoundException
This method retrieves the next Object out of the stream and deserializes it. The return
value is Object, so you will need to cast it to its appropriate data type.
To demonstrate how serialization works in Java, I am going to use the Employee class that
we discussed early on in the book. Suppose that we have the following Employee class,
which implements the Serializable interface:
public class Employee implements java.io.Serializable
{
public String name;
public String address;
public transient int SSN;
public int number;
public void mailCheck()
{
System.out.println("Mailing a check to " + name + " " + address);
}
}
461Java
Notice that for a class to be serialized successfully, two conditions must be met:
 The class must implement the java.io.Serializable interface.
 All of the fields in the class must be serializable. If a field is not serializable, it must
be marked transient.
If you are curious to know if a Java Standard Class is serializable or not, check the
documentation for the class. The test is simple: If the class implements
java.io.Serializable, then it is serializable; otherwise, it's not.
Serializing an Object
The ObjectOutputStream class is used to serialize an Object. The following SerializeDemo
program instantiates an Employee object and serializes it to a file.
When the program is done executing, a file named employee.ser is created. The program
does not generate any output, but study the code and try to determine what the program
is doing.
Note: When serializing an object to a file, the standard convention in Java is to give the
file a .ser extension.
import java.io.*;
public class SerializeDemo
{
public static void main(String [] args)
{
Employee e = new Employee();
e.name = "Reyan Ali";
e.address = "Phokka Kuan, Ambehta Peer";
e.SSN = 11122333;
e.number = 101;
try
{
FileOutputStream fileOut =
new FileOutputStream("/tmp/employee.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(e);
out.close();
fileOut.close();
462Java
System.out.printf("Serialized data is saved in /tmp/employee.ser");
}catch(IOException i)
{
i.printStackTrace();
}
}
}
Deserializing an Object
The following DeserializeDemo program deserializes the Employee object created in the
SerializeDemo program. Study the program and try to determine its output:
import java.io.*;
public class DeserializeDemo
{
public static void main(String [] args)
{
Employee e = null;
try
{
FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
e = (Employee) in.readObject();
in.close();
fileIn.close();
}catch(IOException i)
{
i.printStackTrace();
return;
}catch(ClassNotFoundException c)
{
System.out.println("Employee class not found");
c.printStackTrace();
return;
}
System.out.println("Deserialized Employee...");
System.out.println("Name: " + e.name);
463Java
System.out.println("Address: " + e.address);
System.out.println("SSN: " + e.SSN);
System.out.println("Number: " + e.number);
}
}
This will produce the following result:
Deserialized Employee...
Name: Reyan Ali
Address:Phokka Kuan, Ambehta Peer
SSN: 0
Number:101
Here are following important points to be noted:
 The try/catch block tries to catch a ClassNotFoundException, which is declared by
the readObject() method. For a JVM to be able to deserialize an object, it must be
able to find the bytecode for the class. If the JVM can't find a class during the
deserialization of an object, it throws a ClassNotFoundException.
 Notice that the return value of readObject() is cast to an Employee reference.
 The value of the SSN field was 11122333 when the object was serialized, but
because the field is transient, this value was not sent to the output stream. The
SSN field of the deserialized Employee object is 0.
46432.
Java – Networking
Java
The term network programming refers to writing programs that execute across multiple
devices (computers), in which the devices are all connected to each other using a network.
The java.net package of the J2SE APIs contains a collection of classes and interfaces that
provide the low-level communication details, allowing you to write programs that focus on
solving the problem at hand.
The java.net package provides support for the two common network protocols:
 TCP: TCP stands for Transmission Control Protocol, which allows for reliable
communication between two applications. TCP is typically used over the Internet
Protocol, which is referred to as TCP/IP.
 UDP: UDP stands for User Datagram Protocol, a connection-less protocol that
allows for packets of data to be transmitted between applications.
This chapter gives a good understanding on the following two subjects:
 Socket Programming: This is the most widely used concept in Networking and it
has been explained in very detail.
 URL Processing: This would be covered separately. Click here to learn about URL
Processing in Java language.
URL Processing
URL stands for Uniform Resource Locator and represents a resource on the World Wide
Web, such as a Web page or FTP directory.
This section shows you how to write Java programs that communicate with a URL. A URL
can be broken down into parts, as follows:
protocol://host:port/path?query#ref
Examples of protocols include HTTP, HTTPS, FTP, and File. The path is also referred to as
the filename, and the host is also called the authority.
The following is a URL to a web page whose protocol is HTTP:
http://www.amrood.com/index.htm?language=en#j2se
Notice that this URL does not specify a port, in which case the default port for the protocol
is used. With HTTP, the default port is 80.
465Java
URL Class Methods
The java.net.URL class represents a URL and has a complete set of methods to
manipulate URL in Java.
The URL class has several constructors for creating URLs, including the following:
Sr.
No.
1
Methods with Description
public URL(String protocol, String host, int port, String file) throws
MalformedURLException
Creates a URL by putting together the given parts.
public URL(String protocol,
MalformedURLException
String
host,
String
file)
throws
2
Identical to the previous constructor, except that the default port for the given
protocol is used.
3
public
URL(String
url)
throws
MalformedURLException
Creates a URL from the given String.
4
public URL(URL context, String url) throws MalformedURLException
Creates a URL by parsing together the URL and String arguments.
The URL class contains many methods for accessing the various parts of the URL being
represented. Some of the methods in the URL class include the following:
Sr.
No.
1
Methods with Description
public String getPath()
Returns the path of the URL.
public String getQuery()
2
Returns the query part of the URL.
public String getAuthority()
3
Returns the authority of the URL.
4
public int getPort()
466Java
Returns the port of the URL.
public int getDefaultPort()
5
Returns the default port for the protocol of the URL.
6
public String getProtocol()
Returns the protocol of the URL.
public String getHost()
7
Returns the host of the URL.
public String getHost()
8
Returns the host of the URL.
public String getFile()
9
Returns the filename of the URL.
public String getRef()
10
Returns the reference part of the URL.
public URLConnection openConnection() throws IOException
11
Opens a connection to the URL, allowing a client to communicate with the
resource.
Example
The following URLDemo program demonstrates the various parts of a URL. A URL is
entered on the command line, and the URLDemo program outputs each part of the given
URL.
// File Name : URLDemo.java
import java.net.*;
import java.io.*;
467Java
public class URLDemo
{
public static void main(String [] args)
{
try
{
URL url = new URL("http://www.amrood.com/index.htm?language=en#j2se");
System.out.println("URL is " + url.toString());
System.out.println("protocol is " + url.getProtocol());
System.out.println("authority is " + url.getAuthority());
System.out.println("file name is " + url.getFile());
System.out.println("host is " + url.getHost());
System.out.println("path is " + url.getPath());
System.out.println("port is " + url.getPort());
System.out.println("default port is " + url.getDefaultPort());
System.out.println("query is " + url.getQuery());
System.out.println("ref is " + url.getRef());
}catch(IOException e)
{
e.printStackTrace();
}
}
}
A sample run of the this program will produce the following result:
URL is http://www.amrood.com/index.htm?language=en#j2se
protocol is http
authority is www.amrood.com
file name is /index.htm?language=en
host is www.amrood.com
path is /index.htm
port is -1
default port is 80
query is language=en
ref is j2se
468Java
URLConnections Class Methods
The openConnection() method returns a java.net.URLConnection, an abstract class
whose subclasses represent the various types of URL connections.
For example:
 If you connect to a URL whose protocol is HTTP, the openConnection() method
returns an HttpURLConnection object.
 If you connect to a URL that represents a JAR file, the openConnection() method
returns a JarURLConnection object, etc.
The URLConnection class has many methods for setting or determining information about
the connection, including the following:
Sr. No.
Methods with Description
Object getContent()
1
Retrieves the contents of this URL connection.
Object getContent(Class[] classes)
2
Retrieves the contents of this URL connection.
String getContentEncoding()
3
Returns the value of the content-encoding header field.
int getContentLength()
4
Returns the value of the content-length header field.
String getContentType()
5
Returns the value of the content-type header field.
int getLastModified()
6
Returns the value of the last-modified header field.
long getExpiration()
7
Returns the value of the expired header field.
469Java
long getIfModifiedSince()
8
Returns the value of this object's ifModifiedSince field.
public void setDoInput(boolean input)
9
Passes in true to denote that the connection will be used for input. The
default value is true because clients typically read from a URLConnection.
public void setDoOutput(boolean output)
10
Passes in true to denote that the connection will be used for output. The
default value is false because many types of URLs do not support being
written to.
public InputStream getInputStream() throws IOException
11
Returns the input stream of the URL connection for reading from the
resource.
public OutputStream getOutputStream() throws IOException
12
Returns the output stream of the URL connection for writing to the
resource.
public URL getURL()
13
Returns the URL that this URLConnection object is connected to.
Example
The following URLConnectionDemo program connects to a URL entered from the command
line.
If the URL represents an HTTP resource, the connection is cast to HttpURLConnection, and
the data in the resource is read one line at a time.
// File Name : URLConnDemo.java
import java.net.*;
import java.io.*;
public class URLConnDemo
{
public static void main(String [] args)
470Java
{
try
{
URL url = new URL("http://www.amrood.com");
URLConnection urlConnection = url.openConnection();
HttpURLConnection connection = null;
if(urlConnection instanceof HttpURLConnection)
{
connection = (HttpURLConnection) urlConnection;
}
else
{
System.out.println("Please enter an HTTP URL.");
return;
}
BufferedReader in = new BufferedReader(
new InputStreamReader(connection.getInputStream()));
String urlString = "";
String current;
while((current = in.readLine()) != null)
{
urlString += current;
}
System.out.println(urlString);
}catch(IOException e)
{
e.printStackTrace();
}
}
}
A sample run of this program will produce the following result:
$ java URLConnDemo
.....a complete HTML content of home page of amrood.com.....
471Java
Socket Programming
Sockets provide the communication mechanism between two computers using TCP. A
client program creates a socket on its end of the communication and attempts to connect
that socket to a server.
When the connection is made, the server creates a socket object on its end of the
communication. The client and the server can now communicate by writing to and reading
from the socket.
The java.net.Socket class represents a socket, and the java.net.ServerSocket class
provides a mechanism for the server program to listen for clients and establish connections
with them.
The following steps occur when establishing a TCP connection between two computers
using sockets:
 The server instantiates a ServerSocket object, denoting which port number
communication is to occur on.
 The server invokes the accept() method of the ServerSocket class. This method
waits until a client connects to the server on the given port.
 After the server is waiting, a client instantiates a Socket object, specifying the
server name and the port number to connect to.
 The constructor of the Socket class attempts to connect the client to the specified
server and the port number. If communication is established, the client now has a
Socket object capable of communicating with the server.
 On the server side, the accept() method returns a reference to a new socket on the
server that is connected to the client's socket.
After the connections are established, communication can occur using I/O streams. Each
socket has both an OutputStream and an InputStream. The client's OutputStream is
connected to the server's InputStream, and the client's InputStream is connected to the
server's OutputStream.
TCP is a two-way communication protocol, hence data can be sent across both streams at
the same time. Following are the useful classes providing complete set of methods to
implement sockets.
472Java
ServerSocket Class Methods
The java.net.ServerSocket class is used by server applications to obtain a port and listen
for client requests.
The ServerSocket class has four constructors:
Sr. No.
Methods with Description
public ServerSocket(int port) throws IOException
1
Attempts to create a server socket bound to the specified port. An exception
occurs if the port is already bound by another application.
public ServerSocket(int port, int backlog) throws IOException
2
Similar to the previous constructor, the backlog parameter specifies how
many incoming clients to store in a wait queue.
public ServerSocket(int port, int backlog, InetAddress address)
throws IOException
3
Similar to the previous constructor, the InetAddress parameter specifies the
local IP address to bind to. The InetAddress is used for servers that may have
multiple IP addresses, allowing the server to specify which of its IP addresses
to accept client requests on.
public ServerSocket() throws IOException
4
Creates an unbound server socket. When using this constructor, use the
bind() method when you are ready to bind the server socket.
If the ServerSocket constructor does not throw an exception, it means that your
application has successfully bound to the specified port and is ready for client requests.
Following are some of the common methods of the ServerSocket class:
Sr. No.
Methods with Description
public int getLocalPort()
1
Returns the port that the server socket is listening on. This method is useful
if you passed in 0 as the port number in a constructor and let the server find
a port for you.
public Socket accept() throws IOException
2
Waits for an incoming client. This method blocks until either a client connects
to the server on the specified port or the socket times out, assuming that the
time-out value has been set using the setSoTimeout() method. Otherwise,
this method blocks indefinitely.
473Java
public void setSoTimeout(int timeout)
3
Sets the time-out value for how long the server socket waits for a client during
the accept().
public void bind(SocketAddress host, int backlog)
4
Binds the socket to the specified server and port in the SocketAddress object.
Use this method if you have instantiated the ServerSocket using the no-
argument constructor.
When the ServerSocket invokes accept(), the method does not return until a client
connects. After a client does connect, the ServerSocket creates a new Socket on an
unspecified port and returns a reference to this new Socket. A TCP connection now exists
between the client and the server, and communication can begin.
Socket Class Methods
The java.net.Socket class represents the socket that both the client and the server use
to communicate with each other. The client obtains a Socket object by instantiating one,
whereas the server obtains a Socket object from the return value of the accept() method.
The Socket class has five constructors that a client uses to connect to a server:
Sr.
No.
Methods with Description
public Socket(String host, int port) throws UnknownHostException,
IOException.
1
This method attempts to connect to the specified server at the specified port. If
this constructor does not throw an exception, the connection is successful and
the client is connected to the server.
public Socket(InetAddress host, int port) throws IOException
2
This method is identical to the previous constructor, except that the host is
denoted by an InetAddress object.
public Socket(String host, int port, InetAddress localAddress, int
localPort) throws IOException.
3
Connects to the specified host and port, creating a socket on the local host at
the specified address and port.
public Socket(InetAddress host, int port, InetAddress localAddress, int
localPort) throws IOException.
4
This method is identical to the previous constructor, except that the host is
denoted by an InetAddress object instead of a String.
474Java
public Socket()
5
Creates an unconnected socket. Use the connect() method to connect this socket
to a server.
When the Socket constructor returns, it does not simply instantiate a Socket object but it
actually attempts to connect to the specified server and port.
Some methods of interest in the Socket class are listed here. Notice that both the client
and the server have a Socket object, so these methods can be invoked by both the client
and the server.
Sr.
No.
Methods with Description
public void
IOException
connect(SocketAddress
host,
int
timeout)
throws
1
This method connects the socket to the specified host. This method is needed
only when you instantiate the Socket using the no-argument constructor.
public InetAddress getInetAddress()
2
This method returns the address of the other computer that this socket is
connected to.
public int getPort()
3
Returns the port the socket is bound to on the remote machine.
public int getLocalPort()
4
Returns the port the socket is bound to on the local machine.
public SocketAddress getRemoteSocketAddress()
5
Returns the address of the remote socket.
public InputStream getInputStream() throws IOException
6
Returns the input stream of the socket. The input stream is connected to the
output stream of the remote socket.
public OutputStream getOutputStream() throws IOException
7
Returns the output stream of the socket. The output stream is connected to the
input stream of the remote socket.
public void close() throws IOException
8
Closes the socket, which makes this Socket object no longer capable of
connecting again to any server.
475Java
InetAddress Class Methods
This class represents an Internet Protocol (IP) address. Here are following usefull methods
which you would need while doing socket programming:
Sr. No.
Methods with Description
static InetAddress getByAddress(byte[] addr)
1
Returns an InetAddress object given the raw IP address.
static InetAddress getByAddress(String host, byte[] addr)
2
Creates an InetAddress based on the provided host name and IP address.
static InetAddress getByName(String host)
3
Determines the IP address of a host, given the host's name.
String getHostAddress()
4
Returns the IP address string in textual presentation.
String getHostName()
5
Gets the host name for this IP address.
static InetAddress InetAddress getLocalHost()
6
Returns the local host.
String toString()
7
Converts this IP address to a String.
Socket Client Example
The following GreetingClient is a client program that connects to a server by using a socket
and sends a greeting, and then waits for a response.
// File Name GreetingClient.java
import java.net.*;
import java.io.*;
public class GreetingClient
{
public static void main(String [] args)
476Java
{
String serverName = args[0];
int port = Integer.parseInt(args[1]);
try
{
System.out.println("Connecting to " + serverName +
" on port " + port);
Socket client = new Socket(serverName, port);
System.out.println("Just connected to "
+ client.getRemoteSocketAddress());
OutputStream outToServer = client.getOutputStream();
DataOutputStream out = new DataOutputStream(outToServer);
out.writeUTF("Hello from "
+ client.getLocalSocketAddress());
InputStream inFromServer = client.getInputStream();
DataInputStream in =
new DataInputStream(inFromServer);
System.out.println("Server says " + in.readUTF());
client.close();
}catch(IOException e)
{
e.printStackTrace();
}
}
}
477Java
Socket Server Example
The following GreetingServer program is an example of a server application that uses the
Socket class to listen for clients on a port number specified by a command-line argument:
// File Name GreetingServer.java
import java.net.*;
import java.io.*;
public class GreetingServer extends Thread
{
private ServerSocket serverSocket;
public GreetingServer(int port) throws IOException
{
serverSocket = new ServerSocket(port);
serverSocket.setSoTimeout(10000);
}
public void run()
{
while(true)
{
try
{
System.out.println("Waiting for client on port " +
serverSocket.getLocalPort() + "...");
Socket server = serverSocket.accept();
System.out.println("Just connected to "
+ server.getRemoteSocketAddress());
DataInputStream in =
new DataInputStream(server.getInputStream());
System.out.println(in.readUTF());
DataOutputStream out =
new DataOutputStream(server.getOutputStream());
out.writeUTF("Thank you for connecting to "
+ server.getLocalSocketAddress() + "\nGoodbye!");
server.close();
}catch(SocketTimeoutException s)
478Java
{
System.out.println("Socket timed out!");
break;
}catch(IOException e)
{
e.printStackTrace();
break;
}
}
}
public static void main(String [] args)
{
int port = Integer.parseInt(args[0]);
try
{
Thread t = new GreetingServer(port);
t.start();
}catch(IOException e)
{
e.printStackTrace();
}
}
}
Compile the client and the server and then start the server as follows:
$ java GreetingServer 6066
Waiting for client on port 6066...
Check the client program as follows:
$ java GreetingClient localhost 6066
Connecting to localhost on port 6066
Just connected to localhost/127.0.0.1:6066
Server says Thank you for connecting to /127.0.0.1:6066
Goodbye!
47933.
Java – Sending E-mail
Java
To send an e-mail using your Java Application is simple enough but to start with you should
have JavaMail API and Java Activation Framework (JAF) installed on your machine.
 You can download latest version of JavaMail (Version 1.2) from Java's standard
website.
 You can download latest version of JAF (Version 1.1.1) from Java's standard
website.
Download and unzip these files, in the newly created top level directories you will find a
number of jar files for both the applications. You need to add mail.jar
and activation.jar files in your CLASSPATH.
Send a Simple E-mail
Here is an example to send a simple e-mail from your machine. It is assumed that
your localhost is connected to the Internet and capable enough to send an e-mail.
// File Name SendEmail.java
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;
public class SendEmail
{
public static void main(String [] args)
{
// Recipient's email ID needs to be mentioned.
String to = "abcd@gmail.com";
// Sender's email ID needs to be mentioned
String from = "web@gmail.com";
// Assuming you are sending email from localhost
String host = "localhost";
480Java
// Get system properties
Properties properties = System.getProperties();
// Setup mail server
properties.setProperty("mail.smtp.host", host);
// Get the default Session object.
Session session = Session.getDefaultInstance(properties);
try{
// Create a default MimeMessage object.
MimeMessage message = new MimeMessage(session);
// Set From: header field of the header.
message.setFrom(new InternetAddress(from));
// Set To: header field of the header.
message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
// Set Subject: header field
message.setSubject("This is the Subject Line!");
// Now set the actual message
message.setText("This is actual message");
// Send message
Transport.send(message);
System.out.println("Sent message successfully....");
}catch (MessagingException mex) {
mex.printStackTrace();
}
}
}
Compile and run this program to send a simple e-mail:
$ java SendEmail
Sent message successfully....
481Java
If you want to send an e-mail to multiple recipients then the following methods would be
used to specify multiple e-mail IDs:
void addRecipients(Message.RecipientType type, Address[] addresses)throws
MessagingException
Here is the description of the parameters:
 type: This would be set to TO, CC or BCC. Here CC represents Carbon Copy and
BCC represents Black Carbon Copy. ExampleMessage.RecipientType.TO
 addresses: This is an array of e-mail ID. You would need to use InternetAddress()
method while specifying email IDs.
Send an HTML E-mail
Here is an example to send an HTML e-mail from your machine. Here it is assumed that
your localhost is connected to the Internet and capable enough to send an e-mail.
This example is very similar to the previous one, except here we are using setContent()
method to set content whose second argument is "text/html" to specify that the HTML
content is included in the message.
Using this example, you can send as big as HTML content you like.
// File Name SendHTMLEmail.java
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;
public class SendHTMLEmail
{
public static void main(String [] args)
{
// Recipient's email ID needs to be mentioned.
String to = "abcd@gmail.com";
// Sender's email ID needs to be mentioned
String from = "web@gmail.com";
482Java
// Assuming you are sending email from localhost
String host = "localhost";
// Get system properties
Properties properties = System.getProperties();
// Setup mail server
properties.setProperty("mail.smtp.host", host);
// Get the default Session object.
Session session = Session.getDefaultInstance(properties);
try{
// Create a default MimeMessage object.
MimeMessage message = new MimeMessage(session);
// Set From: header field of the header.
message.setFrom(new InternetAddress(from));
// Set To: header field of the header.
message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
// Set Subject: header field
message.setSubject("This is the Subject Line!");
// Send the actual HTML message, as big as you like
message.setContent("<h1>This is actual message</h1>", "text/html" );
// Send message
Transport.send(message);
System.out.println("Sent message successfully....");
}catch (MessagingException mex) {
mex.printStackTrace();
}
}
}
Compile and run this program to send an HTML e-mail:
483Java
$ java SendHTMLEmail
Sent message successfully....
Send Attachment in E-mail
Here is an example to send an e-mail with attachment from your machine. Here it is
assumed that your localhost is connected to the internet and capable enough to send an
e-mail.
// File Name SendFileEmail.java
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*;
import javax.activation.*;
public class SendFileEmail
{
public static void main(String [] args)
{
// Recipient's email ID needs to be mentioned.
String to = "abcd@gmail.com";
// Sender's email ID needs to be mentioned
String from = "web@gmail.com";
// Assuming you are sending email from localhost
String host = "localhost";
// Get system properties
Properties properties = System.getProperties();
// Setup mail server
properties.setProperty("mail.smtp.host", host);
// Get the default Session object.
Session session = Session.getDefaultInstance(properties);
484Java
try{
// Create a default MimeMessage object.
MimeMessage message = new MimeMessage(session);
// Set From: header field of the header.
message.setFrom(new InternetAddress(from));
// Set To: header field of the header.
message.addRecipient(Message.RecipientType.TO,
new InternetAddress(to));
// Set Subject: header field
message.setSubject("This is the Subject Line!");
// Create the message part
BodyPart messageBodyPart = new MimeBodyPart();
// Fill the message
messageBodyPart.setText("This is message body");
// Create a multipar message
Multipart multipart = new MimeMultipart();
// Set text message part
multipart.addBodyPart(messageBodyPart);
// Part two is attachment
messageBodyPart = new MimeBodyPart();
String filename = "file.txt";
DataSource source = new FileDataSource(filename);
messageBodyPart.setDataHandler(new DataHandler(source));
messageBodyPart.setFileName(filename);
multipart.addBodyPart(messageBodyPart);
// Send the complete message parts
message.setContent(multipart );
// Send message
485Java
Transport.send(message);
System.out.println("Sent message successfully....");
}catch (MessagingException mex) {
mex.printStackTrace();
}
}
}
Compile and run this program to send an HTML e-mail:
$ java SendFileEmail
Sent message successfully....
User Authentication Part
If it is required to provide user ID and Password to the e-mail server for authentication
purpose, then you can set these properties as follows:
props.setProperty("mail.user", "myuser");
props.setProperty("mail.password", "mypwd");
Rest of the e-mail sending mechanism would remain as explained above.
48634.
Java – Multithreading
Java
Java is a multi-threaded programming language which means we can develop multi-
threaded program using Java. A multi-threaded program contains two or more parts that
can run concurrently and each part can handle a different task at the same time making
optimal use of the available resources specially when your computer has multiple CPUs.
By definition, multitasking is when multiple processes share common processing resources
such as a CPU. Multi-threading extends the idea of multitasking into applications where
you can subdivide specific operations within a single application into individual threads.
Each of the threads can run in parallel. The OS divides processing time not only among
different applications, but also among each thread within an application.
Multi-threading enables you to write in a way where multiple activities can proceed
concurrently in the same program.
Life Cycle of a Thread
A thread goes through various stages in its life cycle. For example, a thread is born,
started, runs, and then dies. The following diagram shows the complete life cycle of a
thread.
Following are the stages of the life cycle:
 New: A new thread begins its life cycle in the new state. It remains in this state
until the program starts the thread. It is also referred to as a born thread.
 Runnable: After a newly born thread is started, the thread becomes runnable. A
thread in this state is considered to be executing its task.
487Java



Waiting: Sometimes, a thread transitions to the waiting state while the thread
waits for another thread to perform a task. A thread transitions back to the
runnable state only when another thread signals the waiting thread to continue
executing.
Timed Waiting: A runnable thread can enter the timed waiting state for a specified
interval of time. A thread in this state transitions back to the runnable state when
that time interval expires or when the event it is waiting for occurs.
Terminated (Dead): A runnable thread enters the terminated state when it
completes its task or otherwise terminates.
Thread Priorities
Every Java thread has a priority that helps the operating system determine the order in
which threads are scheduled.
Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and
MAX_PRIORITY (a constant of 10). By default, every thread is given priority
NORM_PRIORITY (a constant of 5).
Threads with higher priority are more important to a program and should be allocated
processor time before lower-priority threads. However, thread priorities cannot guarantee
the order in which threads execute and are very much platform dependent.
Create a Thread by Implementing a Runnable Interface
If your class is intended to be executed as a thread then you can achieve this by
implementing a Runnable interface. You will need to follow three basic steps:
Step 1
As a first step, you need to implement a run() method provided by a Runnable interface.
This method provides an entry point for the thread and you will put your complete business
logic inside this method. Following is a simple syntax of the run() method:
public void run( )
Step 2
As a second step, you will instantiate a Thread object using the following constructor:
Thread(Runnable threadObj, String threadName);
Where, threadObj is an instance of a class that implements the Runnable interface
and threadName is the name given to the new thread.
Step 3
Once a Thread object is created, you can start it by calling start( ) method, which
executes a call to run( ) method. Following is a simple syntax of start() method:
488Java
void start( );
Example
Here is an example that creates a new thread and starts running it:
class RunnableDemo implements Runnable {
private Thread t;
private String threadName;
RunnableDemo( String name){
threadName = name;
System.out.println("Creating " +
threadName );
}
public void run() {
System.out.println("Running " +
threadName );
try {
for(int i = 4; i > 0; i--) {
System.out.println("Thread: " + threadName + ", " + i);
// Let the thread sleep for a while.
Thread.sleep(50);
}
} catch (InterruptedException e) {
System.out.println("Thread " +
threadName + " interrupted.");
}
System.out.println("Thread " +
threadName + " exiting.");
}
public void start ()
{
System.out.println("Starting " +
threadName );
if (t == null)
{
t = new Thread (this, threadName);
t.start ();
}
}
}
489Java
public class TestThread {
public static void main(String args[]) {
RunnableDemo R1 = new RunnableDemo( "Thread-1");
R1.start();
RunnableDemo R2 = new RunnableDemo( "Thread-2");
R2.start();
}
}
This will produce the following result:
Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
Create a Thread by Extending a Thread Class
The second way to create a thread is to create a new class that extends Thread class
using the following two simple steps. This approach provides more flexibility in handling
multiple threads created using available methods in Thread class.
490Java
Step 1
You will need to override run( ) method available in Thread class. This method provides
an entry point for the thread and you will put your complete business logic inside this
method. Following is a simple syntax of run() method:
public void run( )
Step 2
Once Thread object is created, you can start it by calling start( ) method, which executes
a call to run( ) method. Following is a simple syntax of start() method:
void start( );
Example
Here is the preceding program rewritten to extend the Thread:
class ThreadDemo extends Thread {
private Thread t;
private String threadName;
ThreadDemo( String name){
threadName = name;
System.out.println("Creating " +
threadName );
}
public void run() {
System.out.println("Running " +
threadName );
try {
for(int i = 4; i > 0; i--) {
System.out.println("Thread: " + threadName + ", " + i);
// Let the thread sleep for a while.
Thread.sleep(50);
}
} catch (InterruptedException e) {
System.out.println("Thread " +
threadName + " interrupted.");
}
System.out.println("Thread " +
threadName + " exiting.");
}
491Java
public void start ()
{
System.out.println("Starting " +
threadName );
if (t == null)
{
t = new Thread (this, threadName);
t.start ();
}
}
}
public class TestThread {
public static void main(String args[]) {
ThreadDemo T1 = new ThreadDemo( "Thread-1");
T1.start();
ThreadDemo T2 = new ThreadDemo( "Thread-2");
T2.start();
}
}
This will produce the following result:
Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
492Java
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
Thread Methods
Following is the list of important methods available in the Thread class.
Sr.
No.
Methods with Description
public void start()
1
Starts the thread in a separate path of execution, then invokes the run() method
on this Thread object.
public void run()
2
If this Thread object was instantiated using a separate Runnable target, the run() method is invoked
on that Runnable object.
public final void setName(String name)
3
Changes the name of the Thread object. There is also a getName() method for
retrieving the name.
public final void setPriority(int priority)
4
Sets the priority of this Thread object. The possible values are between 1 and
10.
public final void setDaemon(boolean on)
5
A parameter of true denotes this Thread as a daemon thread.
public final void join(long millisec)
6
The current thread invokes this method on a second thread, causing the current
thread to block until the second thread terminates or the specified number of
milliseconds passes.
493Java
public void interrupt()
7
Interrupts this thread, causing it to continue execution if it was blocked for any
reason.
public final boolean isAlive()
8
Returns true if the thread is alive, which is any time after the thread has been
started but before it runs to completion.
The previous methods are invoked on a particular Thread object. The following methods
in the Thread class are static. Invoking one of the static methods performs the operation
on the currently running thread.
Sr.
No.
Methods with Description
public static void yield()
1
Causes the currently running thread to yield to any other threads of the same
priority that are waiting to be scheduled.
public static void sleep(long millisec)
2
Causes the currently running thread to block for at least the specified number
of milliseconds.
public static boolean holdsLock(Object x)
3
Returns true if the current thread holds the lock on the given Object.
public static Thread currentThread()
4
Returns a reference to the currently running thread, which is the thread that
invokes this method.
public static void dumpStack()
5
Prints the stack trace for the currently running thread, which is useful when
debugging a multithreaded application.
494Java
Example
The following ThreadClassDemo program demonstrates some of these methods of the
Thread class. Consider a class DisplayMessage which implements Runnable:
// File Name : DisplayMessage.java
// Create a thread to implement Runnable
public class DisplayMessage implements Runnable
{
private String message;
public DisplayMessage(String message)
{
this.message = message;
}
public void run()
{
while(true)
{
System.out.println(message);
}
}
}
Following is another class which extends the Thread class:
// File Name : GuessANumber.java
// Create a thread to extentd Thread
public class GuessANumber extends Thread
{
private int number;
public GuessANumber(int number)
{
this.number = number;
}
495Java
public void run()
{
int counter = 0;
int guess = 0;
do
{
guess = (int) (Math.random() * 100 + 1);
System.out.println(this.getName()
+ " guesses " + guess);
counter++;
}while(guess != number);
System.out.println("** Correct! " + this.getName()
+ " in " + counter + " guesses.**");
}
}
Following is the main program, which makes use of the above-defined classes:
// File Name : ThreadClassDemo.java
public class ThreadClassDemo
{
public static void main(String [] args)
{
Runnable hello = new DisplayMessage("Hello");
Thread thread1 = new Thread(hello);
thread1.setDaemon(true);
thread1.setName("hello");
System.out.println("Starting hello thread...");
thread1.start();
Runnable bye = new DisplayMessage("Goodbye");
Thread thread2 = new Thread(bye);
thread2.setPriority(Thread.MIN_PRIORITY);
thread2.setDaemon(true);
System.out.println("Starting goodbye thread...");
thread2.start();
496Java
System.out.println("Starting thread3...");
Thread thread3 = new GuessANumber(27);
thread3.start();
try
{
thread3.join();
}catch(InterruptedException e)
{
System.out.println("Thread interrupted.");
}
System.out.println("Starting thread4...");
Thread thread4 = new GuessANumber(75);
thread4.start();
System.out.println("main() is ending...");
}
}
This will produce the following result. You can try this example again and again and you
will get a different result every time.
Starting hello thread...
Starting goodbye thread...
Hello
Hello
Hello
Hello
Hello
Hello
Goodbye
Goodbye
Goodbye
Goodbye
Goodbye
.......
497Java
Major Java Multithreading Concepts
While doing Multithreading programming in Java, you would need to have the following
concepts very handy:
 What is thread synchronization?
 Handling interthread communication
 Handling thread deadlock
 Major thread operations
Thread Synchronization
When we start two or more threads within a program, there may be a situation when
multiple threads try to access the same resource and finally they can produce unforeseen
result due to concurrency issues. For example, if multiple threads try to write within a
same file then they may corrupt the data because one of the threads can override data or
while one thread is opening the same file at the same time another thread might be closing
the same file.
So there is a need to synchronize the action of multiple threads and make sure that only
one thread can access the resource at a given point in time. This is implemented using a
concept called monitors. Each object in Java is associated with a monitor, which a thread
can lock or unlock. Only one thread at a time may hold a lock on a monitor.
Java programming language provides a very handy way of creating threads and
synchronizing their task by using synchronized blocks. You keep shared resources within
this block. Following is the general form of the synchronized statement:
synchronized(objectidentifier) {
// Access shared variables and other shared resources
}
Here, the objectidentifier is a reference to an object whose lock associates with the
monitor that the synchronized statement represents. Now we are going to see two
examples, where we will print a counter using two different threads. When threads are not
synchronized, they print counter value which is not in sequence, but when we print counter
by putting inside synchronized() block, then it prints counter very much in sequence for
both the threads.
498Java
Multithreading Example without Synchronization
Here is a simple example which may or may not print counter value in sequence and every
time we run it, it produces a different result based on CPU availability to a thread.
class PrintDemo {
public void printCount(){
try {
for(int i = 5; i > 0; i--) {
System.out.println("Counter
---
"
+ i );
}
} catch (Exception e) {
System.out.println("Thread
interrupted.");
}
}
}
class ThreadDemo extends Thread {
private Thread t;
private String threadName;
PrintDemo
PD;
ThreadDemo( String name,
PrintDemo pd){
threadName = name;
PD = pd;
}
public void run() {
PD.printCount();
System.out.println("Thread " +
threadName + " exiting.");
}
public void start ()
{
System.out.println("Starting " +
threadName );
if (t == null)
{
t = new Thread (this, threadName);
t.start ();
}
}
499Java
}
public class TestThread {
public static void main(String args[]) {
PrintDemo PD = new PrintDemo();
ThreadDemo T1 = new ThreadDemo( "Thread - 1 ", PD );
ThreadDemo T2 = new ThreadDemo( "Thread - 2 ", PD );
T1.start();
T2.start();
// wait for threads to end
try {
T1.join();
T2.join();
} catch( Exception e) {
System.out.println("Interrupted");
}
}
}
This produces a different result every time you run this program:
Starting Thread - 1
Starting Thread - 2
Counter --- 5
Counter --- 4
Counter --- 3
Counter --- 5
Counter --- 2
Counter --- 1
Counter --- 4
Thread Thread - 1
exiting.
500Java
Counter --- 3
Counter --- 2
Counter --- 1
Thread Thread - 2
exiting.
Multithreading Example with Synchronization
Here is the same example which prints counter value in sequence and every time we run
it, it produces the same result.
class PrintDemo {
public void printCount(){
try {
for(int i = 5; i > 0; i--) {
System.out.println("Counter
---
"
+ i );
}
} catch (Exception e) {
System.out.println("Thread
interrupted.");
}
}
}
class ThreadDemo extends Thread {
private Thread t;
private String threadName;
PrintDemo
PD;
ThreadDemo( String name,
PrintDemo pd){
threadName = name;
PD = pd;
}
public void run() {
synchronized(PD) {
PD.printCount();
}
501Java
System.out.println("Thread " +
threadName + " exiting.");
}
public void start ()
{
System.out.println("Starting " +
threadName );
if (t == null)
{
t = new Thread (this, threadName);
t.start ();
}
}
}
public class TestThread {
public static void main(String args[]) {
PrintDemo PD = new PrintDemo();
ThreadDemo T1 = new ThreadDemo( "Thread - 1 ", PD );
ThreadDemo T2 = new ThreadDemo( "Thread - 2 ", PD );
T1.start();
T2.start();
// wait for threads to end
try {
T1.join();
T2.join();
} catch( Exception e) {
System.out.println("Interrupted");
}
}
}
502Java
This produces the same result every time you run this program:
Starting Thread - 1
Starting Thread - 2
Counter --- 5
Counter --- 4
Counter --- 3
Counter --- 2
Counter --- 1
Thread Thread - 1
Counter --- 5
Counter --- 4
Counter --- 3
Counter --- 2
Counter --- 1
Thread Thread - 2
exiting.
exiting.
Interthread Communication
If you are aware of interprocess communication then it will be easy for you to understand
interthread communication. Interthread communication is important when you develop an
application where two or more threads exchange some information.
There are three simple methods and a little trick which makes thread communication
possible. All the three methods are listed below:
Sr. No.
1
Methods with Description
public void wait()
Causes the current thread to wait until another thread invokes the notify().
public void notify()
2
Wakes up a single thread that is waiting on this object's monitor.
public void notifyAll()
3
Wakes up all the threads that called wait( ) on the same object.
These methods have been implemented as final methods in Object, so they are available
in all the classes. All three methods can be called only from within
a synchronized context.
503Java
Example
This examples shows how two threads can communicate using wait() and
notify() method. You can create a complex system using the same concept.
class Chat {
boolean flag = false;
public synchronized void Question(String msg) {
if (flag) {
try {
wait();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
System.out.println(msg);
flag = true;
notify();
}
public synchronized void Answer(String msg) {
if (!flag) {
try {
wait();
} catch (InterruptedException e) {
e.printStackTrace();
}
}
System.out.println(msg);
flag = false;
notify();
}
}
class T1 implements Runnable {
Chat m;
String[] s1 = { "Hi", "How are you ?", "I am also doing fine!" };
504Java
public T1(Chat m1) {
this.m = m1;
new Thread(this, "Question").start();
}
public void run() {
for (int i = 0; i < s1.length; i++) {
m.Question(s1[i]);
}
}
}
class T2 implements Runnable {
Chat m;
String[] s2 = { "Hi", "I am good, what about you?", "Great!" };
public T2(Chat m2) {
this.m = m2;
new Thread(this, "Answer").start();
}
public void run() {
for (int i = 0; i < s2.length; i++) {
m.Answer(s2[i]);
}
}
}
public class TestThread {
public static void main(String[] args) {
Chat m = new Chat();
new T1(m);
new T2(m);
}
}
505Java
When the above program is complied and executed, it produces the following result:
Hi
Hi
How are you ?
I am good, what about you?
I am also doing fine!
Great!
Above
example
has
been
taken
and
then
modified
from
[http://stackoverflow.com/questions/2170520/inter-thread-communication-in-java]
Thread Deadlock
Deadlock describes a situation where two or more threads are blocked forever, waiting for
each other. Deadlock occurs when multiple threads need the same locks but obtain them
in different order. A Java multithreaded program may suffer from the deadlock condition
because the synchronized keyword causes the executing thread to block while waiting
for the lock, or monitor, associated with the specified object. Here is an example.
Example
public class TestThread {
public static Object Lock1 = new Object();
public static Object Lock2 = new Object();
public static void main(String args[]) {
ThreadDemo1 T1 = new ThreadDemo1();
ThreadDemo2 T2 = new ThreadDemo2();
T1.start();
T2.start();
}
private static class ThreadDemo1 extends Thread {
public void run() {
synchronized (Lock1) {
System.out.println("Thread 1: Holding lock 1...");
try { Thread.sleep(10); }
catch (InterruptedException e) {}
System.out.println("Thread 1: Waiting for lock 2...");
506Java
synchronized (Lock2) {
System.out.println("Thread 1: Holding lock 1 & 2...");
}
}
}
}
private static class ThreadDemo2 extends Thread {
public void run() {
synchronized (Lock2) {
System.out.println("Thread 2: Holding lock 2...");
try { Thread.sleep(10); }
catch (InterruptedException e) {}
System.out.println("Thread 2: Waiting for lock 1...");
synchronized (Lock1) {
System.out.println("Thread 2: Holding lock 1 & 2...");
}
}
}
}
}
When you compile and execute the above program, you find a deadlock situation and
following is the output produced by the program:
Thread 1: Holding lock 1...
Thread 2: Holding lock 2...
Thread 1: Waiting for lock 2...
Thread 2: Waiting for lock 1...
The above program will hang forever because neither of the threads in position to proceed
and waiting for each other to release the lock, so you can come out of the program by
pressing CTRL+C.
507Java
Deadlock Solution Example
Let's change the order of the lock and run of the same program to see if both the threads
still wait for each other:
public class TestThread {
public static Object Lock1 = new Object();
public static Object Lock2 = new Object();
public static void main(String args[]) {
ThreadDemo1 T1 = new ThreadDemo1();
ThreadDemo2 T2 = new ThreadDemo2();
T1.start();
T2.start();
}
private static class ThreadDemo1 extends Thread {
public void run() {
synchronized (Lock1) {
System.out.println("Thread 1: Holding lock 1...");
try { Thread.sleep(10); }
catch (InterruptedException e) {}
System.out.println("Thread 1: Waiting for lock 2...");
synchronized (Lock2) {
System.out.println("Thread 1: Holding lock 1 & 2...");
}
}
}
}
private static class ThreadDemo2 extends Thread {
public void run() {
synchronized (Lock1) {
System.out.println("Thread 2: Holding lock 1...");
try { Thread.sleep(10); }
catch (InterruptedException e) {}
System.out.println("Thread 2: Waiting for lock 2...");
508Java
synchronized (Lock2) {
System.out.println("Thread 2: Holding lock 1 & 2...");
}
}
}
}
}
So just changing the order of the locks prevent the program in going into a deadlock
situation and completes with the following result:
Thread 1: Holding lock 1...
Thread 1: Waiting for lock 2...
Thread 1: Holding lock 1 & 2...
Thread 2: Holding lock 1...
Thread 2: Waiting for lock 2...
Thread 2: Holding lock 1 & 2...
The above example is to just make the concept clear, however, it is a complex concept
and you should deep dive into it before you develop your applications to deal with deadlock
situations.
Thread Control
Core Java provides complete control over multithreaded program. You can develop a
multithreaded program which can be suspended, resumed, or stopped completely based
on your requirements. There are various static methods which you can use on thread
objects to control their behavior. Following table lists down those methods:
Sr. No.
Methods with Description
public void suspend()
1
This method puts a thread in the suspended state and can be resumed using
resume() method.
public void stop()
2
This method stops a thread completely.
public void resume()
3
This method resumes a thread, which was suspended using suspend()
method.
509Java
public void wait()
4
Causes the current thread to wait until another thread invokes the notify().
public void notify()
5
Wakes up a single thread that is waiting on this object's monitor.
Be aware that the latest versions of Java has deprecated the usage of suspend( ), resume(
), and stop( ) methods and so you need to use available alternatives.
Example
class RunnableDemo implements Runnable {
public Thread t;
private String threadName;
boolean suspended = false;
RunnableDemo( String name){
threadName = name;
System.out.println("Creating " +
threadName );
}
public void run() {
System.out.println("Running " +
threadName );
try {
for(int i = 10; i > 0; i--) {
System.out.println("Thread: " + threadName + ", " + i);
// Let the thread sleep for a while.
Thread.sleep(300);
synchronized(this) {
while(suspended) {
wait();
}
}
}
510Java
} catch (InterruptedException e) {
System.out.println("Thread " +
threadName + " interrupted.");
}
System.out.println("Thread " +
threadName + " exiting.");
}
public void start ()
{
System.out.println("Starting " +
threadName );
if (t == null)
{
t = new Thread (this, threadName);
t.start ();
}
}
void suspend() {
suspended = true;
}
synchronized void resume() {
suspended = false;
notify();
}
}
public class TestThread {
public static void main(String args[]) {
RunnableDemo R1 = new RunnableDemo( "Thread-1");
R1.start();
RunnableDemo R2 = new RunnableDemo( "Thread-2");
R2.start();
try {
Thread.sleep(1000);
R1.suspend();
System.out.println("Suspending First Thread");
Thread.sleep(1000);
511Java
R1.resume();
System.out.println("Resuming First Thread");
R2.suspend();
System.out.println("Suspending thread Two");
Thread.sleep(1000);
R2.resume();
System.out.println("Resuming thread Two");
} catch (InterruptedException e) {
System.out.println("Main thread Interrupted");
}
try {
System.out.println("Waiting for threads to finish.");
R1.t.join();
R2.t.join();
} catch (InterruptedException e) {
System.out.println("Main thread Interrupted");
}
System.out.println("Main thread exiting.");
}
}
The above program produces the following output:
Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 10
Running Thread-2
Thread: Thread-2, 10
Thread: Thread-1, 9
Thread: Thread-2, 9
Thread: Thread-1, 8
Thread: Thread-2, 8
Thread: Thread-1, 7
512Java
Thread: Thread-2, 7
Suspending First Thread
Thread: Thread-2, 6
Thread: Thread-2, 5
Thread: Thread-2, 4
Resuming First Thread
Suspending thread Two
Thread: Thread-1, 6
Thread: Thread-1, 5
Thread: Thread-1, 4
Thread: Thread-1, 3
Resuming thread Two
Thread: Thread-2, 3
Waiting for threads to finish.
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
ain thread exiting.
51335.
Java – Applet Basics
Java
An applet is a Java program that runs in a Web browser. An applet can be a fully functional
Java application because it has the entire Java API at its disposal.
There are some important differences between an applet and a standalone Java
application, including the following:
 An applet is a Java class that extends the java.applet.Applet class.
 A main() method is not invoked on an applet, and an applet class will not define
main().
 Applets are designed to be embedded within an HTML page.
 When a user views an HTML page that contains an applet, the code for the applet
is downloaded to the user's machine.
 A JVM is required to view an applet. The JVM can be either a plug-in of the Web
browser or a separate runtime environment.
 The JVM on the user's machine creates an instance of the applet class and invokes
various methods during the applet's lifetime.
 Applets have strict security rules that are enforced by the Web browser. The
security of an applet is often referred to as sandbox security, comparing the applet
to a child playing in a sandbox with various rules that must be followed.
 Other classes that the applet needs can be downloaded in a single Java Archive
(JAR) file.
Life Cycle of an Applet
Four methods in the Applet class gives you the framework on which you build any serious
applet:
 init: This method is intended for whatever initialization is needed for your applet.
It is called after the param tags inside the applet tag have been processed.
 start: This method is automatically called after the browser calls the init method.
It is also called whenever the user returns to the page containing the applet after
having gone off to other pages.
 stop: This method is automatically called when the user moves off the page on
which the applet sits. It can, therefore, be called repeatedly in the same applet.
514Java

destroy: This method is only called when the browser shuts down normally.
Because applets are meant to live on an HTML page, you should not normally leave
resources behind after a user leaves the page that contains the applet.
paint: Invoked immediately after the start() method, and also any time the applet
needs to repaint itself in the browser. The paint() method is actually inherited from
the java.awt.

A "Hello, World" Applet
Following is a simple applet named HelloWorldApplet.java:
import java.applet.*;
import java.awt.*;
public class HelloWorldApplet extends Applet
{
public void paint (Graphics g)
{
g.drawString ("Hello World", 25, 50);
}
}
These import statements bring the classes into the scope of our applet class:
 java.applet.Applet
 java.awt.Graphics
Without those import statements, the Java compiler would not recognize the classes Applet
and Graphics, which the applet class refers to.
The Applet Class
Every applet is an extension of the java.applet.Applet class. The base Applet class provides
methods that a derived Applet class may call to obtain information and services from the
browser context.
These include methods that do the following:
 Get applet parameters
 Get the network location of the HTML file that contains the applet
 Get the network location of the applet class directory
 Print a status message in the browser
 Fetch an image
 Fetch an audio clip
 Play an audio clip
515Java

Resize the applet
Additionally, the Applet class provides an interface by which the viewer or browser obtains
information about the applet and controls the applet's execution. The viewer may:
 Request information about the author, version, and copyright of the applet
 Request a description of the parameters the applet recognizes
 Initialize the applet
 Destroy the applet
 Start the applet's execution
 Stop the applet's execution
The Applet class provides default implementations of each of these methods. Those
implementations may be overridden as necessary.
The "Hello, World" applet is complete as it stands. The only method overridden is the paint
method.
Invoking an Applet
An applet may be invoked by embedding directives in an HTML file and viewing the file
through an applet viewer or Java-enabled browser.
The <applet> tag is the basis for embedding an applet in an HTML file. Following is an
example that invokes the "Hello, World" applet:
<html>
<title>The Hello, World Applet</title>
<hr>
<applet code="HelloWorldApplet.class" width="320" height="120">
If your browser was Java-enabled, a "Hello, World"
message would appear here.
</applet>
<hr>
</html>
Note: You can refer to HTML Applet Tag to understand more about calling applet from
HTML.
HTML <applet> Tag
Description: The HTML <applet> tag specifies an applet. It is used for embedding a Java
applet within an HTML document. It is not supported in HTML5.
516Java
Example
<!DOCTYPE html>
<html>
<head>
<title>HTML applet Tag</title>
</head>
<body>
<applet code="newClass.class" width="300" height="200">
</applet>
</body>
</html>
Here is the newClass.java file:
import java.applet.*;
import java.awt.*;
public class newClass extends Applet
{
public void paint (Graphics gh)
{
g.drawString("Tutorialspoint.com", 300, 150);
}
}
This will produce the following result:
Global Attributes
This tag supports all the global attributes described in - HTML Attribute Reference
517Java
HTML Attribute Reference
There are few HTML attributes which are standard and associated to all the HTML tags.
These attributes are listed here with a brief description.
Global Attributes: Not valid in base, head, html, meta, param, script, style, and title
elements.
Attribute
HTML-5
Description
Specifies a shortcut key for an element to be used in
place of keyboard.
accesskey
class
The class of the element.
contenteditable Yes Boolean attribute to specify whether the element is
editable or not.
contextmenu Yes Specifies a context menu for an element.
data-* Yes Used to store custom data associated with the element.
draggable Yes Boolean attribute to specify whether the element can be
dragged or not.
dropzone Yes Specifies whether the dragged data is copied, moved,
or linked, when dropped.
hidden Yes Specifies whether the element should be visible or not.
id
spellcheck
A unique id for the element.
Yes
style
An inline style definition.
tabindex
Specifies the tab order of an element.
title
translate
Specifies if the element must have it's spelling or
grammar checked.
A text to display in a tool tip.
Yes
Boolean attribute specifies whether the content of an
element should be translated or not.
Language Attributes
The lang attribute indicates the language being used for the enclosed content. The
language is identified using the ISO standard language abbreviations, such
as fr for French, en for English,
and
so
on.
RFC
1766
(http://www.ietf.org/rfc/rfc1766.txt) describes these codes and their formats.
518Java
Not valid in base, br, frame, frameset, hr, iframe, param, and script elements.
Attribute
Value
Description
dir ltr | rtl Sets the text direction
lang language_code Sets the language code
Specific Attributes
The HTML <> tag also supports following additional attributes:
Attribute Value Description
align URL Deprecated - Defines the text alignment around the
applet.
alt URL Alternate text to be displayed in case the browser
does not support the applet.
archive URL Applet path when it is stored in a Java Archive, i.e.
jar file.
code URL A URL that points to the class of the applet.
codebase URL Indicates the base URL of the applet if the code
attribute is relative.
height pixels Height to display the applet.
hspace pixels Deprecated - Defines the left and right spacing
around the applet.
name name Defines a unique name for the applet.
object name Specifies the resource that contains a serialized
representation of the applet's state.
title test Additional information to be displayed in tool tip of
the mouse.
vspace pixels Deprecated - Amount of white space to be inserted
above and below the object.
width pixels Width to display the applet.
519Java
Event Attributes
This tag supports all the event attributes described in - HTML Events Reference
HTML Events Reference
When users visit your website, they do things like click various links, hover mouse over
text and images, etc. These are examples of what we call events in Javascript and VBScript
terminologies.
We can write our event handlers using Javascript or VBScript and can specify some actions
to be taken against these events. Though these are the events, they will be specified as
attributes for the HTML tags.
The HTML 4.01 specification had defined 19 events but later HTML-5 has added many
other events, which we have listed below:
Window Events Attributes
Following events have been introduced in older versions of HTML but all the tags marked
with
are part of HTML-5.
Events
onafterprint
onbeforeprint
onbeforeonload
onerror
onhaschange
onload
onmessage
HTML-5
Description
Triggers after a document is printed.
Triggers before a document is printed.
Triggers before a document loads.
Triggers when an error occurs.
Triggers when a document has changed.
Triggers when a document loads.
Triggers when a message is triggered.
onoffline Triggers when a document goes offline.
ononline Triggers when a document comes online.
onpagehide Triggers when a window is hidden.
onpageshow Triggers when a window becomes visible.
onpopstate Triggers when a window's history changes.
onredo Triggers when a document performs a redo.
520Java
onresize
Triggers when a window is resized.
onstorage
Triggers when a document loads.
onundo
Triggers when a document performs an undo.
onunload
Triggers when a user leaves the document.
Form Events
Following tags have been introduced in older versions of HTML but all the tags marked
with
are part of HTML-5.
Events
HTML-5
Description
onblur Triggers when a window loses focus.
onchange Triggers when an element changes.
oncontextmenu
Triggers when a context menu is triggered.
onfocus
Triggers when a window gets focus.
onformchange
Triggers when a form changes.
onforminput
Triggers when a form gets user input.
oninput
Triggers when an element gets user input.
oninvalid Triggers when an element is invalid.
onreset Triggers when a form is reset.
onselect Triggers when an element is selected.
onsubmit
Triggers when a form is submitted.
Keyboard Events
Events
HTML-5
Description
onkeydown Triggers when a key is pressed.
onkeypress Triggers when a key is pressed and released.
521Java
onkeyup
Triggers when a key is released.
Mouse Events
Following tags have been introduced in older versions of HTML but all the tags marked
with
are part of HTML-5.
Events
onclick
ondblclick
ondrag
ondragend
HTML-
5
Description
Triggers on a mouse click.
Triggers on a mouse double-click.
Triggers when an element is dragged.
Triggers at the end of a drag operation.
ondragenter Triggers when an element has been dragged to a valid drop
target.
ondragleave Triggers when an element leaves a valid drop target.
ondragover Triggers when an element is being dragged over a valid drop
target.
ondragstart Triggers at the start of a drag operation.
ondrop
Triggers when a dragged element is being dropped.
onmousedown Triggers when a mouse button is pressed.
onmousemove Triggers when the mouse pointer moves.
onmouseout Triggers when the mouse pointer moves out of an element.
onmouseover Triggers when the mouse pointer moves over an element.
onmouseup
onmousewheel
onscroll
Triggers when a mouse button is released.
Triggers when the mouse wheel is being rotated.
Triggers when an element's scrollbar is being scrolled.
522Java
Media Events
Following tags have been introduced in older versions of HTML but all the tags marked
with
are part of HTML-5.
Events
onabort
HTML-5
Description
Triggers on an abort event.
oncanplay Triggers when a media can start play, but might have
to stop for buffering.
oncanplaythrough Triggers when a media can be played to the end,
without stopping for buffering.
ondurationchange Triggers when the length of a media is changed.
onemptied
Triggers when a media resource element suddenly
becomes empty.
onended Triggers when a media has reached the end.
onerror Triggers when an error occurs.
onloadeddata
Triggers when media data is loaded.
onloadedmetadata Triggers when the duration and other media data of a
media element is loaded.
onloadstart Triggers when the browser starts loading the media
data.
onpause
onplay
onplaying
Triggers when media data is paused.
Triggers when media data is going to start playing.
Triggers when media data has started playing.
onprogress Triggers when the browser is fetching the media data.
onratechange Triggers when the playing rate of media data has
changed.
onreadystatechange
onseeked
Triggers when the ready-state changes.
Triggers when the seeking attribute of a media
element is no longer true, and the seeking has ended.
523Java
onseeking Triggers when the seeking attribute of a media
element is true, and the seeking has begun.
onstalled Triggers when there is an error in fetching media data.
onsuspend Triggers when the browser has been fetching media
data, but stopped before the entire media file was
fetched.
ontimeupdate
Triggers when media changes its playing position.
onvolumechange Triggers when a media changes the volume, also when
the volume is set to "mute".
onwaiting Triggers when media has stopped playing, but is
expected to resume.
Browser Support
Chrome Firefox IE Opera Safari Android
No Yes Yes No Yes No
The code attribute of the <applet> tag is required. It specifies the Applet class to run.
Width and height are also required to specify the initial size of the panel in which an applet
runs. The applet directive must be closed with an </applet> tag.
If an applet takes parameters, values may be passed for the parameters by adding
<param> tags between <applet> and </applet>. The browser ignores text and other tags
between the applet tags.
Non-Java-enabled browsers do not process <applet> and </applet>. Therefore, anything
that appears between the tags, not related to the applet, is visible in non-Java-enabled
browsers.
The viewer or browser looks for the compiled Java code at the location of the document.
To specify otherwise, use the codebase attribute of the <applet> tag as shown:
<applet codebase="http://amrood.com/applets"
code="HelloWorldApplet.class" width="320" height="120">
If an applet resides in a package other than the default, the holding package must be
specified in the code attribute using the period character (.) to separate package/class
components. For example:
<applet code="mypackage.subpackage.TestApplet.class"
width="320" height="120">
524Java
Getting Applet Parameters
The following example demonstrates how to make an applet respond to setup parameters
specified in the document. This applet displays a checkerboard pattern of black and a
second color.
The second color and the size of each square may be specified as parameters to the applet
within the document.
CheckerApplet gets its parameters in the init() method. It may also get its parameters in
the paint() method. However, getting the values and saving the settings once at the start
of the applet, instead of at every refresh, is convenient and efficient.
The applet viewer or browser calls the init() method of each applet it runs. The viewer
calls init() once, immediately after loading the applet. (Applet.init() is implemented to do
nothing.) Override the default implementation to insert custom initialization code.
The Applet.getParameter() method fetches a parameter given the parameter's name (the
value of a parameter is always a string). If the value is numeric or other non-character
data, the string must be parsed.
The following is a skeleton of CheckerApplet.java:
import java.applet.*;
import java.awt.*;
public class CheckerApplet extends Applet
{
int squareSize = 50;// initialized to default size
public void init () {}
private void parseSquareSize (String param) {}
private Color parseColor (String param) {}
public void paint (Graphics g) {}
}
Here are CheckerApplet's init() and private parseSquareSize() methods:
public void init ()
{
String squareSizeParam = getParameter ("squareSize");
parseSquareSize (squareSizeParam);
String colorParam = getParameter ("color");
Color fg = parseColor (colorParam);
setBackground (Color.black);
setForeground (fg);
}
525Java
private void parseSquareSize (String param)
{
if (param == null) return;
try {
squareSize = Integer.parseInt (param);
}
catch (Exception e) {
// Let default value remain
}
}
The applet calls parseSquareSize() to parse the squareSize parameter. parseSquareSize()
calls the library method Integer.parseInt(), which parses a string and returns an integer.
Integer.parseInt() throws an exception whenever its argument is invalid.
Therefore, parseSquareSize() catches exceptions, rather than allowing the applet to fail
on bad input.
The applet calls parseColor() to parse the color parameter into a Color value. parseColor()
does a series of string comparisons to match the parameter value to the name of a
predefined color. You need to implement these methods to make this applet work.
Specifying Applet Parameters
The following is an example of an HTML file with a CheckerApplet embedded in it. The
HTML file specifies both parameters to the applet by means of the <param> tag.
<html>
<title>Checkerboard Applet</title>
<hr>
<applet code="CheckerApplet.class" width="480" height="320">
<param name="color" value="blue">
<param name="squaresize" value="30">
</applet>
<hr>
</html>
Note: Parameter names are not case sensitive.
Application Conversion to Applets
It is easy to convert a graphical Java application (that is, an application that uses the AWT
and that you can start with the Java program launcher) into an applet that you can embed
in a web page.
526Java
Following are the specific steps for converting an application to an applet.
 Make an HTML page with the appropriate tag to load the applet code.
 Supply a subclass of the JApplet class. Make this class public. Otherwise, the applet
cannot be loaded.
 Eliminate the main method in the application. Do not construct a frame window for
the application. Your application will be displayed inside the browser.
 Move any initialization code from the frame window constructor to the init method
of the applet. You don't need to explicitly construct the applet object. The browser
instantiates it for you and calls the init method.
 Remove the call to setSize; for applets, sizing is done with the width and height
parameters in the HTML file.
 Remove the call to setDefaultCloseOperation. An applet cannot be closed; it
terminates when the browser exits.
 If the application calls setTitle, eliminate the call to the method. Applets cannot
have title bars. (You can, of course, title the web page itself, using the HTML title
tag.)
 Don't call setVisible(true). The applet is displayed automatically.
Event Handling
Applets inherit a group of event-handling methods from the Container class. The Container
class defines several methods, such as processKeyEvent and processMouseEvent, for
handling particular types of events, and then one catch-all method called processEvent.
In order to react to an event, an applet must override the appropriate event-specific
method.
import java.awt.event.MouseListener;
import java.awt.event.MouseEvent;
import java.applet.Applet;
import java.awt.Graphics;
public class ExampleEventHandling extends Applet
implements MouseListener {
StringBuffer strBuffer;
public void init() {
addMouseListener(this);
527Java
strBuffer = new StringBuffer();
addItem("initializing the apple ");
}
public void start() {
addItem("starting the applet ");
}
public void stop() {
addItem("stopping the applet ");
}
public void destroy() {
addItem("unloading the applet");
}
void addItem(String word) {
System.out.println(word);
strBuffer.append(word);
repaint();
}
public void paint(Graphics g) {
//Draw a Rectangle around the applet's display area.
g.drawRect(0, 0,
getWidth() - 1,
getHeight() - 1);
//display the string inside the rectangle.
g.drawString(strBuffer.toString(), 10, 20);
}
public void mouseEntered(MouseEvent event) {
}
528Java
public void mouseExited(MouseEvent event) {
}
public void mousePressed(MouseEvent event) {
}
public void mouseReleased(MouseEvent event) {
}
public void mouseClicked(MouseEvent event) {
addItem("mouse clicked! ");
}
}
Now, let us call this applet as follows:
<html>
<title>Event Handling</title>
<hr>
<applet code="ExampleEventHandling.class"
width="300" height="300">
</applet>
<hr>
</html>
Initially, the applet will display "initializing the applet. Starting the applet." Then once you
click inside the rectangle, "mouse clicked" will be displayed as well.
Displaying Images
An applet can display images of the format GIF, JPEG, BMP, and others. To display an
image within the applet, you use the drawImage() method found in the java.awt.Graphics
class.
Following is an example illustrating all the steps to show images:
import java.applet.*;
import java.awt.*;
import java.net.*;
public class ImageDemo extends Applet
{
private Image image;
private AppletContext context;
public void init()
529Java
{
context = this.getAppletContext();
String imageURL = this.getParameter("image");
if(imageURL == null)
{
imageURL = "java.jpg";
}
try
{
URL url = new URL(this.getDocumentBase(), imageURL);
image = context.getImage(url);
}catch(MalformedURLException e)
{
e.printStackTrace();
// Display in browser status bar
context.showStatus("Could not load image!");
}
}
public void paint(Graphics g)
{
context.showStatus("Displaying image");
g.drawImage(image, 0, 0, 200, 84, null);
g.drawString("www.javalicense.com", 35, 100);
}
}
Now, let us call this applet as follows:
<html>
<title>The ImageDemo applet</title>
<hr>
<applet code="ImageDemo.class" width="300" height="200">
<param name="image" value="java.jpg">
</applet>
<hr>
</html>
530Java
Playing Audio
An applet can play an audio file represented by the AudioClip interface in the java.applet
package. The AudioClip interface has three methods, including:
 public void play(): Plays the audio clip one time, from the beginning.
 public void loop(): Causes the audio clip to replay continually.
 public void stop(): Stops playing the audio clip.
To obtain an AudioClip object, you must invoke the getAudioClip() method of the Applet
class. The getAudioClip() method returns immediately, whether or not the URL resolves to
an actual audio file. The audio file is not downloaded until an attempt is made to play the
audio clip.
Following is an example illustrating all the steps to play an audio:
import java.applet.*;
import java.awt.*;
import java.net.*;
public class AudioDemo extends Applet
{
private AudioClip clip;
private AppletContext context;
public void init()
{
context = this.getAppletContext();
String audioURL = this.getParameter("audio");
if(audioURL == null)
{
audioURL = "default.au";
}
try
{
URL url = new URL(this.getDocumentBase(), audioURL);
clip = context.getAudioClip(url);
}catch(MalformedURLException e)
{
e.printStackTrace();
context.showStatus("Could not load audio file!");
}
}
public void start()
531Java
{
if(clip != null)
{
clip.loop();
}
}
public void stop()
{
if(clip != null)
{
clip.stop();
}
}
}
Now, let us call this applet as follows:
<html>
<title>The ImageDemo applet</title>
<hr>
<applet code="ImageDemo.class" width="0" height="0">
<param name="audio" value="test.wav">
</applet>
<hr>
</html>
You can use test.wav on your PC to test the above example.
53236.
Java – Documentation Comments
Java
The Java language supports three types of comments:
Comment
/* text */
// text
Description
The compiler ignores everything from /* to */.
The compiler ignores everything from // to the end of the line.
/**
documentation
*/
This is a documentation comment and in general its called doc
comment. The JDK javadoc tool uses doc comments when
preparing automatically generated documentation.
This chapter is all about explaining Javadoc. We will see how we can make use of Javadoc
to generate useful documentation for Java code.
What is Javadoc?
Javadoc is a tool which comes with JDK and it is used for generating Java code
documentation in HTML format from Java source code, which requires documentation in a
predefined format.
Following is a simple example where the lines inside /*....*/ are Java multi-line comments.
Similarly, the line which preceeds // is Java single-line comment.
/**
* The HelloWorld program implements an application that
* simply displays "Hello World!" to the standard output.
*
* @author
Zara Ali
* @version 1.0
* @since
2014-03-31
*/
public class HelloWorld {
public static void main(String[] args) {
// Prints Hello, World! on standard output.
System.out.println("Hello World!");
}
}
533Java
You can include required HTML tags inside the description part. For instance, the following
example makes use of <h1>....</h1> for heading and <p> has been used for creating
paragraph break:
/**
* <h1>Hello, World!</h1>
* The HelloWorld program implements an application that
* simply displays "Hello World!" to the standard output.
* <p>
* Giving proper comments in your program makes it more
* user friendly and it is assumed as a high quality code.
*
*
* @author
Zara Ali
* @version 1.0
* @since
2014-03-31
*/
public class HelloWorld {
public static void main(String[] args) {
// Prints Hello, World! on standard output.
System.out.println("Hello World!");
}
}
The javadoc Tags
The javadoc tool recognizes the following tags:
Tag
Description
Syntax
@author Adds the author of a class. @author name-text
{@code} Displays text in code font without
interpreting the text as HTML markup or
nested javadoc tags. {@code text}
{@docRoot} Represents the relative path to the
generated document's root directory
from any generated page. {@docRoot}
@deprecated Adds a comment indicating that this API
should no longer be used. @deprecated
text
deprecated-
534Java
@exception Adds a Throws subheading to the
generated documentation, with the class-
name and description text. @exception
description
{@inheritDoc} Inherits a comment from the nearest
inheritable class or implementable
interface. Inherits a comment from
the immediate surperclass.
{@link} Inserts an in-line link with the visible text
label that points to the documentation for
the specified package, class, or member
name of a referenced class. {@link
package.class#member
label}
{@linkplain} Identical to {@link}, except the link's
label is displayed in plain text than code
font. {@linkplain
package.class#member
label}
@param Adds a parameter with the specified
parameter-name
followed
by
the
specified description to the "Parameters"
section. @param parameter-name
description
@return Adds a "Returns"
description text. @return description
section
with
the
class-name
@see Adds a "See Also" heading with a link or
text entry that points to reference. @see reference
@serial Used in the doc comment for a default
serializable field. @serial field-description |
include | exclude
@serialData Documents the data written by the
writeObject( ) or writeExternal( )
methods. @serialData
description
@serialField Documents
component. @serialField
field-name
field-type field-description
an
ObjectStreamField
data-
@since Adds a "Since" heading with the specified
since-text
to
the
generated
documentation. @since release
@throws The @throws and @exception tags are
synonyms. @throws
description
{@value} When {@value} is used in the doc
comment of a static field, it displays the
value of that constant. {@value
package.class#field}
class-name
535Java
Adds a "Version" subheading with the
specified version-text to the generated
docs when the -version option is used.
@version
@version version-text
Example
Following program uses few of the important tags available for documentation comments.
You can make use of other tags based on your requirements.
The documentation about the AddNum class will be produced in HTML file AddNum.html
but at the same time a master file with a name index.html will also be created.
import java.io.*;
/**
* <h1>Add Two Numbers!</h1>
* The AddNum program implements an application that
* simply adds two given integer numbers and Prints
* the output on the screen.
* <p>
* <b>Note:</b> Giving proper comments in your program makes it more
* user friendly and it is assumed as a high quality code.
*
* @author
Zara Ali
* @version 1.0
* @since
2014-03-31
*/
public class AddNum {
/**
* This method is used to add two integers. This is
* a the simplest form of a class method, just to
* show the usage of various javadoc Tags.
* @param numA This is the first paramter to addNum method
* @param numB
This is the second parameter to addNum method
* @return int This returns sum of numA and numB.
*/
public int addNum(int numA, int numB) {
return numA + numB;
}
536Java
/**
* This is the main method which makes use of addNum method.
* @param args Unused.
* @return Nothing.
* @exception IOException On input error.
* @see IOException
*/
public static void main(String args[]) throws IOException
{
AddNum obj = new AddNum();
int sum = obj.addNum(10, 20);
System.out.println("Sum of 10 and 20 is :" + sum);
}
}
Now, process the above AddNum.java file using javadoc utility as follows:
$ javadoc AddNum.java
Loading source file AddNum.java...
Constructing Javadoc information...
Standard Doclet version 1.7.0_51
Building tree for all the packages and classes...
Generating /AddNum.html...
AddNum.java:36: warning - @return tag cannot be used in method with void return
type.
Generating /package-frame.html...
Generating /package-summary.html...
Generating /package-tree.html...
Generating /constant-values.html...
Building index for all the packages and classes...
Generating /overview-tree.html...
Generating /index-all.html...
Generating /deprecated-list.html...
537Java
Building index for all classes...
Generating /allclasses-frame.html...
Generating /allclasses-noframe.html...
Generating /index.html...
Generating /help-doc.html...
1 warning
$
You can check all the generated documentation here: AddNum. If you are using JDK 1.7
then javadoc does not generate a great stylesheet.css, so we suggest to download and
use standard stylesheet from http://docs.oracle.com/javase/7/docs/api/stylesheet.css
538
